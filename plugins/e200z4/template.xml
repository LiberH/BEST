<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>/* TODO:
 *  - microbench for memory access time
 *  - set proper values for _Inst_t.cycles
 *  - should remove '_do'?
 */

//////////////////////////////////////////
////////////////// Types and Constants: //
//////////////////////////////////////////

/* Binary: */

typedef struct {
  int index; // in bit field
  int value; // when set alone
} B_BitField_t;

/* Flash: */

const int FLASH_BURST_MAX =  4;
typedef struct {
  int[0, FLASH_BURST_MAX] burst_index;
} Flash_t;

const int FLASH_LATENCY = 10; // TODO: arbitrary; to set correctly

/* Static RAM (SRAM): */

const int SRAM_LATENCY = 10; // TODO: arbitrary; to set correctly

typedef struct {
  bool executing;
} SRAM_t;

/* Instruction Memory Unit (IMU): */

const int IMU_WAYS_MAX              =  2;
const int IMU_SETS_MAX              = 64;
const int IMU_FILLBUFFER_DWORDS_MAX =  4;

/*
const int IMU_FIRST_USED_SET = (_INSTS[           0].addr / 32) % IMU_SETS_MAX; // First 'in-use-at-run-time' set
const int IMU_LAST_USED_SET  = (_INSTS[_INST_MAX -1].addr / 32) % IMU_SETS_MAX; // Last  'in-use-at-run-time' set
const int IMU_USED_SETS_MAX  = IMU_LAST_USED_SET - IMU_FIRST_USED_SET +1;       // Number of 'used' sets
*/
const int IMU_USED_SETS_MAX = IMU_SETS_MAX;

typedef struct {
  int[-1, _INST_MAX -1] index;
  int[0, IMU_WAYS_MAX -1] rp_way;
  int tags[IMU_WAYS_MAX][IMU_USED_SETS_MAX];
} IMU_ICache_t;

typedef struct {
  int[-1, _INST_MAX -1] index;
  int[-1, IMU_FILLBUFFER_DWORDS_MAX -1] dword;
  int[-1, IMU_SETS_MAX -1] set;
  int tag; // TODO: set a range as [-1, ???]
  bool filled[IMU_FILLBUFFER_DWORDS_MAX];
} IMU_FillBuffer_t;
const IMU_FillBuffer_t IMU_EMPTY_FILLBUFFER_LINE = { -1, -1, -1, -1, { false, false, false, false } };

typedef struct {
  IMU_FillBuffer_t FillBuffer;
  IMU_ICache_t ICache;
} IMU_t;

const int IMU_CACHE_HIT       = 0;
const int IMU_FILLBUFFER_HIT  = 1;
const int IMU_FILLBUFFER_MISS = 2;
const int IMU_CACHE_MISS      = 3;

/* Instruction and Control Unit (InCU): */

const int INCU_STRONGLY_NOT_TAKEN = 0;
const int INCU_WEAKLY___NOT_TAKEN = 1;
const int INCU_WEAKLY_______TAKEN = 2;
const int INCU_STRONGLY_____TAKEN = 3;
typedef struct {
  int[-1, _INST_MAX -1] index;
  int[-1, INCU_STRONGLY_____TAKEN +1] prediction;
} InCU_BTB_Entry_t;

const int INCU_BTB_MAX = 8;
typedef struct {
  int[0, 8] top;
  InCU_BTB_Entry_t buffer[INCU_BTB_MAX];
} InCU_BTB_t;

typedef struct {
  int[-1, _INST_MAX -1] index;
  bool predict_taken;
  bool dynamic_prediction;
  bool taken;
} InCU_IBuff_Entry_t;
const InCU_IBuff_Entry_t INCU_EMPTY_IBUFF_ENTRY = { -1, false, false, false };

const int INCU_IBUFF_MAX = 8;
typedef struct {
  int[0, INCU_IBUFF_MAX] count;
  InCU_IBuff_Entry_t buffer[INCU_IBUFF_MAX];
} InCU_IBuff_t;

typedef struct {
  int[-1, _INST_MAX -1] index;
  bool predict_taken;
  bool dynamic_prediction;
  bool taken;
} InCU_IR_t;
const InCU_IR_t INCU_EMPTY_IR = { -1, false, false, false };

typedef struct {
  InCU_BTB_t BTB;
  int PC;
  InCU_IBuff_t IBuff;
  InCU_IR_t IR;
} InCU_t;

/* Execution Units (EUs): */

const int EUS_PIPELINE_D   = 0;
const int EUS_PIPELINE_E   = 1;
const int EUS_PIPELINE_M   = 2;
const int EUS_PIPELINE_W   = 3;
const int EUS_PIPELINE_MAX = 4;
const int EUS_CYCLES_MAX   = 5; // TODO: arbitrary; set properly
typedef struct {
  int pipeline[EUS_PIPELINE_MAX];
  bool predict_taken;
  bool dynamic_prediction;
  bool taken;
  int cycles;
} EUs_t;

//////////////////////////////////////////
///////////////////////// Declarations: //
//////////////////////////////////////////

/* (global:) */

clock _clock;

broadcast chan _doInitialize;
   urgent chan _doTerminate;
   urgent chan _do;

bool _mustTerminate;
bool _predict_taken;
bool _dynamic_prediction;
bool _taken;

/* Flash: */

Flash_t Flash;
clock Flash_clock;

urgent           chan Flash_doBurst;
urgent broadcast chan Flash_doneBurst[FLASH_BURST_MAX];

/* Static RAM (SRAM): */

SRAM_t SRAM;
clock SRAM_clock;

chan SRAM_doAccess;
chan SRAM_doneAccess;

/* Instruction Memory Unit (IMU): */

IMU_t IMU;
clock IMU_clock;

                 chan IMU_doneFill;
urgent           chan IMU_doAccess;
urgent broadcast chan IMU_doneAccess;

/* Instruction and Control Unit (InCU): */

InCU_t InCU;

/* Execution Units (EUs): */

EUs_t EUs;
clock EUs_clock;
broadcast chan EUs_doStep;

//////////////////////////////////////////
//////////////////////////// Functions: //
//////////////////////////////////////////

/* (global:) */

void _Init() {
  _mustTerminate      = false;
  _predict_taken      = false;
  _dynamic_prediction = false;
  _taken              = false;
}

/* Binary: */

const int NONE               = 0;
const int CARRYING           = 1;
const int COMPLEMENTED       = 2;
const int EXTENDED           = 3;
const int EXTENDED_MINUS_ONE = 4;
const int EXTENDED_ZERO      = 5;
const int LOGICAL            = 6;
const int LOGICAL_UIMM       = 7;
const int SHIFTED            = 8;
const int SIGN_EXTENDED      = 9;

const B_BitField_t XER___ = { -1, -1 /* 0b0001 */ }; // Not used
const B_BitField_t XER_CA = {  1,  2 /* 0b0010 */ };
const B_BitField_t XER_OV = {  2,  4 /* 0b0100 */ };
const B_BitField_t XER_SO = {  3,  8 /* 0b1000 */ };

const B_BitField_t  CR_SO = {  0,  1 /* 0b0001 */ };
const B_BitField_t  CR_EQ = {  1,  2 /* 0b0010 */ };
const B_BitField_t  CR_GT = {  2,  4 /* 0b0100 */ };
const B_BitField_t  CR_LT = {  3,  8 /* 0b1000 */ };

bool getBit  ( sint32_t  field, uint5_t i            ) { return (((field &gt;&gt; i) % 2) == 1); }
int  getBits ( sint32_t  field, uint5_t i, uint5_t j ) { return ((field &gt;&gt; (32 -i)) &amp; (2^(j +1) -1)); } // TODO: check and fix
void setBit  ( sint32_t &amp;field, uint5_t i, uint1_t b ) { field |= (b &lt;&lt; i); }

bool  z () { return ((ctr -1) == 0);    }
bool eq () { return getBit(cr, CR_EQ.index); }
bool gt () { return getBit(cr, CR_GT.index); }
bool lt () { return getBit(cr, CR_LT.index); }
bool nz () { return !z();               }
bool ne () { return !eq();              }
bool le () { return !gt();              }
bool ge () { return !lt();              }

// Arithmetic instructions:

void _ARITHM( int qualifier, sint32_t &amp;rD, sint32_t rA, sint32_t rB_or_SIMM, uint1_t OE, uint1_t Rc ) {
  if ( qualifier == NONE               ) { rD = rA +  rB_or_SIMM;                                     }
  if ( qualifier == CARRYING           ) { rD = rA +  rB_or_SIMM;  setBit ( xer , XER_CA.index , 0 ); } // TODO: 0 -&gt; ?
  if ( qualifier == EXTENDED           ) { rD = rA +  rB_or_SIMM + getBit ( xer , XER_CA.index     ); }
  if ( qualifier == EXTENDED_MINUS_ONE ) { rD = rA -  1          + getBit ( xer , XER_CA.index     ); }
  if ( qualifier == EXTENDED_ZERO      ) { rD = rA               + getBit ( xer , XER_CA.index     ); }
  if ( qualifier == SHIFTED            ) { rD = rA + (rB_or_SIMM &lt;&lt; 16);                              }

  if ( OE ) { setBit (xer , XER_OV.index , 0);   // TODO: 0 -&gt; ?
              setBit (xer , XER_SO.index , 0); } // TODO: 0 -&gt; ?
  if ( Rc ) { setBit (cr  ,  CR_SO.index , 0);   // TODO: 0 -&gt; ?; cr -&gt; cr0
              setBit (cr  ,  CR_EQ.index , 0);   // TODO: 0 -&gt; ?; cr -&gt; cr0
              setBit (cr  ,  CR_GT.index , 0);   // TODO: 0 -&gt; ?; cr -&gt; cr0
              setBit (cr  ,  CR_LT.index , 0); } // TODO: 0 -&gt; ?; cr -&gt; cr0
}

void _add      ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( NONE               , rD ,  rA , rB   , false , false ); }
void _add_     ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( NONE               , rD ,  rA , rB   , false , true  ); }
void _addo     ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( NONE               , rD ,  rA , rB   , true  , false ); }
void _addo_    ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( NONE               , rD ,  rA , rB   , true  , true  ); }
void _addc     ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( CARRYING           , rD ,  rA , rB   , false , false ); }
void _addc_    ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( CARRYING           , rD ,  rA , rB   , false , true  ); }
void _addco    ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( CARRYING           , rD ,  rA , rB   , true  , false ); }
void _addco_   ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( CARRYING           , rD ,  rA , rB   , true  , true  ); }
void _adde     ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( EXTENDED           , rD ,  rA , rB   , false , false ); }
void _adde_    ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( EXTENDED           , rD ,  rA , rB   , false , true  ); }
void _addeo    ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( EXTENDED           , rD ,  rA , rB   , true  , false ); }
void _addeo_   ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( EXTENDED           , rD ,  rA , rB   , true  , true  ); }

void _addi     ( sint32_t &amp;rD , sint32_t rA   , sint16_t SIMM ) { _ARITHM( NONE               , rD ,  rA , SIMM , false , false ); }
void _addic    ( sint32_t &amp;rD , sint32_t rA   , sint16_t SIMM ) { _ARITHM( CARRYING           , rD ,  rA , SIMM , false , false ); }
void _addic_   ( sint32_t &amp;rD , sint32_t rA   , sint16_t SIMM ) { _ARITHM( CARRYING           , rD ,  rA , SIMM , false , true  ); }
void _addis    ( sint32_t &amp;rD , sint32_t rA   , sint16_t SIMM ) { _ARITHM( SHIFTED            , rD ,  rA , SIMM , false , false ); }

void _addme    ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_MINUS_ONE , rD ,  rA , 0    , false , false ); }
void _addme_   ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_MINUS_ONE , rD ,  rA , 0    , false , true  ); }
void _addmeo   ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_MINUS_ONE , rD ,  rA , 0    , true  , false ); }
void _addmeo_  ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_MINUS_ONE , rD ,  rA , 0    , true  , true  ); }
void _addze    ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_ZERO      , rD ,  rA , 0    , false , false ); }
void _addze_   ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_ZERO      , rD ,  rA , 0    , false , true  ); }
void _addzeo   ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_ZERO      , rD ,  rA , 0    , true  , false ); }
void _addzeo_  ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_ZERO      , rD ,  rA , 0    , true  , true  ); }

void _subf     ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( NONE               , rD , -rA , rB   , false , false ); }
void _subf_    ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( NONE               , rD , -rA , rB   , false , true  ); }
void _subfo    ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( NONE               , rD , -rA , rB   , true  , false ); }
void _subfo_   ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( NONE               , rD , -rA , rB   , true  , true  ); }
void _subfc    ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( CARRYING           , rD , -rA , rB   , false , false ); }
void _subfc_   ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( CARRYING           , rD , -rA , rB   , false , true  ); }
void _subfco   ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( CARRYING           , rD , -rA , rB   , true  , false ); }
void _subfco_  ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( CARRYING           , rD , -rA , rB   , true  , true  ); }
void _subfe    ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( EXTENDED           , rD , -rA , rB   , false , false ); }
void _subfe_   ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( EXTENDED           , rD , -rA , rB   , false , true  ); }
void _subfeo   ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( EXTENDED           , rD , -rA , rB   , true  , false ); }
void _subfeo_  ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _ARITHM( EXTENDED           , rD , -rA , rB   , true  , true  ); }

void _subfic   ( sint32_t &amp;rD , sint32_t rA   , sint16_t SIMM ) { _ARITHM( CARRYING           , rD , -rA , SIMM , false , false ); }

void _subfme   ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_MINUS_ONE , rD , -rA , 0    , false , false ); }
void _subfme_  ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_MINUS_ONE , rD , -rA , 0    , false , true  ); }
void _subfmeo  ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_MINUS_ONE , rD , -rA , 0    , true  , false ); }
void _subfmeo_ ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_MINUS_ONE , rD , -rA , 0    , true  , true  ); }
void _subfze   ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_ZERO      , rD , -rA , 0    , false , false ); }
void _subfze_  ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_ZERO      , rD , -rA , 0    , false , true  ); }
void _subfzeo  ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_ZERO      , rD , -rA , 0    , true  , false ); }
void _subfzeo_ ( sint32_t &amp;rD , sint32_t rA                   ) { _ARITHM( EXTENDED_ZERO      , rD , -rA , 0    , true  , true  ); }

void _li       ( sint32_t &amp;rD ,                 sint16_t SIMM ) { _addi   ( rD,  0,  SIMM ); }
void _lis      ( sint32_t &amp;rD ,                 sint16_t SIMM ) { _addis  ( rD,  0,  SIMM ); }
void _la       ( sint32_t &amp;rD , sint16_t SIMM , sint32_t rA   ) { _addi   ( rD, rA,  SIMM ); }
void _sub      ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _subf   ( rD, rB,  rA   ); }
void _subc     ( sint32_t &amp;rD , sint32_t rA   , sint32_t rB   ) { _subfc  ( rD, rB,  rA   ); }
void _subi     ( sint32_t &amp;rD , sint32_t rA   , sint16_t SIMM ) { _addi   ( rD, rA, -SIMM ); }
void _subis    ( sint32_t &amp;rD , sint32_t rA   , sint16_t SIMM ) { _addis  ( rD, rA, -SIMM ); }
void _subic    ( sint32_t &amp;rD , sint32_t rA   , sint16_t SIMM ) { _addic  ( rD, rA, -SIMM ); }
void _subic_   ( sint32_t &amp;rD , sint32_t rA   , sint16_t SIMM ) { _addic_ ( rD, rA, -SIMM ); }

// Logic instructions:

const int AND  = 0;
const int NAND = 1;
const int NEG  = 2;
const int NOR  = 3;
const int OR   = 4;
const int XOR  = 5;

void _LOGICAL( int operator, int qualifier, sint32_t &amp;rA_or_rD, sint32_t rS_or_rA, sint32_t rB_or_UIMM, uint1_t OE, uint1_t Rc ) {
  if ( operator  == AND            ) {
    if ( qualifier == NONE         ) { rA_or_rD =  rS_or_rA &amp;  rB_or_UIMM;        }
    if ( qualifier == COMPLEMENTED ) { rA_or_rD =  rS_or_rA &amp; -rB_or_UIMM;        } // TODO: check if -rB == complement(rB)
    if ( qualifier == SHIFTED      ) { rA_or_rD =  rS_or_rA &amp; (rB_or_UIMM &lt;&lt; 16); }}
  if ( operator  == NAND           ) { rA_or_rD = -rS_or_rA | -rB_or_UIMM;        } // TODO: check if -rS | -rB == rS NAND rB
  if ( operator  == NEG            ) { rA_or_rD = -rS_or_rA;                      } // TODO: check if -rA == NOT/NEG rA
  if ( operator  == NOR            ) { rA_or_rD = -rS_or_rA &amp; -rB_or_UIMM;        } // TODO: check if -rS &amp; -rB == rS NOR rB
  if ( operator  == OR             ) {
    if ( qualifier == NONE         ) { rA_or_rD =  rS_or_rA |  rB_or_UIMM;        }
    if ( qualifier == COMPLEMENTED ) { rA_or_rD =  rS_or_rA &amp; -rB_or_UIMM;        }}
  if ( operator  == XOR            ) { rA_or_rD =  rS_or_rA ^  rB_or_UIMM;        }

  if ( OE ) { setBit (xer , XER_OV.index , 0);   // TODO: 0 -&gt; ?
              setBit (xer , XER_SO.index , 0); } // TODO: 0 -&gt; ?
  if ( Rc ) { setBit (cr  ,  CR_SO.index , 0);   // TODO: 0 -&gt; ?; cr -&gt; cr0
              setBit (cr  ,  CR_EQ.index , 0);   // TODO: 0 -&gt; ?; cr -&gt; cr0
              setBit (cr  ,  CR_GT.index , 0);   // TODO: 0 -&gt; ?; cr -&gt; cr0
              setBit (cr  ,  CR_LT.index , 0); } // TODO: 0 -&gt; ?; cr -&gt; cr0
}

void _and    ( sint32_t &amp;rA, sint32_t rS, sint32_t rB   ) { _LOGICAL( AND  , NONE         , rA , rS , rB   , false , false ); }
void _and_   ( sint32_t &amp;rA, sint32_t rS, sint32_t rB   ) { _LOGICAL( AND  , NONE         , rA , rS , rB   , false , true  ); }
void _andc   ( sint32_t &amp;rA, sint32_t rS, sint32_t rB   ) { _LOGICAL( AND  , COMPLEMENTED , rA , rS , rB   , false , false ); }
void _andc_  ( sint32_t &amp;rA, sint32_t rS, sint32_t rB   ) { _LOGICAL( AND  , COMPLEMENTED , rA , rS , rB   , false , true  ); }
void _andi_  ( sint32_t &amp;rA, sint32_t rS, sint16_t UIMM ) { _LOGICAL( AND  , NONE         , rA , rS , UIMM , false , true  ); }
void _andis_ ( sint32_t &amp;rA, sint32_t rS, sint16_t UIMM ) { _LOGICAL( AND  , SHIFTED      , rA , rS , UIMM , false , true  ); }

void _nand   ( sint32_t &amp;rA, sint32_t rS, sint32_t rB   ) { _LOGICAL( NAND , NONE         , rA , rS , rB   , false , false ); }
void _nand_  ( sint32_t &amp;rA, sint32_t rS, sint32_t rB   ) { _LOGICAL( NAND , NONE         , rA , rS , rB   , false , true  ); }

void _neg    ( sint32_t &amp;rD, sint32_t rA                ) { _LOGICAL( NEG  , NONE         , rD , rA , 0    , false , false ); }
void _neg_   ( sint32_t &amp;rD, sint32_t rA                ) { _LOGICAL( NEG  , NONE         , rD , rA , 0    , false , true  ); }
void _nego   ( sint32_t &amp;rD, sint32_t rA                ) { _LOGICAL( NEG  , NONE         , rD , rA , 0    , true  , false ); }
void _nego_  ( sint32_t &amp;rD, sint32_t rA                ) { _LOGICAL( NEG  , NONE         , rD , rA , 0    , true  , true  ); }

void _nor    ( sint32_t &amp;rA, sint32_t rS, sint32_t rB   ) { _LOGICAL( NOR  , NONE         , rA , rS , rB   , false , false ); }
void _nor_   ( sint32_t &amp;rA, sint32_t rS, sint32_t rB   ) { _LOGICAL( NOR  , NONE         , rA , rS , rB   , false , true  ); }

void _or     ( sint32_t &amp;rA, sint32_t rS, sint32_t rB   ) { _LOGICAL( OR   , NONE         , rA , rS , rB   , false , false ); }
void _or_    ( sint32_t &amp;rA, sint32_t rS, sint32_t rB   ) { _LOGICAL( OR   , NONE         , rA , rS , rB   , false , true  ); }
void _orc    ( sint32_t &amp;rA, sint32_t rS, sint32_t rB   ) { _LOGICAL( OR   , COMPLEMENTED , rA , rS , rB   , false , false ); }
void _orc_   ( sint32_t &amp;rA, sint32_t rS, sint32_t rB   ) { _LOGICAL( OR   , COMPLEMENTED , rA , rS , rB   , false , true  ); }
void _ori    ( sint32_t &amp;rA, sint32_t rS, sint16_t UIMM ) { _LOGICAL( OR   , NONE         , rA , rS , UIMM , false , false ); }
void _oris   ( sint32_t &amp;rA, sint32_t rS, sint16_t UIMM ) { _LOGICAL( OR   , SHIFTED      , rA , rS , UIMM , false , false ); }

void _xor    ( sint32_t &amp;rA, sint32_t rS, sint32_t rB   ) { _LOGICAL( XOR  , NONE         , rA , rS , rB   , false , false ); }
void _xor_   ( sint32_t &amp;rA, sint32_t rS, sint32_t rB   ) { _LOGICAL( XOR  , NONE         , rA , rS , rB   , false , true  ); }
void _xori   ( sint32_t &amp;rA, sint32_t rS, sint16_t UIMM ) { _LOGICAL( XOR  , NONE         , rA , rS , UIMM , false , false ); }
void _xoris  ( sint32_t &amp;rA, sint32_t rS, sint16_t UIMM ) { _LOGICAL( XOR  , SHIFTED      , rA , rS , UIMM , false , false ); }

void _not    ( sint32_t &amp;rA, sint32_t rS                ) { _nor ( rA, rS, rS ); }
void _mr     ( sint32_t &amp;rA, sint32_t rS                ) { _or  ( rA, rS, rS ); }
void _nop    (                                          ) { /*  "ori 0,0,0"   */ }

/*
/////

/////

void _mullw  ( sint32_t &amp;rD, sint32_t rA, sint32_t rB   ) { rD = rA * rB;                          }
void _mullw_ ( sint32_t &amp;rD, sint32_t rA, sint32_t rB   ) { rD = rA * rB;                          } // TODO: add proper affectation for CR0
void _mulli  ( sint32_t &amp;rD, sint32_t rA, sint32_t SIMM ) { rD = rA * SIMM;                        }
void _mulhw  ( sint32_t &amp;rD, sint32_t rA, sint32_t rB   ) { rD = getBits(rA * rB, 32, 63);           } // TODO: check if correct according to specs
void _mulhwu ( sint32_t &amp;rD, sint32_t rA, sint32_t rB   ) { rD = getBits(rA * rB, 32, 63);           } // TODO: TODO: check if correct according to specs + fix; should be 'unsigned'
void _divw   ( sint32_t &amp;rD, sint32_t rA, sint32_t rB   ) { rD = rA / rB;                          }
void _divwu  ( sint32_t &amp;rD, sint32_t rA, sint32_t rB   ) { rD = rA / rB;                          } // TODO: fix; should be 'unsigned'

void _extsh ( sint32_t &amp;rA, sint32_t rS ) { rA = rS &amp; 65535; } // == 0xffff (hex. doesn't work in UPPAAL...)

/////

sint32_t ROTL ( sint32_t x, sint32_t y ) { return 0; } // TODO: implement according to the semantics given in the specs
sint32_t MASK ( sint32_t x, sint32_t y ) { return 0; } // TODO: implement according to the semantics given in the specs

void _rlwinm ( sint32_t &amp;rA, sint32_t rS, sint32_t SH, sint32_t MB, sint32_t ME ) {
  sint32_t n = SH;
  sint32_t r = ROTL(rS, n);
  sint32_t m = MASK(MB, ME);

  rA = r &amp; m;
}

void _clrlwi ( sint32_t &amp;rA, sint32_t rS, sint32_t n ) { _rlwinm(rA, rS, 0, n, 31); } // TODO: n &lt; 32

void _slw ( sint32_t &amp;rA, sint32_t rS, sint32_t rB ) {
  sint32_t n = getBits(rB, 0, 5); // TODO: check; specs says "rB[27-31]" (btw. shouldn't it be "rB[26-31]"?)
  sint32_t r = ROTL(rS, n);
  sint32_t m = 0;
  if (getBit(rB, 6) == 0) m = MASK(0, n - 31); // TODO: check and fix; lines are missing in the specs...

  rA = r &amp; m;
}

void _srw ( sint32_t &amp;rA, sint32_t rS, sint32_t rB ) {
  sint32_t n = getBits(rB, 0, 5); // TODO: check; specs says "rB[27-31]" (btw. shouldn't it be "rB[26-31]"?)
  sint32_t r = ROTL(rS, 32 - n);
  sint32_t m = 0;
  if (getBit(rB, 6) == 0) m = MASK(n, 31); // TODO: check and fix; lines are missing in the specs...

  rA = r &amp; m;
}

void _sraw ( sint32_t &amp;rA, sint32_t rS, sint32_t rB ) {
  sint32_t n = getBits(rB, 0, 5); // TODO: check; specs says "rB[27-31]" (btw. shouldn't it be "rB[26-31]"?)
  sint32_t r = ROTL(rS, n);
  sint32_t S  = rS;
  sint32_t m = 0;
  if (getBit(rB, 6) == 0) m = MASK(0, n);

  rA = r &amp; m | S &amp; !m;
  xer = S &amp; ((r &amp; !m) != 0); // TODO: check xer implementation
}

void _srawi ( sint32_t &amp;rA, sint32_t rS, sint32_t SH ) { // TODO: check the operator precedence; must be needed some parentheses
  sint32_t n = SH;
  sint32_t r = ROTL(rS, 32 - n);
  sint32_t S = rS;
  sint32_t m = MASK(0, n); // TODO: check and fix; it says "MASK(n)" in the specs but there is no semantics for it...

  rA  = r &amp; m | S &amp; !m;
  xer = S &amp; ((r &amp; !m) != 0); // TODO: check xer implementation
}

void _srawi_ ( sint32_t &amp;rA, sint32_t rS, sint32_t SH ) { // TODO: same as srawi + add proper affectation for CR0
  sint32_t n = SH;
  sint32_t r = ROTL(rS, 32 - n);
  sint32_t S = rS;
  sint32_t m = MASK(0, n);

  rA  = r &amp; m | S &amp; !m;
  xer = S &amp; ((r &amp; !m) != 0);
}

void _cntlzw ( sint32_t &amp; rA, sint32_t rS ) {
  sint32_t n = 0;
  bool doBreak; // TODO: check if correct according to specs (there is no "break" keyword in UPPAAL...)
  while (n &lt; 32 &amp;&amp; !doBreak)
    if (getBit(rS, n) == 1) doBreak = true;
    else                  n       = n + 1;

  rA = n;
}

*/

// Register move instructions:
 
void _mfcr  ( sint32_t &amp;rD                ) { rD  = cr;                      }

void _mfxer ( sint32_t &amp;rD                ) { rD  = xer;                     }
void _mfctr ( sint32_t &amp;rD                ) { rD  = ctr;                     }
void _mfspr ( sint32_t &amp;rD , sint32_t spr ) { if (spr == 1) { _mfxer (rD); }
                                              if (spr == 9) { _mfctr (rD); } }

void _mtxer (                sint32_t rS  ) { xer = rS;                      }
void _mtctr (                sint32_t rS  ) { ctr = rS;                      }
void _mtspr ( sint32_t spr , sint32_t rS  ) { if (spr == 1) { _mtxer (rS); }
                                              if (spr == 9) { _mtctr (rS); } }

// Compare instructions:

sint32_t EXTS ( sint32_t x ) { return 0; } // TODO: how to perform a sign extension?

void _COMPARE( int qualifier, sint32_t &amp;crfD, uint1_t L, sint32_t rA, sint32_t rB_or_IMM ) {
  int a = rA;
  int b = rB_or_IMM;
  int c;

  if ( qualifier == NONE          ) { if ( L ) { a = EXTS(a); b = EXTS(b); } }
  if ( qualifier == SIGN_EXTENDED ) {                         b = EXTS(b);   }
  if ( qualifier == LOGICAL       ) {                                        } // TODO: how to perform an unsigned evaluation?
  if ( qualifier == LOGICAL_UIMM  ) {                                        } // TODO: how to perform an unsigned evaluation?

       if ( a &lt; b ) { c = CR_LT.value; }
  else if ( a &gt; b ) { c = CR_GT.value; }
  else              { c = CR_EQ.value; }

  crfD = c | getBit(xer, XER_SO.index); // TODO: crfD -&gt; CR[4 ∗ crfD–4 ∗ crfD + 3]
}

void _cmp    ( sint32_t &amp;crfD , sint32_t rA , sint32_t rB   ) { _COMPARE( NONE          , crfD , false , rA , rB   ); }
void _cmpi   ( sint32_t &amp;crfD , sint32_t rA , sint16_t SIMM ) { _COMPARE( SIGN_EXTENDED , crfD , false , rA , SIMM ); }
void _cmpl   ( sint32_t &amp;crfD , sint32_t rA , sint32_t rB   ) { _COMPARE( LOGICAL       , crfD , false , rA , rB   ); }
void _cmpli  ( sint32_t &amp;crfD , sint32_t rA , sint16_t UIMM ) { _COMPARE( LOGICAL_UIMM  , crfD , false , rA , UIMM ); }

void _cmpw   ( sint32_t &amp;crfD , sint32_t rA , sint32_t rB   ) { _cmp   ( crfD, rA, rB   ); }
void _cmpwi  ( sint32_t &amp;crfD , sint32_t rA , sint16_t SIMM ) { _cmpi  ( crfD, rA, SIMM ); }
void _cmplw  ( sint32_t &amp;crfD , sint32_t rA , sint32_t rB   ) { _cmpl  ( crfD, rA, rB   ); }
void _cmplwi ( sint32_t &amp;crfD , sint32_t rA , sint16_t UIMM ) { _cmpli ( crfD, rA, UIMM ); }

// Branching instructions:

const int BO_not_ctr_not_cond =  0;
const int BO_____ctr_not_cond =  2;
const int BO_________not_cond =  4;
const int BO_not_ctr_____cond =  8;
const int BO_____ctr_____cond = 10;
const int BO_____________cond = 12;
const int BO_not_ctr_________ = 16;
const int BO_____ctr_________ = 18;
const int BO_________________ = 20; // Branch always

void _BRANCH( uint5_t BO, uint5_t BI, sint16_t BD_or_LI , uint1_t AA, uint1_t LK ) {
  // TODO:

  bool ctr_ok, cond_ok;
  if (!getBit(BO, 2)) { ctr = ctr -1; }
  ctr_ok  = getBit(BO, 2) || ((ctr != 0) ^ getBit(BO, 1)); // ^ is XOR
  cond_ok = getBit(BO, 4) || (getBit(cr, BI) == getBit(BO, 3));
  if (ctr_ok &amp;&amp; cond_ok) {
    /* TODO or not TODO? That is the question. */
  }
}

void _b        (                           sint16_t LI ) { _BRANCH( 0  , 0  , LI , false , false ); }
void _ba       (                           sint16_t LI ) { _BRANCH( 0  , 0  , LI , true  , false ); }
void _bl       (                           sint16_t LI ) { _BRANCH( 0  , 0  , LI , false , true  ); }
void _bla      (                           sint16_t LI ) { _BRANCH( 0  , 0  , LI , true  , true  ); }
void _bc       ( uint5_t BO , uint5_t BI , sint16_t BD ) { _BRANCH( BO , BI , BD , false , false ); }
void _bca      ( uint5_t BO , uint5_t BI , sint16_t BD ) { _BRANCH( BO , BI , BD , true  , false ); }
void _bcl      ( uint5_t BO , uint5_t BI , sint16_t BD ) { _BRANCH( BO , BI , BD , false , true  ); }
void _bcla     ( uint5_t BO , uint5_t BI , sint16_t BD ) { _BRANCH( BO , BI , BD , true  , true  ); }
void _bcctr    ( uint5_t BO , uint5_t BI               ) { _BRANCH( BO , BI , 0  , false , false ); }
void _bcctrl   ( uint5_t BO , uint5_t BI               ) { _BRANCH( BO , BI , 0  , false , true  ); }
void _bclr     ( uint5_t BO , uint5_t BI               ) { _BRANCH( BO , BI , 0  , false , false ); }
void _bclrl    ( uint5_t BO , uint5_t BI               ) { _BRANCH( BO , BI , 0  , false , true  ); }

void _bt       ( sint16_t BD ) { _bc     ( BO_____________cond , 0           , BD ); }
void _bf       ( sint16_t BD ) { _bc     ( BO_________not_cond , 0           , BD ); }
void _bdnz     ( sint16_t BD ) { _bc     ( BO_not_ctr_________ , 0           , BD ); }
void _bdnzt    ( sint16_t BD ) { _bc     ( BO_not_ctr_____cond , 0           , BD ); }
void _bdnzf    ( sint16_t BD ) { _bc     ( BO_not_ctr_not_cond , 0           , BD ); }
void _bdz      ( sint16_t BD ) { _bc     ( BO_____ctr_________ , 0           , BD ); }
void _bdzt     ( sint16_t BD ) { _bc     ( BO_____ctr_____cond , 0           , BD ); }
void _bdzf     ( sint16_t BD ) { _bc     ( BO_____ctr_not_cond , 0           , BD ); }
void _blt      ( sint16_t BD ) { _bc     ( BO_____________cond , CR_LT.index , BD ); }
void _ble      ( sint16_t BD ) { _bc     ( BO_________not_cond , CR_GT.index , BD ); }
void _beq      ( sint16_t BD ) { _bc     ( BO_____________cond , CR_EQ.index , BD ); }
void _bge      ( sint16_t BD ) { _bc     ( BO_________not_cond , CR_LT.index , BD ); }
void _bgt      ( sint16_t BD ) { _bc     ( BO_____________cond , CR_GT.index , BD ); }
void _bnl      ( sint16_t BD ) { _bc     ( BO_________not_cond , CR_LT.index , BD ); }
void _bne      ( sint16_t BD ) { _bc     ( BO_________not_cond , CR_EQ.index , BD ); }
void _bng      ( sint16_t BD ) { _bc     ( BO_________not_cond , CR_GT.index , BD ); }
void _bso      ( sint16_t BD ) { _bc     ( BO_____________cond , CR_SO.index , BD ); }
void _bns      ( sint16_t BD ) { _bc     ( BO_________not_cond , CR_SO.index , BD ); }
void _bun      ( sint16_t BD ) { _bc     ( BO_____________cond , CR_SO.index , BD ); }
void _bnu      ( sint16_t BD ) { _bc     ( BO_________not_cond , CR_SO.index , BD ); }

void _bta      ( sint16_t BD ) { _bca    ( BO_____________cond , 0           , BD ); }
void _bfa      ( sint16_t BD ) { _bca    ( BO_________not_cond , 0           , BD ); }
void _bdnza    ( sint16_t BD ) { _bca    ( BO_not_ctr_________ , 0           , BD ); }
void _bdnzta   ( sint16_t BD ) { _bca    ( BO_not_ctr_____cond , 0           , BD ); }
void _bdnzfa   ( sint16_t BD ) { _bca    ( BO_not_ctr_not_cond , 0           , BD ); }
void _bdza     ( sint16_t BD ) { _bca    ( BO_____ctr_________ , 0           , BD ); }
void _bdzta    ( sint16_t BD ) { _bca    ( BO_____ctr_____cond , 0           , BD ); }
void _bdzfa    ( sint16_t BD ) { _bca    ( BO_____ctr_not_cond , 0           , BD ); }
void _blta     ( sint16_t BD ) { _bca    ( BO_____________cond , CR_LT.index , BD ); }
void _blea     ( sint16_t BD ) { _bca    ( BO_________not_cond , CR_GT.index , BD ); }
void _beqa     ( sint16_t BD ) { _bca    ( BO_____________cond , CR_EQ.index , BD ); }
void _bgea     ( sint16_t BD ) { _bca    ( BO_________not_cond , CR_LT.index , BD ); }
void _bgta     ( sint16_t BD ) { _bca    ( BO_____________cond , CR_GT.index , BD ); }
void _bnla     ( sint16_t BD ) { _bca    ( BO_________not_cond , CR_LT.index , BD ); }
void _bnea     ( sint16_t BD ) { _bca    ( BO_________not_cond , CR_EQ.index , BD ); }
void _bnga     ( sint16_t BD ) { _bca    ( BO_________not_cond , CR_GT.index , BD ); }
void _bsoa     ( sint16_t BD ) { _bca    ( BO_____________cond , CR_SO.index , BD ); }
void _bnsa     ( sint16_t BD ) { _bca    ( BO_________not_cond , CR_SO.index , BD ); }
void _buna     ( sint16_t BD ) { _bca    ( BO_____________cond , CR_SO.index , BD ); }
void _bnua     ( sint16_t BD ) { _bca    ( BO_________not_cond , CR_SO.index , BD ); }

void _btl      ( sint16_t BD ) { _bcl    ( BO_____________cond , 0           , BD ); }
void _bfl      ( sint16_t BD ) { _bcl    ( BO_________not_cond , 0           , BD ); }
void _bdnzl    ( sint16_t BD ) { _bcl    ( BO_not_ctr_________ , 0           , BD ); }
void _bdnztl   ( sint16_t BD ) { _bcl    ( BO_not_ctr_____cond , 0           , BD ); }
void _bdnzfl   ( sint16_t BD ) { _bcl    ( BO_not_ctr_not_cond , 0           , BD ); }
void _bdzl     ( sint16_t BD ) { _bcl    ( BO_____ctr_________ , 0           , BD ); }
void _bdztl    ( sint16_t BD ) { _bcl    ( BO_____ctr_____cond , 0           , BD ); }
void _bdzfl    ( sint16_t BD ) { _bcl    ( BO_____ctr_not_cond , 0           , BD ); }
void _bltl     ( sint16_t BD ) { _bcl    ( BO_____________cond , CR_LT.index , BD ); }
void _blel     ( sint16_t BD ) { _bcl    ( BO_________not_cond , CR_GT.index , BD ); }
void _beql     ( sint16_t BD ) { _bcl    ( BO_____________cond , CR_EQ.index , BD ); }
void _bgel     ( sint16_t BD ) { _bcl    ( BO_________not_cond , CR_LT.index , BD ); }
void _bgtl     ( sint16_t BD ) { _bcl    ( BO_____________cond , CR_GT.index , BD ); }
void _bnll     ( sint16_t BD ) { _bcl    ( BO_________not_cond , CR_LT.index , BD ); }
void _bnel     ( sint16_t BD ) { _bcl    ( BO_________not_cond , CR_EQ.index , BD ); }
void _bngl     ( sint16_t BD ) { _bcl    ( BO_________not_cond , CR_GT.index , BD ); }
void _bsol     ( sint16_t BD ) { _bcl    ( BO_____________cond , CR_SO.index , BD ); }
void _bnsl     ( sint16_t BD ) { _bcl    ( BO_________not_cond , CR_SO.index , BD ); }
void _bunl     ( sint16_t BD ) { _bcl    ( BO_____________cond , CR_SO.index , BD ); }
void _bnul     ( sint16_t BD ) { _bcl    ( BO_________not_cond , CR_SO.index , BD ); }

void _btla     ( sint16_t BD ) { _bcla   ( BO_____________cond , 0           , BD ); }
void _bfla     ( sint16_t BD ) { _bcla   ( BO_________not_cond , 0           , BD ); }
void _bdnzla   ( sint16_t BD ) { _bcla   ( BO_not_ctr_________ , 0           , BD ); }
void _bdnztla  ( sint16_t BD ) { _bcla   ( BO_not_ctr_____cond , 0           , BD ); }
void _bdnzfla  ( sint16_t BD ) { _bcla   ( BO_not_ctr_not_cond , 0           , BD ); }
void _bdzla    ( sint16_t BD ) { _bcla   ( BO_____ctr_________ , 0           , BD ); }
void _bdztla   ( sint16_t BD ) { _bcla   ( BO_____ctr_____cond , 0           , BD ); }
void _bdzfla   ( sint16_t BD ) { _bcla   ( BO_____ctr_not_cond , 0           , BD ); }
void _bltla    ( sint16_t BD ) { _bcla   ( BO_____________cond , CR_LT.index , BD ); }
void _blela    ( sint16_t BD ) { _bcla   ( BO_________not_cond , CR_GT.index , BD ); }
void _beqla    ( sint16_t BD ) { _bcla   ( BO_____________cond , CR_EQ.index , BD ); }
void _bgela    ( sint16_t BD ) { _bcla   ( BO_________not_cond , CR_LT.index , BD ); }
void _bgtla    ( sint16_t BD ) { _bcla   ( BO_____________cond , CR_GT.index , BD ); }
void _bnlla    ( sint16_t BD ) { _bcla   ( BO_________not_cond , CR_LT.index , BD ); }
void _bnela    ( sint16_t BD ) { _bcla   ( BO_________not_cond , CR_EQ.index , BD ); }
void _bngla    ( sint16_t BD ) { _bcla   ( BO_________not_cond , CR_GT.index , BD ); }
void _bsola    ( sint16_t BD ) { _bcla   ( BO_____________cond , CR_SO.index , BD ); }
void _bnsla    ( sint16_t BD ) { _bcla   ( BO_________not_cond , CR_SO.index , BD ); }
void _bunla    ( sint16_t BD ) { _bcla   ( BO_____________cond , CR_SO.index , BD ); }
void _bnula    ( sint16_t BD ) { _bcla   ( BO_________not_cond , CR_SO.index , BD ); }

void _blr      (             ) { _bclr   ( BO_________________ , 0                ); }
void _btlr     (             ) { _bclr   ( BO_____________cond , 0                ); }
void _bflr     (             ) { _bclr   ( BO_________not_cond , 0                ); }
void _bdnzlr   (             ) { _bclr   ( BO_not_ctr_________ , 0                ); }
void _bdnztlr  (             ) { _bclr   ( BO_not_ctr_____cond , 0                ); }
void _bdnzflr  (             ) { _bclr   ( BO_not_ctr_not_cond , 0                ); }
void _bdzlr    (             ) { _bclr   ( BO_____ctr_________ , 0                ); }
void _bdztlr   (             ) { _bclr   ( BO_____ctr_____cond , 0                ); }
void _bdzflr   (             ) { _bclr   ( BO_____ctr_not_cond , 0                ); }
void _bltlr    (             ) { _bclr   ( BO_____________cond , CR_LT.index      ); }
void _blelr    (             ) { _bclr   ( BO_________not_cond , CR_GT.index      ); }
void _beqlr    (             ) { _bclr   ( BO_____________cond , CR_EQ.index      ); }
void _bgelr    (             ) { _bclr   ( BO_________not_cond , CR_LT.index      ); }
void _bgtlr    (             ) { _bclr   ( BO_____________cond , CR_GT.index      ); }
void _bnllr    (             ) { _bclr   ( BO_________not_cond , CR_LT.index      ); }
void _bnelr    (             ) { _bclr   ( BO_________not_cond , CR_EQ.index      ); }
void _bnglr    (             ) { _bclr   ( BO_________not_cond , CR_GT.index      ); }
void _bsolr    (             ) { _bclr   ( BO_____________cond , CR_SO.index      ); }
void _bnslr    (             ) { _bclr   ( BO_________not_cond , CR_SO.index      ); }
void _bunlr    (             ) { _bclr   ( BO_____________cond , CR_SO.index      ); }
void _bnulr    (             ) { _bclr   ( BO_________not_cond , CR_SO.index      ); }

void _bctr     (             ) { _bcctr  ( BO_________________ , 0                ); }
void _btctr    (             ) { _bcctr  ( BO_____________cond , 0                ); }
void _bfctr	   (             ) { _bcctr  ( BO_________not_cond , 0                ); }			        
void _bltctr   (             ) { _bcctr  ( BO_____________cond , CR_LT.index      ); }
void _blectr   (             ) { _bcctr  ( BO_________not_cond , CR_GT.index      ); }
void _beqctr   (             ) { _bcctr  ( BO_____________cond , CR_EQ.index      ); }
void _bgectr   (             ) { _bcctr  ( BO_________not_cond , CR_LT.index      ); }
void _bgtctr   (             ) { _bcctr  ( BO_____________cond , CR_GT.index      ); }
void _bnlctr   (             ) { _bcctr  ( BO_________not_cond , CR_LT.index      ); }
void _bnectr   (             ) { _bcctr  ( BO_________not_cond , CR_EQ.index      ); }
void _bngctr   (             ) { _bcctr  ( BO_________not_cond , CR_GT.index      ); }
void _bsoctr   (             ) { _bcctr  ( BO_____________cond , CR_SO.index      ); }
void _bnsctr   (             ) { _bcctr  ( BO_________not_cond , CR_SO.index      ); }
void _bunctr   (             ) { _bcctr  ( BO_____________cond , CR_SO.index      ); }
void _bnuctr   (             ) { _bcctr  ( BO_________not_cond , CR_SO.index      ); }
	                   						        
void _blrl     (             ) { _bclrl  ( BO_________________ , 0                ); }
void _btlrl    (             ) { _bclrl  ( BO_____________cond , 0                ); }
void _bflrl    (             ) { _bclrl  ( BO_________not_cond , 0                ); }
void _bdnzlrl  (             ) { _bclrl  ( BO_not_ctr_________ , 0                ); }
void _bdnztlrl (             ) { _bclrl  ( BO_not_ctr_____cond , 0                ); }
void _bdnzflrl (             ) { _bclrl  ( BO_not_ctr_not_cond , 0                ); }
void _bdzlrl   (             ) { _bclrl  ( BO_____ctr_________ , 0                ); }
void _bdztlrl  (             ) { _bclrl  ( BO_____ctr_____cond , 0                ); }
void _bdzflrl  (             ) { _bclrl  ( BO_____ctr_not_cond , 0                ); }
void _bltlrl   (             ) { _bclrl  ( BO_____________cond , CR_LT.index      ); }
void _blelrl   (             ) { _bclrl  ( BO_________not_cond , CR_GT.index      ); }
void _beqlrl   (             ) { _bclrl  ( BO_____________cond , CR_EQ.index      ); }
void _bgelrl   (             ) { _bclrl  ( BO_________not_cond , CR_LT.index      ); }
void _bgtlrl   (             ) { _bclrl  ( BO_____________cond , CR_GT.index      ); }
void _bnllrl   (             ) { _bclrl  ( BO_________not_cond , CR_LT.index      ); }
void _bnelrl   (             ) { _bclrl  ( BO_________not_cond , CR_EQ.index      ); }
void _bnglrl   (             ) { _bclrl  ( BO_________not_cond , CR_GT.index      ); }
void _bsolrl   (             ) { _bclrl  ( BO_____________cond , CR_SO.index      ); }
void _bnslrl   (             ) { _bclrl  ( BO_________not_cond , CR_SO.index      ); }
void _bunlrl   (             ) { _bclrl  ( BO_____________cond , CR_SO.index      ); }
void _bnulrl   (             ) { _bclrl  ( BO_________not_cond , CR_SO.index      ); }
	                   						        
void _bctrl    (             ) { _bcctrl ( BO_________________ , 0                ); }
void _btctrl   (             ) { _bcctrl ( BO_____________cond , 0                ); }
void _bfctrl   (             ) { _bcctrl ( BO_________not_cond , 0                ); }	
void _bltctrl  (             ) { _bcctrl ( BO_____________cond , CR_LT.index      ); }
void _blectrl  (             ) { _bcctrl ( BO_________not_cond , CR_GT.index      ); }
void _beqctrl  (             ) { _bcctrl ( BO_____________cond , CR_EQ.index      ); }
void _bgectrl  (             ) { _bcctrl ( BO_________not_cond , CR_LT.index      ); }
void _bgtctrl  (             ) { _bcctrl ( BO_____________cond , CR_GT.index      ); }
void _bnlctrl  (             ) { _bcctrl ( BO_________not_cond , CR_LT.index      ); }
void _bnectrl  (             ) { _bcctrl ( BO_________not_cond , CR_EQ.index      ); }
void _bngctrl  (             ) { _bcctrl ( BO_________not_cond , CR_GT.index      ); }
void _bsoctrl  (             ) { _bcctrl ( BO_____________cond , CR_SO.index      ); }
void _bnsctrl  (             ) { _bcctrl ( BO_________not_cond , CR_SO.index      ); }
void _bunctrl  (             ) { _bcctrl ( BO_____________cond , CR_SO.index      ); }
void _bnuctrl  (             ) { _bcctrl ( BO_________not_cond , CR_SO.index      ); }

// Memory instructions:

sint32_t MEM ( sint32_t x, sint32_t y ) { return 0; } // TODO: what to do with memory accesses?

void _lbz  ( sint32_t &amp;rD, sint32_t  d, sint32_t  rA ) { rD = MEM((d  + rA), 1);              }
void _lbzu ( sint32_t &amp;rD, sint32_t  d, sint32_t  rA ) { rD = MEM((d  + rA), 1); rA = d + rA; }
void _lbzx ( sint32_t &amp;rD, sint32_t rA, sint32_t  rB ) { rD = MEM((rA + rB), 1);              }
void _lhz  ( sint32_t &amp;rD, sint32_t  d, sint32_t  rA ) { rD = MEM((d  + rA), 2);              }
void _lhzx ( sint32_t &amp;rD, sint32_t rA, sint32_t  rB ) { rD = MEM((rA + rB), 2);              }
void _lwz  ( sint32_t &amp;rD, sint32_t  d, sint32_t  rA ) { rD = MEM((d  + rA), 4);              }
void _lwzu ( sint32_t &amp;rD, sint32_t  d, sint32_t &amp;rA ) { rD = MEM((d  + rA), 4); rA = d + rA; }
void _lwzx ( sint32_t &amp;rD, sint32_t rA, sint32_t  rB ) { rD = MEM((rA + rB), 4);              }
void _stwu ( sint32_t  rS, sint32_t  d, sint32_t &amp;rA ) {                         rA = d + rA; }

/* Flash: */

void Flash_Init() {
  Flash.burst_index = 0;
}

bool Flash_IsTerminated() {
  return _mustTerminate;
}

/* Static RAM (SRAM): */

void SRAM_Init() {
  SRAM.executing = false;
}

bool SRAM_IsAccessed() {
  return ((EUs.pipeline[EUS_PIPELINE_E] != -1) &amp;&amp;
          _INSTS[EUs.pipeline[EUS_PIPELINE_E]].do_memory);
}

bool SRAM_IsTerminated() {
  return _mustTerminate;
}

/* Instruction Memory Unit (IMU): */

void IMU_Init(){
  int w, s;

  IMU.FillBuffer   = IMU_EMPTY_FILLBUFFER_LINE;
  IMU.ICache.index = -1;
  IMU.ICache.rp_way =  0;
  for (w = 0; w &lt; IMU_WAYS_MAX; ++w)
    for (s = 0; s &lt; IMU_USED_SETS_MAX; ++s)
      IMU.ICache.tags[w][s] = -1;
}

bool IMU_IsAccessed(int index) {
  return (IMU.ICache.index == index);
}

bool IMU_IsTerminated() {
  return _mustTerminate;
}

void IMU_Set() {
  IMU.ICache.index = InCU.PC;
}

void IMU_FillBuffer_Update() {
  IMU.FillBuffer.filled[IMU.FillBuffer.dword] = true;
  IMU.FillBuffer.dword = (IMU.FillBuffer.dword +1) % IMU_FILLBUFFER_DWORDS_MAX;
}

int IMU_ICache_Lookup() {
  // return wether the current instruction is in the instruction cache (or line buffer) or not
  int                          addr  = _INSTS[IMU.ICache.index].addr;
  int[0, IMU_WAYS_MAX]         way;
  int[0, IMU_USED_SETS_MAX -1] set   = (addr /  32) % IMU_SETS_MAX;
  int                          tag   =  addr / (32  * IMU_SETS_MAX);
  int                          dword = (addr /   8) % IMU_FILLBUFFER_DWORDS_MAX;

  // Is in cache?
  int icache_tag;
  for (way = 0; way &lt; IMU_WAYS_MAX; ++way) {
    icache_tag = IMU.ICache.tags[way][set];

    if (icache_tag != -1
    &amp;&amp;  icache_tag == tag)
      return IMU_CACHE_HIT;
  }

  // Is in fill buffer?
  if (IMU.FillBuffer.set == set
  &amp;&amp;  IMU.FillBuffer.tag == tag) {
    if (IMU.FillBuffer.filled[dword]) return IMU_FILLBUFFER_HIT;
    else                              return IMU_FILLBUFFER_MISS;
  }

  return IMU_CACHE_MISS;
}

bool IMU_ICache_Hit      () { return ( IMU_ICache_Lookup() == IMU_CACHE_HIT       ); }
bool IMU_FillBuffer_Hit  () { return ( IMU_ICache_Lookup() == IMU_FILLBUFFER_HIT  ); }
bool IMU_FillBuffer_Miss () { return ( IMU_ICache_Lookup() == IMU_FILLBUFFER_MISS ); }
bool IMU_ICache_Miss     () { return ( IMU_ICache_Lookup() == IMU_CACHE_MISS      ); }

void IMU_ICache_Update() {
  // on a miss, insert the current instruction on the instruction cache
  int                          addr = _INSTS[IMU.FillBuffer.index].addr;
  int[0, IMU_WAYS_MAX]         way;
  int[0, IMU_USED_SETS_MAX -1] set   = (addr /  32) % IMU_SETS_MAX;
  int                          tag   =  addr / (32  * IMU_SETS_MAX);

  bool found = false;

  way = 0;
  while (!found &amp;&amp; way &lt; IMU_WAYS_MAX)
    if (IMU.ICache.tags[way][set] == -1)
      found = true;
    else ++way; // conditional increment (thus not a for loop)
  if (found) {
    // free slot found
    IMU.ICache.tags[way][set] = tag;

  } else {
    // no free slot found (pseudo round-robin replacement policy)
    way = IMU.ICache.rp_way;
    IMU.ICache.tags[way][set] = tag;
    IMU.ICache.rp_way = (IMU.ICache.rp_way +1) % IMU_WAYS_MAX;
  }
}

void IMU_FillBuffer_Set() {
  int                     addr = _INSTS[IMU.ICache.index].addr;
  int[0, IMU_SETS_MAX -1] set  = (addr /  32) % IMU_SETS_MAX;  // TODO: add _USED
  int                     tag  =  addr / (32  * IMU_SETS_MAX);

  IMU.FillBuffer       = IMU_EMPTY_FILLBUFFER_LINE;
  IMU.FillBuffer.index = IMU.ICache.index;
  IMU.FillBuffer.dword = (addr / 8) % IMU_FILLBUFFER_DWORDS_MAX;
  IMU.FillBuffer.set   = set;
  IMU.FillBuffer.tag   = tag;
}

/* Instruction and Control Unit (InCU): */

void InCU_Init() {
  int i;

  InCU.BTB.top = 0;
  for (i = 0; i &lt; INCU_BTB_MAX; ++i) {
    InCU.BTB.buffer[i].index = -1;
    InCU.BTB.buffer[i].prediction = -1;
  }

  InCU.PC = -1;
  InCU.IBuff.count = 0;
  for (i = 0; i &lt; INCU_IBUFF_MAX; ++i)
    InCU.IBuff.buffer[i] = INCU_EMPTY_IBUFF_ENTRY;  
  InCU.IR = INCU_EMPTY_IR;
}

int InCU_BTB_Predict(int index) {
  int i;
  int btb_index = -1;

  if (_INSTS[index].do_branch)
    for (i = 0; i &lt; INCU_BTB_MAX; ++i)
      if (InCU.BTB.buffer[i].index == index)
        btb_index = i;

  if (btb_index != -1) {
    if (InCU.BTB.buffer[btb_index].prediction == INCU_WEAKLY_______TAKEN
    ||  InCU.BTB.buffer[btb_index].prediction == INCU_STRONGLY_____TAKEN)
      return _INSTS[index].target;
  }

  return index +1;
}

void InCU_BTB_Update(int index, bool taken) {
  int i;
  int btb_index = -1;

  for (i = 0; i &lt; INCU_BTB_MAX; ++i)
    if (InCU.BTB.buffer[i].index == index)
      btb_index = i;
    
  if (btb_index != -1) {
    // Fix prediction
    if (taken) {
      InCU.BTB.buffer[btb_index].prediction =  InCU.BTB.buffer[btb_index].prediction +1;
      InCU.BTB.buffer[btb_index].prediction = (InCU.BTB.buffer[btb_index].prediction &gt; INCU_STRONGLY_____TAKEN) ? INCU_STRONGLY_____TAKEN : InCU.BTB.buffer[btb_index].prediction;
    } else {
      InCU.BTB.buffer[btb_index].prediction =  InCU.BTB.buffer[btb_index].prediction -1;
      InCU.BTB.buffer[btb_index].prediction = (InCU.BTB.buffer[btb_index].prediction &lt; INCU_STRONGLY_NOT_TAKEN) ? INCU_STRONGLY_NOT_TAKEN : InCU.BTB.buffer[btb_index].prediction;
    }

  } else {
    /* "On initial allocation of an entry to the BTB for a taken branch,
     *  the counter is initialized to the weakly-taken state."
     *  (cf. e200z4 manual, p. 4-7) */
    if (taken) { // Insert (FIFO)
      InCU_BTB_Entry_t new_entry = {index, INCU_WEAKLY_______TAKEN};

      InCU.BTB.buffer[InCU.BTB.top] = new_entry;
      InCU.BTB.top = (InCU.BTB.top +1) % INCU_BTB_MAX;
    }
  }
}

void InCU_PC_Update() {
  int i;
  int index;
  
  if (InCU.PC != IMU.ICache.index)
    return;

  InCU.PC = InCU_BTB_Predict(InCU.PC);
  for (i = 0; i &lt; INCU_BTB_MAX; ++i)
    if (InCU.BTB.buffer[i].index == InCU.PC) {
      
      _dynamic_prediction = true;
      index = InCU_BTB_Predict(InCU.PC);
      if (index != InCU.PC +1)
	    _predict_taken = true;

      return;
    }
}

bool InCU_IBuff_IsFull() {
  return (InCU.IBuff.count == INCU_IBUFF_MAX);
}

void InCU_IBuff_Push() {
  if (InCU.PC != IMU.ICache.index)
    return;

  if (InCU.IR.index == -1) {
    InCU.IR.index              = IMU.ICache.index;
    InCU.IR.predict_taken      = _predict_taken;
    InCU.IR.dynamic_prediction = _dynamic_prediction;
    InCU.IR.taken              = _taken;
    
  } else {
    InCU.IBuff.buffer[InCU.IBuff.count].index              = IMU.ICache.index;
    InCU.IBuff.buffer[InCU.IBuff.count].predict_taken      = _predict_taken;
    InCU.IBuff.buffer[InCU.IBuff.count].dynamic_prediction = _dynamic_prediction;
    InCU.IBuff.buffer[InCU.IBuff.count].taken              = _taken;
    InCU.IBuff.count++;
  }
  
  _predict_taken      = false;
  _dynamic_prediction = false;
  _taken              = false;
}

InCU_IR_t InCU_IBuff_Pop() {
  InCU_IR_t entry = INCU_EMPTY_IR;

  if (InCU.IBuff.count &gt; 0) {
    entry.index              = InCU.IBuff.buffer[0].index;
    entry.predict_taken      = InCU.IBuff.buffer[0].predict_taken;
    entry.dynamic_prediction = InCU.IBuff.buffer[0].dynamic_prediction;
    entry.taken              = InCU.IBuff.buffer[0].taken;
    
    InCU.IBuff.buffer[0] = InCU.IBuff.buffer[1];
    InCU.IBuff.buffer[1] = InCU.IBuff.buffer[2];
    InCU.IBuff.buffer[2] = InCU.IBuff.buffer[3];
    InCU.IBuff.buffer[3] = InCU.IBuff.buffer[4];
    InCU.IBuff.buffer[4] = InCU.IBuff.buffer[5];
    InCU.IBuff.buffer[5] = InCU.IBuff.buffer[6];
    InCU.IBuff.buffer[6] = InCU.IBuff.buffer[7];
    InCU.IBuff.buffer[7] = INCU_EMPTY_IBUFF_ENTRY;
    
    InCU.IBuff.count--;
    return entry;
  }

  return entry;
}

bool InCU_IsTerminated() {
  return _mustTerminate;
}

void InCU_Flush() {
  int i;

  InCU.IBuff.count = 0;
  for (i = 0; i &lt; INCU_IBUFF_MAX; ++i)
    InCU.IBuff.buffer[i] = INCU_EMPTY_IBUFF_ENTRY;
  InCU.IR = INCU_EMPTY_IR;
}

void InCU_Update() {
  InCU_IBuff_Push();
  InCU_PC_Update();
}

/* Execution Units (EUs): */

void EUs_Init() {
  int i;

  for (i = 0; i &lt; EUS_PIPELINE_MAX; ++i)
    EUs.pipeline[i] = -1;
  
  EUs.predict_taken      = false;
  EUs.dynamic_prediction = false;
  EUs.taken              = false;
  
  EUs.cycles = 0;
}

bool EUs_IsExecuting(int index) {
  return (EUs.pipeline[EUS_PIPELINE_D] == index);
}

bool EUs_IsTerminated() {
  return (_mustTerminate
       &amp;&amp; InCU.IR.index                == -1
       &amp;&amp; EUs.pipeline[EUS_PIPELINE_D] == -1
       &amp;&amp; EUs.pipeline[EUS_PIPELINE_E] == -1
       &amp;&amp; EUs.pipeline[EUS_PIPELINE_M] == -1
       &amp;&amp; EUs.pipeline[EUS_PIPELINE_W] == -1);
}

bool EUs_D_DoStall() { return EUs.pipeline[EUS_PIPELINE_D] != -1; }
bool EUs_E_DoStall() { return EUs.cycles != 0 || EUs.pipeline[EUS_PIPELINE_E] != -1; }
bool EUs_M_DoStall() { return SRAM.executing || EUs.cycles != 0 || EUs.pipeline[EUS_PIPELINE_M] != -1; }
bool EUs_W_DoStall() { return SRAM.executing; }

void EUs_Update() {
  bool do_stall = false;
  
  // Execute W (if doesn't stall):
  EUs.pipeline[EUS_PIPELINE_W] = -1;
  if (!EUs_W_DoStall()) {
    EUs.pipeline[EUS_PIPELINE_W] = EUs.pipeline[EUS_PIPELINE_M];
    EUs.pipeline[EUS_PIPELINE_M] = -1;
  }

  // Execute M (if doesn't stall):
  if (!EUs_M_DoStall()) {
    EUs.pipeline[EUS_PIPELINE_M] = EUs.pipeline[EUS_PIPELINE_E];
    EUs.pipeline[EUS_PIPELINE_E] = -1;
  }

  // Execute E (if doesn't stall):
  if (EUs.cycles &gt; 0)
    EUs.cycles--;

  /* Don't move inst in D to E if there are
   * data dependencies between D and M:
   */
  if (EUs.pipeline[EUS_PIPELINE_D] != -1
   &amp;&amp; EUs.pipeline[EUS_PIPELINE_E] == -1
   &amp;&amp; EUs.pipeline[EUS_PIPELINE_M] != -1
   &amp;&amp; _INSTS[EUs.pipeline[EUS_PIPELINE_M]].do_memory) {
    int i;
    _Inst_t inD = _INSTS[EUs.pipeline[EUS_PIPELINE_D]];
    _Inst_t inM = _INSTS[EUs.pipeline[EUS_PIPELINE_M]];

    for (i = 0; i &lt; _REGS_MAX; ++i)
      if (inM.write_regs[i] &amp; inD.read_regs[i])
        do_stall = true;
  }

  if (!EUs_E_DoStall() &amp;&amp; !do_stall) {
    EUs.pipeline[EUS_PIPELINE_E] = EUs.pipeline[EUS_PIPELINE_D];
    EUs.pipeline[EUS_PIPELINE_D] = -1;

    if (EUs.pipeline[EUS_PIPELINE_E] != -1) {
      EUs.cycles = _INSTS[EUs.pipeline[EUS_PIPELINE_E]].cycles -1;
      
      // Instruction is a branch
      if (_INSTS[EUs.pipeline[EUS_PIPELINE_E]].do_branch) {
	    // Update the BTB
	    InCU_BTB_Update(EUs.pipeline[EUS_PIPELINE_E], EUs.taken);
 
	    // Check for incorrect predictions:
	    if (EUs.predict_taken &amp;&amp; !EUs.taken) {
	      InCU.PC = EUs.pipeline[EUS_PIPELINE_E] +1;
	      InCU_Flush();
	    }
        if (!EUs.predict_taken &amp;&amp; EUs.taken) {
	      InCU.PC = _INSTS[EUs.pipeline[EUS_PIPELINE_E]].target;
	      InCU_Flush();
	    }
      }
    }
  }

  // Execute D (if doesn't stall):
  if (!EUs_D_DoStall()) {
    EUs.pipeline[EUS_PIPELINE_D] = InCU.IR.index;
    EUs.predict_taken            = InCU.IR.predict_taken;
    EUs.dynamic_prediction       = InCU.IR.dynamic_prediction;
    EUs.taken                    = InCU.IR.taken;
    
    InCU.IR = InCU_IBuff_Pop();

    // inst. in D is a backward branch then statically predict taken
    if (!EUs.dynamic_prediction
    &amp;&amp;  EUs.pipeline[EUS_PIPELINE_D] != -1
    &amp;&amp;  _INSTS[EUs.pipeline[EUS_PIPELINE_D]].do_branch
    &amp;&amp;  _INSTS[EUs.pipeline[EUS_PIPELINE_D]].target &lt; EUs.pipeline[EUS_PIPELINE_D]) {
      EUs.predict_taken = true;
      InCU.PC = _INSTS[EUs.pipeline[EUS_PIPELINE_D]].target;
      InCU_Flush(); // TODO: check wether it should be done or not
    }
  }
}

//////////////////////////////////////////
////////////////// Generated semantics: //
//////////////////////////////////////////
</declaration>
	<template>
		<name>Binary</name>
	</template>
	<template>
		<name>sched</name>
		<location id="id0" x="0" y="102" color="#ffc0cb">
			<name x="17" y="93">end</name>
			<committed/>
		</location>
		<location id="id1" x="0" y="0">
		</location>
		<location id="id2" x="-34" y="102">
			<urgent/>
		</location>
		<init ref="id2"/>
		<transition>
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="17" y="34">_doTerminate?</label>
			<label kind="assignment" x="17" y="51">_clock = 0</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-59" y="-59">_do?</label>
			<nail x="0" y="-102"/>
			<nail x="34" y="-102"/>
			<nail x="34" y="0"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-144" y="25">_doInitialize!</label>
			<label kind="assignment" x="-144" y="42">_Init(),
_clock = 0</label>
			<nail x="-34" y="0"/>
		</transition>
	</template>
	<template>
		<name>Flash_Memory</name>
		<location id="id3" x="0" y="-102">
		</location>
		<location id="id4" x="-68" y="204">
		</location>
		<location id="id5" x="-102" y="204">
			<urgent/>
		</location>
		<location id="id6" x="-68" y="102">
		</location>
		<location id="id7" x="-34" y="0">
			<label kind="invariant" x="-280" y="-25">Flash_clock &lt;= FLASH_LATENCY</label>
		</location>
		<init ref="id5"/>
		<transition>
			<source ref="id3"/>
			<target ref="id7"/>
			<label kind="guard" x="17" y="-93">Flash.burst_index != FLASH_BURST_MAX -1</label>
			<label kind="synchronisation" x="17" y="-76">Flash_doneBurst[Flash.burst_index]!</label>
			<label kind="assignment" x="17" y="-59">IMU_FillBuffer_Update(),
Flash.burst_index++,
Flash_clock = 0</label>
			<nail x="0" y="0"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id4"/>
			<label kind="guard" x="-51" y="136">Flash_IsTerminated()</label>
			<label kind="synchronisation" x="-51" y="153">_do!</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-212" y="136">_doInitialize?</label>
			<label kind="assignment" x="-212" y="153">Flash_Init()</label>
			<nail x="-102" y="102"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="guard" x="-246" y="8">!Flash_IsTerminated()</label>
			<label kind="synchronisation" x="-246" y="25">Flash_doBurst?</label>
			<label kind="assignment" x="-246" y="42">IMU_FillBuffer_Set(),
Flash.burst_index = 0,
Flash_clock = 0</label>
			<nail x="-68" y="0"/>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id6"/>
			<label kind="guard" x="17" y="17">Flash.burst_index == FLASH_BURST_MAX -1</label>
			<label kind="synchronisation" x="17" y="34">Flash_doneBurst[Flash.burst_index]!</label>
			<label kind="assignment" x="17" y="51">IMU_FillBuffer_Update(),
IMU_ICache_Update()</label>
			<nail x="0" y="102"/>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id3"/>
			<label kind="guard" x="-289" y="-85">Flash_clock == FLASH_LATENCY</label>
			<label kind="synchronisation" x="-289" y="-68">EUs_doStep?</label>
			<nail x="-34" y="-102"/>
		</transition>
	</template>
	<template>
		<name>Static_RAM</name>
		<location id="id8" x="170" y="306">
		</location>
		<location id="id9" x="136" y="306">
			<urgent/>
		</location>
		<location id="id10" x="170" y="204">
		</location>
		<location id="id11" x="204" y="102">
			<label kind="invariant" x="221" y="110">SRAM_clock &lt;= SRAM_LATENCY</label>
		</location>
		<init ref="id9"/>
		<transition>
			<source ref="id10"/>
			<target ref="id8"/>
			<label kind="guard" x="187" y="238">SRAM_IsTerminated()</label>
			<label kind="synchronisation" x="187" y="255">_do!</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id10"/>
			<label kind="synchronisation" x="25" y="238">_doInitialize?</label>
			<label kind="assignment" x="25" y="255">SRAM_Init()</label>
			<nail x="136" y="289"/>
			<nail x="136" y="204"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id11"/>
			<label kind="guard" x="-34" y="110">!SRAM_IsTerminated() &amp;&amp;
SRAM_IsAccessed()</label>
			<label kind="synchronisation" x="-34" y="144">EUs_doStep?</label>
			<label kind="assignment" x="-34" y="161">SRAM_clock = 0,
SRAM.executing = true</label>
			<nail x="170" y="102"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id10"/>
			<label kind="guard" x="221" y="144">SRAM_clock == SRAM_LATENCY</label>
			<label kind="synchronisation" x="221" y="161">EUs_doStep?</label>
			<label kind="assignment" x="221" y="178">SRAM.executing = false</label>
			<nail x="204" y="204"/>
		</transition>
	</template>
	<template>
		<name>Instruction_Memory_Unit</name>
		<location id="id12" x="-612" y="-102">
		</location>
		<location id="id13" x="-850" y="204">
		</location>
		<location id="id14" x="-782" y="-102">
		</location>
		<location id="id15" x="-646" y="0">
			<label kind="invariant" x="-629" y="17">IMU_clock &lt;= 1</label>
		</location>
		<location id="id16" x="-816" y="0">
		</location>
		<location id="id17" x="-850" y="102">
		</location>
		<location id="id18" x="-884" y="204">
			<urgent/>
		</location>
		<init ref="id18"/>
		<transition>
			<source ref="id12"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="-595" y="-68">IMU_doneAccess!</label>
			<label kind="assignment" x="-595" y="-51">IMU_clock = 0</label>
			<nail x="-612" y="0"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id17"/>
			<label kind="guard" x="-629" y="51">IMU_clock == 1</label>
			<label kind="synchronisation" x="-629" y="68">EUs_doStep?</label>
			<nail x="-646" y="102"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-765" y="-144">Flash_doneBurst[0]?</label>
			<label kind="assignment" x="-765" y="-127">IMU_clock = 0</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id14"/>
			<label kind="guard" x="-969" y="-68">IMU_ICache_Miss()</label>
			<label kind="synchronisation" x="-969" y="-51">Flash_doBurst!</label>
			<nail x="-816" y="-102"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id15"/>
			<label kind="guard" x="-799" y="-42">IMU_ICache_Hit() ||
IMU_FillBuffer_Hit()</label>
			<label kind="synchronisation" x="-799" y="8">IMU_doneAccess!</label>
			<label kind="assignment" x="-799" y="25">IMU_clock = 0</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id16"/>
			<label kind="guard" x="-1020" y="25">!IMU_IsTerminated()</label>
			<label kind="synchronisation" x="-1020" y="42">IMU_doAccess?</label>
			<label kind="assignment" x="-1020" y="59">IMU_Set()</label>
			<nail x="-850" y="0"/>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id13"/>
			<label kind="guard" x="-833" y="136">IMU_IsTerminated()</label>
			<label kind="synchronisation" x="-833" y="153">_do!</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-994" y="136">_doInitialize?</label>
			<label kind="assignment" x="-994" y="153">IMU_Init()</label>
			<nail x="-884" y="102"/>
		</transition>
	</template>
	<template>
		<name>Instruction_and_Control_Unit</name>
		<location id="id19" x="306" y="68">
		</location>
		<location id="id20" x="272" y="68">
			<urgent/>
		</location>
		<location id="id21" x="340" y="-136">
		</location>
		<location id="id22" x="306" y="-34">
		</location>
		<init ref="id20"/>
		<transition>
			<source ref="id22"/>
			<target ref="id19"/>
			<label kind="guard" x="323" y="0">InCU_IsTerminated()</label>
			<label kind="synchronisation" x="323" y="17">_do!</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="161" y="0">_doInitialize?</label>
			<label kind="assignment" x="161" y="17">InCU_Init()</label>
			<nail x="272" y="-34"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="357" y="-102">IMU_doneAccess?</label>
			<label kind="assignment" x="357" y="-85">InCU_Update()</label>
			<nail x="340" y="-34"/>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id21"/>
			<label kind="guard" x="110" y="-110">!InCU_IsTerminated() &amp;&amp;
!InCU_IBuff_IsFull()</label>
			<label kind="synchronisation" x="110" y="-76">IMU_doAccess!</label>
			<nail x="306" y="-136"/>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Execution_Units</name>
		<location id="id23" x="238" y="102">
		</location>
		<location id="id24" x="204" y="102">
			<urgent/>
		</location>
		<location id="id25" x="238" y="0">
			<label kind="invariant" x="102" y="-25">EUs_clock  &lt;= 1</label>
		</location>
		<init ref="id24"/>
		<transition>
			<source ref="id24"/>
			<target ref="id25"/>
			<label kind="synchronisation" x="59" y="25">_doInitialize?</label>
			<label kind="assignment" x="59" y="42">EUs_Init(),
EUs_clock  = 0</label>
			<nail x="204" y="0"/>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id23"/>
			<label kind="guard" x="255" y="34">EUs_IsTerminated()</label>
			<label kind="synchronisation" x="255" y="51">_doTerminate!</label>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id25"/>
			<label kind="guard" x="289" y="-93">!EUs_IsTerminated() &amp;&amp;
EUs_clock == 1</label>
			<label kind="synchronisation" x="289" y="-59">EUs_doStep!</label>
			<label kind="assignment" x="289" y="-42">EUs_Update(),
EUs_clock  = 0</label>
			<nail x="238" y="-102"/>
			<nail x="272" y="-102"/>
			<nail x="272" y="0"/>
		</transition>
	</template>
	<system>system
    sched
  , Flash_Memory
  , Static_RAM
  , Instruction_Memory_Unit
  , Instruction_and_Control_Unit
  , Execution_Units
  , Binary
  ;
</system>
	<queries>
		<query>
			<formula>A&lt;&gt; sched.end
			</formula>
			<comment>...
			</comment>
		</query>
		<query>
			<formula>sup: _clock
			</formula>
			<comment>...
			</comment>
		</query>
	</queries>
</nta>
