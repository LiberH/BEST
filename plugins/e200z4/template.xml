<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>/* TODO:
 *  - microbench for memory access time
 *  - set proper values for _Inst_t.cycles
 *  - should remove '_do'?
 */

//////////////////////////////////////////
////////////////// Types and Constants: //
//////////////////////////////////////////

/* Binary: */

const int _UINT1_MAX  =           1;
const int _UINT2_MAX  =           3;
const int _UINT3_MAX  =           7;
const int _UINT5_MAX  =          32;
const int _UINT16_MAX =       65535;
const int _UINT32_MAX =  2147483647; // not 4294967295 because of UPPAAL internal limitation...
typedef int[0, _UINT1_MAX ] uint1_t;
typedef int[0, _UINT2_MAX ] uint2_t;
typedef int[0, _UINT3_MAX ] uint3_t;
typedef int[0, _UINT5_MAX ] uint5_t;
typedef int[0, _UINT16_MAX] uint16_t;
typedef int[0, _UINT32_MAX] uint32_t;

const int _SINT16_MIN =      -32767;
const int _SINT16_MAX =       32767;
const int _SINT32_MIN = -2147483648;
const int _SINT32_MAX =  2147483647;
typedef int[_SINT16_MIN, _SINT16_MAX] sint16_t;
typedef int[_SINT32_MIN, _SINT32_MAX] sint32_t;

const int _REGS_MAX = 8;
const int _INST_MAX = /* REPLACE_WITH_INST_MAX */ 1;

typedef struct {
  int  addr;
  int  cycles;
  bool do_branch;
  int  target;
  bool do_memory;
  int  read_regs[_REGS_MAX];
  int  write_regs[_REGS_MAX];
} _Inst_t;
const  int    _EMPTY_REGS[_REGS_MAX] = { 0, 0, 0, 0, 0, 0, 0, 0 };
const _Inst_t _EMPTY_INST            = { 0, 0, false, 0, false, _EMPTY_REGS, _EMPTY_REGS };

typedef struct {
  int index; // in bit field
  int value; // when set alone
} B_BitField_t;

/* Flash: */

const int FLASH_BURST_MAX =  4;
typedef struct {
  int[0, FLASH_BURST_MAX] burst_index;
} Flash_t;

const int FLASH_LATENCY = 10; // TODO: arbitrary; to set correctly

/* Static RAM (SRAM): */

const int SRAM_LATENCY = 10; // TODO: arbitrary; to set correctly

typedef struct {
  bool executing;
} SRAM_t;

/* Instruction Memory Unit (IMU): */

const int IMU_WAYS_MAX              =  2;
const int IMU_SETS_MAX              = 64;
const int IMU_FILLBUFFER_DWORDS_MAX =  4;

/*
const int IMU_FIRST_USED_SET = (_INSTS[           0].addr / 32) % IMU_SETS_MAX; // First 'in-use-at-run-time' set
const int IMU_LAST_USED_SET  = (_INSTS[_INST_MAX -1].addr / 32) % IMU_SETS_MAX; // Last  'in-use-at-run-time' set
const int IMU_USED_SETS_MAX  = IMU_LAST_USED_SET - IMU_FIRST_USED_SET +1;       // Number of 'used' sets
*/
const int IMU_USED_SETS_MAX = IMU_SETS_MAX;

typedef struct {
  int[-1, _INST_MAX -1] index;
  int[0, IMU_WAYS_MAX -1] rp_way;
  int tags[IMU_WAYS_MAX][IMU_USED_SETS_MAX];
} IMU_ICache_t;

typedef struct {
  int[-1, _INST_MAX -1] index;
  int[-1, IMU_FILLBUFFER_DWORDS_MAX -1] dword;
  int[-1, IMU_SETS_MAX -1] set;
  int tag; // TODO: set a range as [-1, ???]
  bool filled[IMU_FILLBUFFER_DWORDS_MAX];
} IMU_FillBuffer_t;
const IMU_FillBuffer_t IMU_EMPTY_FILLBUFFER_LINE = { -1, -1, -1, -1, { false, false, false, false } };

typedef struct {
  IMU_FillBuffer_t FillBuffer;
  IMU_ICache_t ICache;
} IMU_t;

const int IMU_CACHE_HIT       = 0;
const int IMU_FILLBUFFER_HIT  = 1;
const int IMU_FILLBUFFER_MISS = 2;
const int IMU_CACHE_MISS      = 3;

/* Instruction and Control Unit (InCU): */

const int INCU_STRONGLY_NOT_TAKEN = 0;
const int INCU_WEAKLY___NOT_TAKEN = 1;
const int INCU_WEAKLY_______TAKEN = 2;
const int INCU_STRONGLY_____TAKEN = 3;
typedef struct {
  int[-1, _INST_MAX -1] index;
  int[-1, INCU_STRONGLY_____TAKEN +1] prediction;
} InCU_BTB_Entry_t;

const int INCU_BTB_MAX = 8;
typedef struct {
  int[0, 8] top;
  InCU_BTB_Entry_t buffer[INCU_BTB_MAX];
} InCU_BTB_t;

typedef struct {
  int[-1, _INST_MAX -1] index;
  bool predict_taken;
  bool dynamic_prediction;
  bool taken;
} InCU_IBuff_Entry_t;
const InCU_IBuff_Entry_t INCU_EMPTY_IBUFF_ENTRY = { -1, false, false, false };

const int INCU_IBUFF_MAX = 8;
typedef struct {
  int[0, INCU_IBUFF_MAX] count;
  InCU_IBuff_Entry_t buffer[INCU_IBUFF_MAX];
} InCU_IBuff_t;

typedef struct {
  int[-1, _INST_MAX -1] index;
  bool predict_taken;
  bool dynamic_prediction;
  bool taken;
} InCU_IR_t;
const InCU_IR_t INCU_EMPTY_IR = { -1, false, false, false };

typedef struct {
  InCU_BTB_t BTB;
  int PC;
  InCU_IBuff_t IBuff;
  InCU_IR_t IR;
} InCU_t;

/* Execution Units (EUs): */

const int EUS_PIPELINE_D   = 0;
const int EUS_PIPELINE_E   = 1;
const int EUS_PIPELINE_M   = 2;
const int EUS_PIPELINE_W   = 3;
const int EUS_PIPELINE_MAX = 4;
const int EUS_CYCLES_MAX   = 5; // TODO: arbitrary; set properly
typedef struct {
  int pipeline[EUS_PIPELINE_MAX];
  bool predict_taken;
  bool dynamic_prediction;
  bool taken;
  int cycles;
} EUs_t;

//////////////////////////////////////////
///////////////////////// Declarations: //
//////////////////////////////////////////

/* (global:) */

clock _clock;

broadcast chan _doInitialize;
   urgent chan _doTerminate;
   urgent chan _do;

bool _mustTerminate;
bool _predict_taken;
bool _dynamic_prediction;
bool _taken;

/* Binary: */

const uint3_t cr0 =  0 , cr1 =  1 , cr2 =  2 , cr3 =  3 , cr4 =  4 , cr5 =  5 , cr6 =  6 , cr7 =  7;
const uint5_t r0  =  0 , r1  =  1 , r2  =  2 , r3  =  3 , r4  =  4 , r5  =  5 , r6  =  6 , r7  =  7;
const uint5_t r8  =  8 , r9  =  9 , r10 = 10 , r11 = 11 , r12 = 12 , r13 = 13 , r14 = 14 , r15 = 15;
const uint5_t r16 = 16 , r17 = 17 , r18 = 18 , r19 = 19 , r20 = 20 , r21 = 21 , r22 = 22 , r23 = 23;
const uint5_t r24 = 24 , r25 = 25 , r26 = 26 , r27 = 27 , r28 = 28 , r29 = 29 , r30 = 30 , r31 = 31;

uint3_t  _CR[8], _XER;
sint32_t _GPRS[32];
sint32_t ctr;

sint32_t /* REPLACE_WITH_REGS */ _REGS;

const _Inst_t _INSTS[_INST_MAX] = /* REPLACE_WITH_INSTS */ _EMPTY_INST;

/* Flash: */

Flash_t Flash;
clock Flash_clock;

urgent           chan Flash_doBurst;
urgent broadcast chan Flash_doneBurst[FLASH_BURST_MAX];

/* Static RAM (SRAM): */

SRAM_t SRAM;
clock SRAM_clock;

chan SRAM_doAccess;
chan SRAM_doneAccess;

/* Instruction Memory Unit (IMU): */

IMU_t IMU;
clock IMU_clock;

                 chan IMU_doneFill;
urgent           chan IMU_doAccess;
urgent broadcast chan IMU_doneAccess;

/* Instruction and Control Unit (InCU): */

InCU_t InCU;

/* Execution Units (EUs): */

EUs_t EUs;
clock EUs_clock;
broadcast chan EUs_doStep;

//////////////////////////////////////////
//////////////////////////// Functions: //
//////////////////////////////////////////

/* (global:) */

void _Init() {
  _mustTerminate      = false;
  _predict_taken      = false;
  _dynamic_prediction = false;
  _taken              = false;
}

/* Binary: */

const B_BitField_t XER_CA = {  1,  2 /* 0b0010 */ };
const B_BitField_t XER_OV = {  2,  4 /* 0b0100 */ };
const B_BitField_t XER_SO = {  3,  8 /* 0b1000 */ };

const B_BitField_t  CR_SO = {  0,  1 /* 0b0001 */ };
const B_BitField_t  CR_EQ = {  1,  2 /* 0b0010 */ };
const B_BitField_t  CR_GT = {  2,  4 /* 0b0100 */ };
const B_BitField_t  CR_LT = {  3,  8 /* 0b1000 */ };

sint32_t bitwiseNot ( sint32_t field ) { int i; for (i = 0; i &lt; 32; ++i) field ^= (1 &lt;&lt; i); return field; }

bool     getBit  ( sint32_t  field , uint5_t i                         ) { return (((field &gt;&gt; i) % 2) == 1); }
sint32_t getBits ( sint32_t  field , uint5_t i , uint5_t j             ) { return ((field &gt;&gt; (32 -i)) &amp; (2^(j +1) -1)); } // TODO: check
void     setBit  ( sint32_t &amp;field , uint5_t i ,             uint1_t b ) { field |= (b &lt;&lt; i); }
void     setBits ( sint32_t &amp;field , uint5_t i , uint5_t j , uint1_t b ) { while (i &lt;= j) setBit (field, i++, b); } // TODO: check

void setCR  ( uint3_t crfD , uint2_t i , uint1_t b ) { _CR[crfD] = ( b ? (_CR[crfD] | (1 &lt;&lt; i)) : (_CR[crfD] &amp; bitwiseNot(1 &lt;&lt; i)) ); }
void setXER (                uint2_t i , uint1_t b ) { _XER      = ( b ? (_XER      | (1 &lt;&lt; i)) : (_XER      &amp; bitwiseNot(1 &lt;&lt; i)) ); }

bool  z () { return ((ctr -1) == 0);    }
bool nz () { return !z();               }

bool eq ( uint3_t crfD ) { return getBit(crfD, CR_EQ.index); }
bool gt ( uint3_t crfD ) { return getBit(crfD, CR_GT.index); }
bool lt ( uint3_t crfD ) { return getBit(crfD, CR_LT.index); }
bool ne ( uint3_t crfD ) { return !eq(crfD);                 }
bool le ( uint3_t crfD ) { return !gt(crfD);                 }
bool ge ( uint3_t crfD ) { return !lt(crfD);                 }

////////////////////////////////////////////
// ARITHM //////////////////////////////////
const int ARITHM_ADD               = 1;
  const int ADD_CARRYING             = 1;
  const int ADD_EXTENDED             = 2;
  const int ADD_EXTENDED_MINUS_ONE   = 3;
  const int ADD_EXTENDED_ZERO        = 4;
  const int ADD_SHIFTED              = 5;
const int ARITHM_MUL               = 2;
  const int MUL_HIGH                 = 1;
  const int MUL_LOW                  = 2;
const int ARITHM_DIV               = 3;
  const int DIV_SIGNED               = 1;
  const int DIV_UNSIGNED             = 2;
// LOGICAL /////////////////////////////////
const int LOGICAL_AND              = 1;
  const int AND_COMPLEMENTED         = 1;
  const int AND_SHIFTED              = 2;
const int LOGICAL_CNTLZW           = 2;
const int LOGICAL_EQUIV            = 3;
const int LOGICAL_EXTEND           = 4;
  const int EXTEND_BYTE             = 1;
  const int EXTEND_HALFWORD         = 2;
const int LOGICAL_NAND             = 5;
const int LOGICAL_NEG              = 6;
const int LOGICAL_NOR              = 7;
const int LOGICAL_OR               = 8;
  const int OR_COMPLEMENTED          = 1;
  const int OR_SHIFTED               = 2;
const int LOGICAL_XOR              = 9;
  const int XOR_SHIFTED              = 1;
// COMPARE /////////////////////////////////
  // "OR-able" qualifers:
  const int COMPARE_LOGICAL          = 1;
  const int COMPARE_SIGN_EXTENDED    = 2;
  const int COMPARE_UNSIGNED         = 4;
// ROTATE //////////////////////////////////
  const int ROTATE_AND_MASK          = 1;
  const int ROTATE_MASK_INSERT       = 2;
// SHIFT ///////////////////////////////////
const int SHIFT_LEFT               = 1;
  const int LEFT_LOGICAL             = 1;
const int SHIFT_RIGHT              = 2;
  const int RIGHT_ALEGBRAIC          = 1;
  const int RIGHT_LOGICAL            = 3;
// MEMORY //////////////////////////////////
const int MEMORY_LOAD              = 1;
  // "OR-able" qualifers:
  const int LOAD_ALGEBRAIC           = 1;
  const int LOAD_REVERSED            = 2;
  const int LOAD_UPDATING            = 4;
  const int LOAD_INDEXED             = 8;
    const int LOAD_BYTE                = 1;
    const int LOAD_HALFWORD            = 2;
    const int LOAD_WORD                = 4;
const int MEMORY_STORE             = 2;
  const int STORE_REVERSED           = 1;
  const int STORE_UPDATING           = 2;
  const int STORE_INDEXED            = 4;
    const int STORE_BYTE               = 1; 
    const int STORE_HALFWORD           = 2;
    const int STORE_WORD               = 4;
// BRANCH //////////////////////////////////
  // "OR-able" qualifers:
  const int BRANCH_UNCONDITIONALLY     = 1;
  const int BRANCH_CONDITIONALLY       = 2;
  const int BRANCH_TOCTR               = 4;
  const int BRANCH_TOLR                = 8;
////////////////////////////////////////////
////////////////////////////////////////////

// Arithmetic instructions:

void _ARITHM( int operator, int qualifier, uint5_t rD, uint5_t rA, uint5_t rB_or_SIMM, uint1_t OE, uint1_t Rc ) {
  if ( operator == ARITHM_ADD )
  { if ( qualifier == 0                      ) { rD = rA +  rB_or_SIMM;                                     }
    if ( qualifier == ADD_CARRYING           ) { rD = rA +  rB_or_SIMM;  setXER (XER_OV.index, 0); }  // TODO: 0 -&gt; ?
    if ( qualifier == ADD_EXTENDED           ) { rD = rA +  rB_or_SIMM + getBit (_XER , XER_CA.index); }
    if ( qualifier == ADD_EXTENDED_MINUS_ONE ) { rD = rA -  1          + getBit (_XER , XER_CA.index); }
    if ( qualifier == ADD_EXTENDED_ZERO      ) { rD = rA               + getBit (_XER , XER_CA.index); }
    if ( qualifier == ADD_SHIFTED            ) { rD = rA + (rB_or_SIMM &lt;&lt; 16);                              }}

  if ( operator == ARITHM_MUL )
  { if ( qualifier == MUL_HIGH               ) { rD = rA * rB_or_SIMM; }  // TODO: perform a 64-bit multiplication; store the HIGH-order 32 bits in rD
    if ( qualifier == MUL_LOW                ) { rD = rA * rB_or_SIMM; }} // TODO: perform a 64-bit multiplication; store the LOW-order 32 bits in rD

  if ( operator == ARITHM_DIV )
  { if ( qualifier == DIV_SIGNED             ) { rD = rA / rB_or_SIMM; }  
    if ( qualifier == DIV_UNSIGNED           ) { rD = rA / rB_or_SIMM; }} // TODO: how to perform an unsigned division?

  if ( OE ) { setXER (      XER_OV.index , 0);   // TODO: 0 -&gt; ?
              setXER (      XER_SO.index , 0); } // TODO: 0 -&gt; ?
  if ( Rc ) { setCR  (cr0 , CR_SO.index  , 0);   // TODO: 0 -&gt; ?
              setCR  (cr0 , CR_EQ.index  , 0);   // TODO: 0 -&gt; ?
              setCR  (cr0 , CR_GT.index  , 0);   // TODO: 0 -&gt; ?
              setCR  (cr0 , CR_LT.index  , 0); } // TODO: 0 -&gt; ?
}

void _add      ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , 0                      , rD ,  rA , rB   , false , false ); }
void _add_     ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , 0                      , rD ,  rA , rB   , false , true  ); }
void _addo     ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , 0                      , rD ,  rA , rB   , true  , false ); }
void _addo_    ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , 0                      , rD ,  rA , rB   , true  , true  ); }
void _addc     ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_CARRYING           , rD ,  rA , rB   , false , false ); }
void _addc_    ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_CARRYING           , rD ,  rA , rB   , false , true  ); }
void _addco    ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_CARRYING           , rD ,  rA , rB   , true  , false ); }
void _addco_   ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_CARRYING           , rD ,  rA , rB   , true  , true  ); }
void _adde     ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED           , rD ,  rA , rB   , false , false ); }
void _adde_    ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED           , rD ,  rA , rB   , false , true  ); }
void _addeo    ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED           , rD ,  rA , rB   , true  , false ); }
void _addeo_   ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED           , rD ,  rA , rB   , true  , true  ); }
void _addi     ( uint5_t rD , uint5_t rA  , sint16_t SIMM ) { _ARITHM( ARITHM_ADD , 0                      , rD ,  rA , SIMM , false , false ); }
void _addic    ( uint5_t rD , uint5_t rA  , sint16_t SIMM ) { _ARITHM( ARITHM_ADD , ADD_CARRYING           , rD ,  rA , SIMM , false , false ); }
void _addic_   ( uint5_t rD , uint5_t rA  , sint16_t SIMM ) { _ARITHM( ARITHM_ADD , ADD_CARRYING           , rD ,  rA , SIMM , false , true  ); }
void _addis    ( uint5_t rD , uint5_t rA  , sint16_t SIMM ) { _ARITHM( ARITHM_ADD , ADD_SHIFTED            , rD ,  rA , SIMM , false , false ); }
void _addme    ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_MINUS_ONE , rD ,  rA , 0    , false , false ); }
void _addme_   ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_MINUS_ONE , rD ,  rA , 0    , false , true  ); }
void _addmeo   ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_MINUS_ONE , rD ,  rA , 0    , true  , false ); }
void _addmeo_  ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_MINUS_ONE , rD ,  rA , 0    , true  , true  ); }
void _addze    ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_ZERO      , rD ,  rA , 0    , false , false ); }
void _addze_   ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_ZERO      , rD ,  rA , 0    , false , true  ); }
void _addzeo   ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_ZERO      , rD ,  rA , 0    , true  , false ); }
void _addzeo_  ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_ZERO      , rD ,  rA , 0    , true  , true  ); }

void _divw     ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_DIV , DIV_SIGNED             , rD ,  rA , rB   , false , false ); }
void _divw_    ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_DIV , DIV_SIGNED             , rD ,  rA , rB   , false , true  ); }
void _divwo    ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_DIV , DIV_SIGNED             , rD ,  rA , rB   , true  , false ); }
void _divwo_   ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_DIV , DIV_SIGNED             , rD ,  rA , rB   , true  , true  ); }
void _divwu    ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_DIV , DIV_UNSIGNED           , rD ,  rA , rB   , false , false ); }
void _divwu_   ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_DIV , DIV_UNSIGNED           , rD ,  rA , rB   , false , true  ); }
void _divwuo   ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_DIV , DIV_UNSIGNED           , rD ,  rA , rB   , true  , false ); }
void _divwuo_  ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_DIV , DIV_UNSIGNED           , rD ,  rA , rB   , true  , true  ); }

void _mulhw    ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_MUL , MUL_HIGH               , rD ,  rA , rB   , false , false ); }
void _mulhw_   ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_MUL , MUL_HIGH               , rD ,  rA , rB   , false , true  ); }
void _mulhwu   ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_MUL , MUL_HIGH               , rD ,  rA , rB   , false , false ); }
void _mulhwu_  ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_MUL , MUL_HIGH               , rD ,  rA , rB   , false , true  ); }
void _mullw    ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_MUL , MUL_LOW                , rD ,  rA , rB   , false , false ); }
void _mullw_   ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_MUL , MUL_LOW                , rD ,  rA , rB   , false , true  ); }
void _mullwo   ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_MUL , MUL_LOW                , rD ,  rA , rB   , true  , false ); }
void _mullwo_  ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_MUL , MUL_LOW                , rD ,  rA , rB   , true  , true  ); }
void _mulli    ( uint5_t rD , uint5_t rA  , sint16_t SIMM ) { _ARITHM( ARITHM_MUL , MUL_LOW                , rD ,  rA , SIMM , false , false ); }

void _subf     ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , 0                      , rD , -rA , rB   , false , false ); }
void _subf_    ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , 0                      , rD , -rA , rB   , false , true  ); }
void _subfo    ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , 0                      , rD , -rA , rB   , true  , false ); }
void _subfo_   ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , 0                      , rD , -rA , rB   , true  , true  ); }
void _subfc    ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_CARRYING           , rD , -rA , rB   , false , false ); }
void _subfc_   ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_CARRYING           , rD , -rA , rB   , false , true  ); }
void _subfco   ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_CARRYING           , rD , -rA , rB   , true  , false ); }
void _subfco_  ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_CARRYING           , rD , -rA , rB   , true  , true  ); }
void _subfe    ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED           , rD , -rA , rB   , false , false ); }
void _subfe_   ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED           , rD , -rA , rB   , false , true  ); }
void _subfeo   ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED           , rD , -rA , rB   , true  , false ); }
void _subfeo_  ( uint5_t rD , uint5_t rA  , uint5_t  rB   ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED           , rD , -rA , rB   , true  , true  ); }
void _subfic   ( uint5_t rD , uint5_t rA  , sint16_t SIMM ) { _ARITHM( ARITHM_ADD , ADD_CARRYING           , rD , -rA , SIMM , false , false ); }
void _subfme   ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_MINUS_ONE , rD , -rA , 0    , false , false ); }
void _subfme_  ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_MINUS_ONE , rD , -rA , 0    , false , true  ); }
void _subfmeo  ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_MINUS_ONE , rD , -rA , 0    , true  , false ); }
void _subfmeo_ ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_MINUS_ONE , rD , -rA , 0    , true  , true  ); }
void _subfze   ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_ZERO      , rD , -rA , 0    , false , false ); }
void _subfze_  ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_ZERO      , rD , -rA , 0    , false , true  ); }
void _subfzeo  ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_ZERO      , rD , -rA , 0    , true  , false ); }
void _subfzeo_ ( uint5_t rD , uint5_t rA                  ) { _ARITHM( ARITHM_ADD , ADD_EXTENDED_ZERO      , rD , -rA , 0    , true  , true  ); }

void _li       ( uint5_t rD ,               sint16_t SIMM ) { _addi    ( rD,  0,  SIMM ); }
void _lis      ( uint5_t rD ,               sint16_t SIMM ) { _addis   ( rD,  0,  SIMM ); }
void _la       ( uint5_t rD , sint16_t d  , uint5_t  rA   ) { _addi    ( rD, rA,  d    ); }
void _sub      ( uint5_t rD , uint5_t  rA , uint5_t  rB   ) { _subf    ( rD, rB,  rA   ); }
void _sub_     ( uint5_t rD , uint5_t  rA , uint5_t  rB   ) { _subf_   ( rD, rB,  rA   ); }
void _subo     ( uint5_t rD , uint5_t  rA , uint5_t  rB   ) { _subfo   ( rD, rB,  rA   ); }
void _subo_    ( uint5_t rD , uint5_t  rA , uint5_t  rB   ) { _subfo_  ( rD, rB,  rA   ); }
void _subc     ( uint5_t rD , uint5_t  rA , uint5_t  rB   ) { _subfc   ( rD, rB,  rA   ); }
void _subc_    ( uint5_t rD , uint5_t  rA , uint5_t  rB   ) { _subfc_  ( rD, rB,  rA   ); }
void _subco    ( uint5_t rD , uint5_t  rA , uint5_t  rB   ) { _subfco  ( rD, rB,  rA   ); }
void _subco_   ( uint5_t rD , uint5_t  rA , uint5_t  rB   ) { _subfco_ ( rD, rB,  rA   ); }
void _subi     ( uint5_t rD , uint5_t  rA , sint16_t SIMM ) { _addi    ( rD, rA, -SIMM ); }
void _subis    ( uint5_t rD , uint5_t  rA , sint16_t SIMM ) { _addis   ( rD, rA, -SIMM ); }
void _subic    ( uint5_t rD , uint5_t  rA , sint16_t SIMM ) { _addic   ( rD, rA, -SIMM ); }
void _subic_   ( uint5_t rD , uint5_t  rA , sint16_t SIMM ) { _addic_  ( rD, rA, -SIMM ); }

// Compare instructions:

sint32_t EXTS ( sint32_t x ) { return 0; } // TODO: how to perform a sign extension?

void _COMPARE( int qualifier, uint3_t crfD, uint1_t L, uint5_t rA, uint5_t rB_or_IMM ) {
  int a = rA;
  int b = rB_or_IMM;
  int c;

  if ( qualifier == 0                                      ) { if ( L ) { a = EXTS(a); b = EXTS(b); } }
  if ( qualifier == ( COMPARE_SIGN_EXTENDED              ) ) {                         b = EXTS(b);   }
  if ( qualifier == ( COMPARE_LOGICAL                    ) ) {                                        } // TODO: how to perform an unsigned evaluation?
  if ( qualifier == ( COMPARE_LOGICAL | COMPARE_UNSIGNED ) ) {                                        } // TODO: how to perform an unsigned evaluation?

       if ( a &lt; b ) { c = CR_LT.value; }
  else if ( a &gt; b ) { c = CR_GT.value; }
  else              { c = CR_EQ.value; }

  crfD = c | getBit(_XER, XER_SO.index); // TODO: crfD -&gt; CR[4 ∗ crfD–4 ∗ crfD + 3]
}

void _cmp    ( uint3_t crfD , uint5_t rA , uint5_t  rB   ) { _COMPARE( 0                                  , crfD , false , rA , rB   ); }
void _cmpi   ( uint3_t crfD , uint5_t rA , sint16_t SIMM ) { _COMPARE( COMPARE_SIGN_EXTENDED              , crfD , false , rA , SIMM ); }
void _cmpl   ( uint3_t crfD , uint5_t rA , uint5_t  rB   ) { _COMPARE( COMPARE_LOGICAL                    , crfD , false , rA , rB   ); }
void _cmpli  ( uint3_t crfD , uint5_t rA , uint16_t UIMM ) { _COMPARE( COMPARE_LOGICAL | COMPARE_UNSIGNED , crfD , false , rA , UIMM ); }

void _cmpw   ( uint3_t crfD , uint5_t rA , uint5_t  rB   ) { _cmp   ( crfD, rA, rB   ); }
void _cmpwi  ( uint3_t crfD , uint5_t rA , sint16_t SIMM ) { _cmpi  ( crfD, rA, SIMM ); }
void _cmplw  ( uint3_t crfD , uint5_t rA , uint5_t  rB   ) { _cmpl  ( crfD, rA, rB   ); }
void _cmplwi ( uint3_t crfD , uint5_t rA , uint16_t UIMM ) { _cmpli ( crfD, rA, UIMM ); }

// Logical instructions:

void _LOGICAL( int operator, int qualifier, uint5_t rA_or_rD, uint5_t rS_or_rA, uint5_t rB_or_UIMM, uint1_t OE, uint1_t Rc ) {
  uint5_t n;

  if ( operator  == LOGICAL_AND        )
  { if ( qualifier == 0                ) { rA_or_rD =  rS_or_rA &amp;  rB_or_UIMM;        }
    if ( qualifier == AND_COMPLEMENTED ) { rA_or_rD =  rS_or_rA &amp; -rB_or_UIMM;        }  // TODO: check if -rB == complement(rB)
    if ( qualifier == AND_SHIFTED      ) { rA_or_rD =  rS_or_rA &amp; (rB_or_UIMM &lt;&lt; 16); }}

  if ( operator  == LOGICAL_CNTLZW     ) { for (n = 31; n &gt;= 0 &amp;&amp; !getBit(rS_or_rA, n); --n);
                                           rA_or_rD = 32 - (n +1);               }
  if ( operator  == LOGICAL_EQUIV      ) { rA_or_rD = -(rS_or_rA ^  rB_or_UIMM); } // TODO: check if -X == complement(X)
  if ( operator  == LOGICAL_EXTEND     )
  { if ( qualifier == EXTEND_BYTE      ) { rA_or_rD = rS_or_rA &amp;   127; setBits (rA_or_rD,  7, 31, getBit (rS_or_rA,  7)); }
    if ( qualifier == EXTEND_HALFWORD  ) { rA_or_rD = rS_or_rA &amp; 32767; setBits (rA_or_rD, 15, 31, getBit (rS_or_rA, 15)); }}

  if ( operator  == LOGICAL_NAND       ) { rA_or_rD = -rS_or_rA | -rB_or_UIMM;  } // TODO: check if -rS | -rB == rS NAND rB
  if ( operator  == LOGICAL_NEG        ) { rA_or_rD = -rS_or_rA;                } // TODO: check if -rA == bitwiseNot(rA)
  if ( operator  == LOGICAL_NOR        ) { rA_or_rD = -rS_or_rA &amp; -rB_or_UIMM;  } // TODO: check if -rS &amp; -rB == rS NOR rB
  if ( operator  == LOGICAL_OR         )
  { if ( qualifier == 0                ) { rA_or_rD = rS_or_rA |  rB_or_UIMM;        }
    if ( qualifier == OR_COMPLEMENTED  ) { rA_or_rD = rS_or_rA | -rB_or_UIMM;        }  // TODO: check if -X == complement(X)
    if ( qualifier == OR_SHIFTED       ) { rA_or_rD = rS_or_rA | (rB_or_UIMM &lt;&lt; 16); }}

  if ( operator  == LOGICAL_XOR        )
  { if ( qualifier == 0                ) { rA_or_rD = rS_or_rA ^  rB_or_UIMM;        }
    if ( qualifier == XOR_SHIFTED      ) { rA_or_rD = rS_or_rA ^ (rB_or_UIMM &lt;&lt; 16); }} 

  if ( OE ) { setXER (      XER_OV.index , 0);   // TODO: 0 -&gt; ?
              setXER (      XER_SO.index , 0); } // TODO: 0 -&gt; ?
  if ( Rc ) { setCR  (cr0 , CR_SO.index  , 0);   // TODO: 0 -&gt; ?
              setCR  (cr0 , CR_EQ.index  , 0);   // TODO: 0 -&gt; ?
              setCR  (cr0 , CR_GT.index  , 0);   // TODO: 0 -&gt; ?
              setCR  (cr0 , CR_LT.index  , 0); } // TODO: 0 -&gt; ?
}

void _and     ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_AND  , 0                 , rA , rS , rB   , false , false ); }
void _and_    ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_AND  , 0                 , rA , rS , rB   , false , true  ); }
void _andc    ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_AND  , AND_COMPLEMENTED  , rA , rS , rB   , false , false ); }
void _andc_   ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_AND  , AND_COMPLEMENTED  , rA , rS , rB   , false , true  ); }
void _andi_   ( uint5_t rA , uint5_t rS , uint16_t UIMM ) { _LOGICAL( LOGICAL_AND  , 0                 , rA , rS , UIMM , false , true  ); }
void _andis_  ( uint5_t rA , uint5_t rS , uint16_t UIMM ) { _LOGICAL( LOGICAL_AND  , AND_SHIFTED       , rA , rS , UIMM , false , true  ); }

void _cntlzw  ( uint5_t rA , uint5_t rS                 ) { _LOGICAL( LOGICAL_CNTLZW , 0               , rA , rS , 0    , false , false ); }
void _cntlzw_ ( uint5_t rA , uint5_t rS                 ) { _LOGICAL( LOGICAL_CNTLZW , 0               , rA , rS , 0    , false , true  ); }
void _eqv     ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_EQUIV  , 0               , rA , rS , rB   , false , false ); }
void _eqv_    ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_EQUIV  , 0               , rA , rS , rB   , false , true  ); }
void _extsb   ( uint5_t rA , uint5_t rS                 ) { _LOGICAL( LOGICAL_EXTEND , EXTEND_BYTE     , rA , rS , 0    , false , false ); }
void _extsb_  ( uint5_t rA , uint5_t rS                 ) { _LOGICAL( LOGICAL_EXTEND , EXTEND_BYTE     , rA , rS , 0    , false , true  ); }
void _extsh   ( uint5_t rA , uint5_t rS                 ) { _LOGICAL( LOGICAL_EXTEND , EXTEND_HALFWORD , rA , rS , 0    , false , false ); }
void _extsh_  ( uint5_t rA , uint5_t rS                 ) { _LOGICAL( LOGICAL_EXTEND , EXTEND_HALFWORD , rA , rS , 0    , false , true  ); }

void _nand    ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_NAND , 0                 , rA , rS , rB   , false , false ); }
void _nand_   ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_NAND , 0                 , rA , rS , rB   , false , true  ); }

void _neg     ( uint5_t rD , uint5_t rA                 ) { _LOGICAL( LOGICAL_NEG  , 0                 , rD , rA , 0    , false , false ); }
void _neg_    ( uint5_t rD , uint5_t rA                 ) { _LOGICAL( LOGICAL_NEG  , 0                 , rD , rA , 0    , false , true  ); }
void _nego    ( uint5_t rD , uint5_t rA                 ) { _LOGICAL( LOGICAL_NEG  , 0                 , rD , rA , 0    , true  , false ); }
void _nego_   ( uint5_t rD , uint5_t rA                 ) { _LOGICAL( LOGICAL_NEG  , 0                 , rD , rA , 0    , true  , true  ); }

void _nor     ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_NOR  , 0                 , rA , rS , rB   , false , false ); }
void _nor_    ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_NOR  , 0                 , rA , rS , rB   , false , true  ); }

void _or      ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_OR   , 0                 , rA , rS , rB   , false , false ); }
void _or_     ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_OR   , 0                 , rA , rS , rB   , false , true  ); }
void _orc     ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_OR   , OR_COMPLEMENTED   , rA , rS , rB   , false , false ); }
void _orc_    ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_OR   , OR_COMPLEMENTED   , rA , rS , rB   , false , true  ); }
void _ori     ( uint5_t rA , uint5_t rS , uint16_t UIMM ) { _LOGICAL( LOGICAL_OR   , 0                 , rA , rS , UIMM , false , false ); }
void _oris    ( uint5_t rA , uint5_t rS , uint16_t UIMM ) { _LOGICAL( LOGICAL_OR   , OR_SHIFTED        , rA , rS , UIMM , false , false ); }

void _xor     ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_XOR  , 0                 , rA , rS , rB   , false , false ); }
void _xor_    ( uint5_t rA , uint5_t rS , uint5_t  rB   ) { _LOGICAL( LOGICAL_XOR  , 0                 , rA , rS , rB   , false , true  ); }
void _xori    ( uint5_t rA , uint5_t rS , uint16_t UIMM ) { _LOGICAL( LOGICAL_XOR  , 0                 , rA , rS , UIMM , false , false ); }
void _xoris   ( uint5_t rA , uint5_t rS , uint16_t UIMM ) { _LOGICAL( LOGICAL_XOR  , XOR_SHIFTED       , rA , rS , UIMM , false , false ); }

void _not     ( uint5_t rA , uint5_t rS                 ) { _nor  ( rA, rS, rS ); }
void _not_    ( uint5_t rA , uint5_t rS                 ) { _nor_ ( rA, rS, rS ); }
void _mr      ( uint5_t rA , uint5_t rS                 ) { _or   ( rA, rS, rS ); }
void _mr_     ( uint5_t rA , uint5_t rS                 ) { _or_  ( rA, rS, rS ); }
void _nop     (                                         ) { /*   "ori 0,0,0"   */ }

// Rotate instructions:

sint32_t ROTL ( sint32_t x , sint32_t y ) { return 0; } // TODO: implement according to the semantics given in the specs
sint32_t MASK ( uint5_t  x , uint5_t  y ) { return 0; } // TODO: implement according to the semantics given in the specs

void _ROTATE( int qualifier, uint5_t rA, uint5_t rS, uint5_t SH_or_rB, uint5_t MB, uint5_t ME, uint1_t Rc ) {
  uint5_t  n = getBits (SH_or_rB, 0, 4);
  sint32_t r = ROTL (rS, n);
  sint32_t m = MASK (MB, ME);

  if ( qualifier == ROTATE_AND_MASK    ) { rA =  r &amp; m;               }
  if ( qualifier == ROTATE_MASK_INSERT ) { rA = (r &amp; m) | ( rA &amp; -m); } // TODO: check if -m == bitwiseNot(m)

  if ( Rc ) { setCR  (cr0 , CR_SO.index  , 0);   // TODO: 0 -&gt; ?
              setCR  (cr0 , CR_EQ.index  , 0);   // TODO: 0 -&gt; ?
              setCR  (cr0 , CR_GT.index  , 0);   // TODO: 0 -&gt; ?
              setCR  (cr0 , CR_LT.index  , 0); } // TODO: 0 -&gt; ?
}

void _rlwimi    ( uint5_t rA , uint5_t rS , uint5_t SH , uint5_t MB , uint5_t ME ) { _ROTATE( ROTATE_MASK_INSERT , rA , rS , SH , MB , ME , false ); }
void _rlwimi_   ( uint5_t rA , uint5_t rS , uint5_t SH , uint5_t MB , uint5_t ME ) { _ROTATE( ROTATE_MASK_INSERT , rA , rS , SH , MB , ME , true  ); }
void _rlwinm    ( uint5_t rA , uint5_t rS , uint5_t SH , uint5_t MB , uint5_t ME ) { _ROTATE( ROTATE_AND_MASK    , rA , rS , SH , MB , ME , false ); }
void _rlwinm_   ( uint5_t rA , uint5_t rS , uint5_t SH , uint5_t MB , uint5_t ME ) { _ROTATE( ROTATE_AND_MASK    , rA , rS , SH , MB , ME , true  ); }
void _rlwnm     ( uint5_t rA , uint5_t rS , uint5_t rB , uint5_t MB , uint5_t ME ) { _ROTATE( ROTATE_AND_MASK    , rA , rS , rB , MB , ME , false ); }
void _rlwnm_    ( uint5_t rA , uint5_t rS , uint5_t rB , uint5_t MB , uint5_t ME ) { _ROTATE( ROTATE_AND_MASK    , rA , rS , rB , MB , ME , true  ); }

void _inslwi    ( uint5_t rA , uint5_t rS , uint5_t n  , uint5_t b ) { _rlwimi  ( rA , rS , 32 - (b + 0) ,  b + 0 , (b +  n) - 1 ); } // (n &gt; 0)
void _inslwi_   ( uint5_t rA , uint5_t rS , uint5_t n  , uint5_t b ) { _rlwimi_ ( rA , rS , 32 - (b + 0) ,  b + 0 , (b +  n) - 1 ); } // (n &gt; 0)
void _insrwi    ( uint5_t rA , uint5_t rS , uint5_t n  , uint5_t b ) { _rlwimi  ( rA , rS , 32 - (b + n) ,  b + 0 , (b +  n) - 1 ); } // (n &gt; 0)
void _insrwi_   ( uint5_t rA , uint5_t rS , uint5_t n  , uint5_t b ) { _rlwimi_ ( rA , rS , 32 - (b + n) ,  b + 0 , (b +  n) - 1 ); } // (n &gt; 0)
void _extlwi    ( uint5_t rA , uint5_t rS , uint5_t n  , uint5_t b ) { _rlwinm  ( rA , rS ,  0 + (b + 0) ,  0 + 0 , (0 +  n) - 1 ); } // (n &gt; 0)
void _extlwi_   ( uint5_t rA , uint5_t rS , uint5_t n  , uint5_t b ) { _rlwinm_ ( rA , rS ,  0 + (b + 0) ,  0 + 0 , (0 +  n) - 1 ); } // (n &gt; 0)
void _extrwi    ( uint5_t rA , uint5_t rS , uint5_t n  , uint5_t b ) { _rlwinm  ( rA , rS ,  0 + (b + n) , 32 - n , (0 + 31) - 0 ); } // (n &gt; 0)
void _extrwi_   ( uint5_t rA , uint5_t rS , uint5_t n  , uint5_t b ) { _rlwinm_ ( rA , rS ,  0 + (b + n) , 32 - n , (0 + 31) - 0 ); } // (n &gt; 0)
void _rotlwi    ( uint5_t rA , uint5_t rS , uint5_t n              ) { _rlwinm  ( rA , rS ,  0 + (0 + n) ,  0 + 0 , (0 + 31) - 0 ); }
void _rotlwi_   ( uint5_t rA , uint5_t rS , uint5_t n              ) { _rlwinm_ ( rA , rS ,  0 + (0 + n) ,  0 + 0 , (0 + 31) - 0 ); }
void _rotrwi    ( uint5_t rA , uint5_t rS , uint5_t n              ) { _rlwinm  ( rA , rS , 32 - (0 + n) ,  0 + 0 , (0 + 31) - 0 ); }
void _rotrwi_   ( uint5_t rA , uint5_t rS , uint5_t n              ) { _rlwinm_ ( rA , rS , 32 - (0 + n) ,  0 + 0 , (0 + 31) - 0 ); }
void _slwi      ( uint5_t rA , uint5_t rS , uint5_t n              ) { _rlwinm  ( rA , rS ,  0 + (0 + n) ,  0 + 0 , (0 + 31) - n ); } // (n &lt; 32)
void _slwi_     ( uint5_t rA , uint5_t rS , uint5_t n              ) { _rlwinm_ ( rA , rS ,  0 + (0 + n) ,  0 + 0 , (0 + 31) - n ); } // (n &lt; 32)
void _srwi      ( uint5_t rA , uint5_t rS , uint5_t n              ) { _rlwinm  ( rA , rS , 32 - (0 + n) ,  0 + n , (0 + 31) - 0 ); } // (n &lt; 32)
void _srwi_     ( uint5_t rA , uint5_t rS , uint5_t n              ) { _rlwinm_ ( rA , rS , 32 - (0 + n) ,  0 + n , (0 + 31) - 0 ); } // (n &lt; 32)
void _clrlwi    ( uint5_t rA , uint5_t rS , uint5_t n              ) { _rlwinm  ( rA , rS ,  0 + (0 + 0) ,  0 + n , (0 + 31) - 0 ); } // (n &lt; 32)
void _clrlwi_   ( uint5_t rA , uint5_t rS , uint5_t n              ) { _rlwinm_ ( rA , rS ,  0 + (0 + 0) ,  0 + n , (0 + 31) - 0 ); } // (n &lt; 32)
void _clrrwi    ( uint5_t rA , uint5_t rS , uint5_t n              ) { _rlwinm  ( rA , rS ,  0 + (0 + 0) ,  0 + 0 , (0 + 31) - n ); } // (n &lt; 32)
void _clrrwi_   ( uint5_t rA , uint5_t rS , uint5_t n              ) { _rlwinm_ ( rA , rS ,  0 + (0 + 0) ,  0 + 0 , (0 + 31) - n ); } // (n &lt; 32)
void _clrlslwi  ( uint5_t rA , uint5_t rS , uint5_t b  , uint5_t n ) { _rlwinm  ( rA , rS ,  0 + (0 + n) ,  b - n , (0 + 31) - n ); } // (n &lt;= b &lt;= 31)
void _clrlslwi_ ( uint5_t rA , uint5_t rS , uint5_t b  , uint5_t n ) { _rlwinm_ ( rA , rS ,  0 + (0 + n) ,  b - n , (0 + 31) - n ); } // (n &lt;= b &lt;= 31)
void _rotlw     ( uint5_t rA , uint5_t rS , uint5_t rB             ) { _rlwnm   ( rA , rS , rB           ,  0 + 0 , (0 + 31) - 0 ); }
void _rotlw_    ( uint5_t rA , uint5_t rS , uint5_t rB             ) { _rlwnm_  ( rA , rS , rB           ,  0 + 0 , (0 + 31) - 0 ); }

// Shift instructions:

void _SHIFT( int operator, int qualifier, uint5_t rA, uint5_t rS, uint5_t rB_or_SH, uint1_t Rc ) {
  uint1_t  S; 
  uint5_t  n, r;
  sint32_t m, tmp;

  m = 0;
  n = getBits (rB_or_SH, 0, 4);
  if ( operator == SHIFT_LEFT  ) { r = ROTL(rS,      n); if (getBit (rB_or_SH, 5) == 0) m = MASK (0, 31 - n); }
  if ( operator == SHIFT_RIGHT ) { r = ROTL(rS, 32 - n); if (getBit (rB_or_SH, 5) == 0) m = MASK (n, 31    ); }

  S  = getBit (rS, 31); // TODO: check if S should be the sign bit (not clear in the specs.)
  rA = r &amp; m;
  if ( qualifier == RIGHT_ALEGBRAIC )
  { setBits (tmp , 0, 31, S);
    rA |= tmp &amp; -m;
    setBit (_XER , XER_CA.index , (S &amp; ((r &amp; -m) == 0))); } // TODO: check if -m == bitwiseNot(m)

  if ( Rc ) { setCR (cr0, CR_SO.index, 0);   // TODO: 0 -&gt; ?
              setCR (cr0, CR_EQ.index, 0);   // TODO: 0 -&gt; ?
              setCR (cr0, CR_GT.index, 0);   // TODO: 0 -&gt; ?
              setCR (cr0, CR_LT.index, 0); } // TODO: 0 -&gt; ?
}

void _slw    ( uint5_t rA , uint5_t rS , uint5_t rB ) { _SHIFT( SHIFT_LEFT  , LEFT_LOGICAL    , rA , rS , rB, false ); }
void _slw_   ( uint5_t rA , uint5_t rS , uint5_t rB ) { _SHIFT( SHIFT_LEFT  , LEFT_LOGICAL    , rA , rS , rB, true  ); }
void _sraw   ( uint5_t rA , uint5_t rS , uint5_t rB ) { _SHIFT( SHIFT_RIGHT , RIGHT_ALEGBRAIC , rA , rS , rB, false ); }
void _sraw_  ( uint5_t rA , uint5_t rS , uint5_t rB ) { _SHIFT( SHIFT_RIGHT , RIGHT_ALEGBRAIC , rA , rS , rB, true  ); }
void _srawi  ( uint5_t rA , uint5_t rS , uint5_t SH ) { _SHIFT( SHIFT_RIGHT , RIGHT_ALEGBRAIC , rA , rS , SH, false ); } // TODO: check impl.
void _srawi_ ( uint5_t rA , uint5_t rS , uint5_t SH ) { _SHIFT( SHIFT_RIGHT , RIGHT_ALEGBRAIC , rA , rS , SH, true  ); } // TODO: check impl.
void _srw    ( uint5_t rA , uint5_t rS , uint5_t rB ) { _SHIFT( SHIFT_RIGHT , RIGHT_LOGICAL   , rA , rS , rB, false ); }
void _srw_   ( uint5_t rA , uint5_t rS , uint5_t rB ) { _SHIFT( SHIFT_RIGHT , RIGHT_LOGICAL   , rA , rS , rB, true  ); }

// Memory instructions:

sint32_t MEM ( sint32_t x, uint5_t y ) { return 0; } // TODO: what to do with memory accesses?

void _MEMORY( int operator, int qualifier, int size,  uint5_t rD_or_RS , uint5_t d_or_rA  , uint5_t rA_or_rB ) {
  sint16_t d;
  sint32_t rD, rS, rA, rB;
  sint32_t EA;

  if ( operator == MEMORY_LOAD )
  { if ( !( qualifier &amp; LOAD_INDEXED ) ) { rD = rD_or_RS; d  = d_or_rA; rA = rA_or_rB; }
    if (  ( qualifier &amp; LOAD_INDEXED ) ) { rD = rD_or_RS; rA = d_or_rA; rB = rA_or_rB; }

    if ( qualifier == ( 0                                             ) ) { EA = rA + EXTS(d); rD =      MEM(EA, size);           } // TODO: if rA == 0 then b = 0 else b = (rA)
    if ( qualifier == (                  LOAD_UPDATING                ) ) { EA = rA + EXTS(d); rD =      MEM(EA, size);  rA = EA; }
    if ( qualifier == (                  LOAD_UPDATING | LOAD_INDEXED ) ) { EA = rA + rB;      rD =      MEM(EA, size);  rA = EA; }
    if ( qualifier == (                                  LOAD_INDEXED ) ) { EA = rA + rB;      rD =      MEM(EA, size);           } // TODO: if rA == 0 then b = 0 else b = (rA)

    if ( qualifier == ( LOAD_ALGEBRAIC                                ) ) { EA = rA + EXTS(d); rD = EXTS(MEM(EA, size));          } // TODO: if rA == 0 then b = 0 else b = (rA)
    if ( qualifier == ( LOAD_ALGEBRAIC | LOAD_UPDATING                ) ) { EA = rA + EXTS(d); rD = EXTS(MEM(EA, size)); rA = EA; }
    if ( qualifier == ( LOAD_ALGEBRAIC | LOAD_UPDATING | LOAD_INDEXED ) ) { EA = rA + rB;      rD = EXTS(MEM(EA, size)); rA = EA; }
    if ( qualifier == ( LOAD_ALGEBRAIC                 | LOAD_INDEXED ) ) { EA = rA + rB;      rD = EXTS(MEM(EA, size));          } // TODO: if rA == 0 then b = 0 else b = (rA)

    if ( qualifier == ( LOAD_REVERSED                  | LOAD_INDEXED ) )
    { if ( size == LOAD_HALFWORD ) { EA = rA + rB; rD  = ((MEM(EA +0, 1) &lt;&lt;  0) | (MEM(EA +1, 1) &lt;&lt;  8)); }   // TODO: if rA == 0 then b = 0 else b = (rA)
      if ( size == LOAD_WORD     ) { EA = rA + rB; rD  = ((MEM(EA +0, 1) &lt;&lt;  0) | (MEM(EA +1, 1) &lt;&lt;  8));     // TODO: if rA == 0 then b = 0 else b = (rA)
                                                   rD |= ((MEM(EA +2, 1) &lt;&lt; 16) | (MEM(EA +3, 1) &lt;&lt; 24)); }}}

  if ( operator == MEMORY_STORE )
  { if ( !( qualifier &amp; STORE_INDEXED ) ) { rS = rD_or_RS; d  = d_or_rA; rA = rA_or_rB; }
    if (  ( qualifier &amp; STORE_INDEXED ) ) { rS = rD_or_RS; rA = d_or_rA; rB = rA_or_rB; }

    if ( qualifier == ( 0                              ) ) { EA = rA + EXTS(d); /* MEM(EA, size) = ((rS)); */          } // TODO: if rA == 0 then b = 0 else b = (rA)
    if ( qualifier == ( STORE_UPDATING                 ) ) { EA = rA + EXTS(d); /* MEM(EA, size) = ((rS)); */ rA = EA; }
    if ( qualifier == ( STORE_UPDATING | STORE_INDEXED ) ) { EA = rA + rB;      /* MEM(EA, size) = ((rS)); */ rA = EA; }
    if ( qualifier == (                  STORE_INDEXED ) ) { EA = rA + rB;      /* MEM(EA, size) = ((rS)); */          } // TODO: if rA == 0 then b = 0 else b = (rA)

    if ( qualifier == ( STORE_REVERSED | STORE_INDEXED ) )
    { if ( size == STORE_HALFWORD ) { EA = rA + rB; /* MEM(EA +0, 1) = ((rS)); MEM(EA +1, 1) &lt;&lt;  8)) = ((rS)); */ }   // TODO: if rA == 0 then b = 0 else b = (rA)
      if ( size == STORE_WORD     ) { EA = rA + rB; /* MEM(EA +0, 1) = ((rS)); MEM(EA +1, 1) &lt;&lt;  8)) = ((rS)); */     // TODO: if rA == 0 then b = 0 else b = (rA)
                                                    /* MEM(EA +2, 1) = ((rS)); MEM(EA +3, 1) &lt;&lt;  8)) = ((rS)); */ }}}
}

void _lbz    ( uint5_t rD , sint16_t d  , uint5_t rA ) { _MEMORY( MEMORY_LOAD  , 0                                               , LOAD_BYTE      , rD , d  , rA ); }
void _lbzu   ( uint5_t rD , sint16_t d  , uint5_t rA ) { _MEMORY( MEMORY_LOAD  ,                  LOAD_UPDATING                  , LOAD_BYTE      , rD , d  , rA ); }
void _lbzux  ( uint5_t rD , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_LOAD  ,                  LOAD_UPDATING  | LOAD_INDEXED  , LOAD_BYTE      , rD , rA , rB ); }
void _lbzx   ( uint5_t rD , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_LOAD  ,                                   LOAD_INDEXED  , LOAD_BYTE      , rD , rA , rB ); }
void _lha    ( uint5_t rD , sint16_t d  , uint5_t rA ) { _MEMORY( MEMORY_LOAD  , LOAD_ALGEBRAIC                                  , LOAD_HALFWORD  , rD , d  , rA ); }
void _lhau   ( uint5_t rD , sint16_t d  , uint5_t rA ) { _MEMORY( MEMORY_LOAD  , LOAD_ALGEBRAIC | LOAD_UPDATING                  , LOAD_HALFWORD  , rD , d  , rA ); }
void _lhaux  ( uint5_t rD , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_LOAD  , LOAD_ALGEBRAIC | LOAD_UPDATING  | LOAD_INDEXED  , LOAD_HALFWORD  , rD , rA , rB ); }
void _lhax   ( uint5_t rD , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_LOAD  , LOAD_ALGEBRAIC                  | LOAD_INDEXED  , LOAD_HALFWORD  , rD , rA , rB ); }
void _lhz    ( uint5_t rD , sint16_t d  , uint5_t rA ) { _MEMORY( MEMORY_LOAD  , 0                                               , LOAD_HALFWORD  , rD , d  , rA ); }
void _lhzu   ( uint5_t rD , sint16_t d  , uint5_t rA ) { _MEMORY( MEMORY_LOAD  ,                  LOAD_UPDATING                  , LOAD_HALFWORD  , rD , d  , rA ); }
void _lhzux  ( uint5_t rD , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_LOAD  ,                  LOAD_UPDATING  | LOAD_INDEXED  , LOAD_HALFWORD  , rD , rA , rB ); }
void _lhzx   ( uint5_t rD , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_LOAD  ,                                   LOAD_INDEXED  , LOAD_HALFWORD  , rD , rA , rB ); }
void _lhbrx  ( uint5_t rD , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_LOAD  , LOAD_REVERSED                   | LOAD_INDEXED  , LOAD_HALFWORD  , rD , rA , rB ); }
void _lwz    ( uint5_t rD , sint16_t d  , uint5_t rA ) { _MEMORY( MEMORY_LOAD  , 0                                               , LOAD_WORD      , rD , d  , rA ); }
void _lwzu   ( uint5_t rD , sint16_t d  , uint5_t rA ) { _MEMORY( MEMORY_LOAD  ,                  LOAD_UPDATING                  , LOAD_WORD      , rD , d  , rA ); }
void _lwzux  ( uint5_t rD , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_LOAD  ,                  LOAD_UPDATING  | LOAD_INDEXED  , LOAD_WORD      , rD , rA , rB ); }
void _lwzx   ( uint5_t rD , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_LOAD  ,                                   LOAD_INDEXED  , LOAD_WORD      , rD , rA , rB ); }
void _lwbrx  ( uint5_t rD , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_LOAD  , LOAD_REVERSED                   | LOAD_INDEXED  , LOAD_WORD      , rD , rA , rB ); }

void _stb    ( uint5_t rS , sint16_t d  , uint5_t rA ) { _MEMORY( MEMORY_STORE , 0                                               , STORE_BYTE     , rS , d  , rA ); }
void _stbu   ( uint5_t rS , sint16_t d  , uint5_t rA ) { _MEMORY( MEMORY_STORE ,                  STORE_UPDATING                 , STORE_BYTE     , rS , d  , rA ); }
void _stbux  ( uint5_t rS , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_STORE ,                  STORE_UPDATING | STORE_INDEXED , STORE_BYTE     , rS , rA , rB ); }
void _stbx   ( uint5_t rS , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_STORE ,                                   STORE_INDEXED , STORE_BYTE     , rS , rA , rB ); }
void _sth    ( uint5_t rS , sint16_t d  , uint5_t rA ) { _MEMORY( MEMORY_STORE , 0                                               , STORE_HALFWORD , rS , d  , rA ); }
void _sthu   ( uint5_t rS , sint16_t d  , uint5_t rA ) { _MEMORY( MEMORY_STORE ,                  STORE_UPDATING                 , STORE_HALFWORD , rS , d  , rA ); }
void _sthux  ( uint5_t rS , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_STORE ,                  STORE_UPDATING | STORE_INDEXED , STORE_HALFWORD , rS , rA , rB ); }
void _sthx   ( uint5_t rS , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_STORE ,                                   STORE_INDEXED , STORE_HALFWORD , rS , rA , rB ); }
void _sthbrx ( uint5_t rS , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_STORE , STORE_REVERSED                  | STORE_INDEXED , STORE_HALFWORD , rS , rA , rB ); }
void _stw    ( uint5_t rS , sint16_t d  , uint5_t rA ) { _MEMORY( MEMORY_STORE , 0                                               , STORE_WORD     , rS , d  , rA ); }
void _stwu   ( uint5_t rS , sint16_t d  , uint5_t rA ) { _MEMORY( MEMORY_STORE ,                  STORE_UPDATING                 , STORE_WORD     , rS , d  , rA ); }
void _stwux  ( uint5_t rS , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_STORE ,                  STORE_UPDATING | STORE_INDEXED , STORE_WORD     , rS , rA , rB ); }
void _stwx   ( uint5_t rS , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_STORE ,                                   STORE_INDEXED , STORE_WORD     , rS , rA , rB ); }
void _stwbrx ( uint5_t rS , uint5_t  rA , uint5_t rB ) { _MEMORY( MEMORY_STORE , STORE_REVERSED                  | STORE_INDEXED , STORE_WORD     , rS , rA , rB ); }

// Branching instructions:

const int BO_not_ctr_not_cond =  0;
const int BO_____ctr_not_cond =  2;
const int BO_________not_cond =  4;
const int BO_not_ctr_____cond =  8;
const int BO_____ctr_____cond = 10;
const int BO_____________cond = 12;
const int BO_not_ctr_________ = 16;
const int BO_____ctr_________ = 18;
const int BO_________________ = 20; // Branch always

void _BRANCH( int qualifier, uint5_t BO, uint5_t BI, sint32_t target_addr , uint1_t AA, uint1_t LK ) {
  bool ctr_ok, cond_ok;

  uint3_t crfD     = BI / 4;
  uint2_t crfD_bit = BI % 4; 

  if ( qualifier == BRANCH_CONDITIONALLY )
  { if (!getBit(BO, 2)) { ctr = ctr -1; }
    ctr_ok  = getBit(BO, 2) || ((ctr != 0) ^ getBit(BO, 1));
    cond_ok = getBit(BO, 4) || (getBit(crfD, crfD_bit) == getBit(BO, 3)); }

  if ( qualifier == BRANCH_UNCONDITIONALLY ) {                        /* jump to target_addr */; }
  if ( qualifier == BRANCH_CONDITIONALLY   ) { if (ctr_ok &amp;&amp; cond_ok) /* jump to target_addr */; }
    if ( qualifier &amp;  BRANCH_TOLR          ) { if (ctr_ok &amp;&amp; cond_ok) /* jump to LR          */; }
    if ( qualifier &amp;  BRANCH_TOCTR         ) { if (true   &amp;&amp; cond_ok) /* jump to CTR         */; }
}

void _b        (                           sint32_t target_addr ) { _BRANCH( BRANCH_UNCONDITIONALLY                , 0  , 0  , target_addr , false , false ); }
void _ba       (                           sint32_t target_addr ) { _BRANCH( BRANCH_UNCONDITIONALLY                , 0  , 0  , target_addr , true  , false ); }
void _bl       (                           sint32_t target_addr ) { _BRANCH( BRANCH_UNCONDITIONALLY                , 0  , 0  , target_addr , false , true  ); }
void _bla      (                           sint32_t target_addr ) { _BRANCH( BRANCH_UNCONDITIONALLY                , 0  , 0  , target_addr , true  , true  ); }
void _bc       ( uint5_t BO , uint5_t BI , sint32_t target_addr ) { _BRANCH( BRANCH_CONDITIONALLY                  , BO , BI , target_addr , false , false ); }
void _bca      ( uint5_t BO , uint5_t BI , sint32_t target_addr ) { _BRANCH( BRANCH_CONDITIONALLY                  , BO , BI , target_addr , true  , false ); }
void _bcl      ( uint5_t BO , uint5_t BI , sint32_t target_addr ) { _BRANCH( BRANCH_CONDITIONALLY                  , BO , BI , target_addr , false , true  ); }
void _bcla     ( uint5_t BO , uint5_t BI , sint32_t target_addr ) { _BRANCH( BRANCH_CONDITIONALLY                  , BO , BI , target_addr , true  , true  ); }
void _bcctr    ( uint5_t BO , uint5_t BI                        ) { _BRANCH( BRANCH_CONDITIONALLY   | BRANCH_TOCTR , BO , BI , 0           , false , false ); }
void _bcctrl   ( uint5_t BO , uint5_t BI                        ) { _BRANCH( BRANCH_CONDITIONALLY   | BRANCH_TOCTR , BO , BI , 0           , false , true  ); }
void _bclr     ( uint5_t BO , uint5_t BI                        ) { _BRANCH( BRANCH_CONDITIONALLY   | BRANCH_TOLR  , BO , BI , 0           , false , false ); }
void _bclrl    ( uint5_t BO , uint5_t BI                        ) { _BRANCH( BRANCH_CONDITIONALLY   | BRANCH_TOLR  , BO , BI , 0           , false , true  ); }

void _bt       ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_____________cond , 0           , target_addr ); }
void _bf       ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_________not_cond , 0           , target_addr ); }
void _bdnz     ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_not_ctr_________ , 0           , target_addr ); }
void _bdnzt    ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_not_ctr_____cond , 0           , target_addr ); }
void _bdnzf    ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_not_ctr_not_cond , 0           , target_addr ); }
void _bdz      ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_____ctr_________ , 0           , target_addr ); }
void _bdzt     ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_____ctr_____cond , 0           , target_addr ); }
void _bdzf     ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_____ctr_not_cond , 0           , target_addr ); }
void _blt      ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_____________cond , CR_LT.index , target_addr ); }
void _ble      ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_________not_cond , CR_GT.index , target_addr ); }
void _beq      ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_____________cond , CR_EQ.index , target_addr ); }
void _bge      ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_________not_cond , CR_LT.index , target_addr ); }
void _bgt      ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_____________cond , CR_GT.index , target_addr ); }
void _bnl      ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_________not_cond , CR_LT.index , target_addr ); }
void _bne      ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_________not_cond , CR_EQ.index , target_addr ); }
void _bng      ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_________not_cond , CR_GT.index , target_addr ); }
void _bso      ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_____________cond , CR_SO.index , target_addr ); }
void _bns      ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_________not_cond , CR_SO.index , target_addr ); }
void _bun      ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_____________cond , CR_SO.index , target_addr ); }
void _bnu      ( uint3_t crfD , sint32_t target_addr ) { _bc     ( BO_________not_cond , CR_SO.index , target_addr ); }

void _bta      ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_____________cond , 0           , target_addr ); }
void _bfa      ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_________not_cond , 0           , target_addr ); }
void _bdnza    ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_not_ctr_________ , 0           , target_addr ); }
void _bdnzta   ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_not_ctr_____cond , 0           , target_addr ); }
void _bdnzfa   ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_not_ctr_not_cond , 0           , target_addr ); }
void _bdza     ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_____ctr_________ , 0           , target_addr ); }
void _bdzta    ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_____ctr_____cond , 0           , target_addr ); }
void _bdzfa    ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_____ctr_not_cond , 0           , target_addr ); }
void _blta     ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_____________cond , CR_LT.index , target_addr ); }
void _blea     ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_________not_cond , CR_GT.index , target_addr ); }
void _beqa     ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_____________cond , CR_EQ.index , target_addr ); }
void _bgea     ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_________not_cond , CR_LT.index , target_addr ); }
void _bgta     ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_____________cond , CR_GT.index , target_addr ); }
void _bnla     ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_________not_cond , CR_LT.index , target_addr ); }
void _bnea     ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_________not_cond , CR_EQ.index , target_addr ); }
void _bnga     ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_________not_cond , CR_GT.index , target_addr ); }
void _bsoa     ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_____________cond , CR_SO.index , target_addr ); }
void _bnsa     ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_________not_cond , CR_SO.index , target_addr ); }
void _buna     ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_____________cond , CR_SO.index , target_addr ); }
void _bnua     ( uint3_t crfD , sint32_t target_addr ) { _bca    ( BO_________not_cond , CR_SO.index , target_addr ); }

void _btl      ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_____________cond , 0           , target_addr ); }
void _bfl      ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_________not_cond , 0           , target_addr ); }
void _bdnzl    ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_not_ctr_________ , 0           , target_addr ); }
void _bdnztl   ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_not_ctr_____cond , 0           , target_addr ); }
void _bdnzfl   ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_not_ctr_not_cond , 0           , target_addr ); }
void _bdzl     ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_____ctr_________ , 0           , target_addr ); }
void _bdztl    ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_____ctr_____cond , 0           , target_addr ); }
void _bdzfl    ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_____ctr_not_cond , 0           , target_addr ); }
void _bltl     ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_____________cond , CR_LT.index , target_addr ); }
void _blel     ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_________not_cond , CR_GT.index , target_addr ); }
void _beql     ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_____________cond , CR_EQ.index , target_addr ); }
void _bgel     ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_________not_cond , CR_LT.index , target_addr ); }
void _bgtl     ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_____________cond , CR_GT.index , target_addr ); }
void _bnll     ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_________not_cond , CR_LT.index , target_addr ); }
void _bnel     ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_________not_cond , CR_EQ.index , target_addr ); }
void _bngl     ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_________not_cond , CR_GT.index , target_addr ); }
void _bsol     ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_____________cond , CR_SO.index , target_addr ); }
void _bnsl     ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_________not_cond , CR_SO.index , target_addr ); }
void _bunl     ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_____________cond , CR_SO.index , target_addr ); }
void _bnul     ( uint3_t crfD , sint32_t target_addr ) { _bcl    ( BO_________not_cond , CR_SO.index , target_addr ); }

void _btla     ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_____________cond , 0           , target_addr ); }
void _bfla     ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_________not_cond , 0           , target_addr ); }
void _bdnzla   ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_not_ctr_________ , 0           , target_addr ); }
void _bdnztla  ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_not_ctr_____cond , 0           , target_addr ); }
void _bdnzfla  ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_not_ctr_not_cond , 0           , target_addr ); }
void _bdzla    ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_____ctr_________ , 0           , target_addr ); }
void _bdztla   ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_____ctr_____cond , 0           , target_addr ); }
void _bdzfla   ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_____ctr_not_cond , 0           , target_addr ); }
void _bltla    ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_____________cond , CR_LT.index , target_addr ); }
void _blela    ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_________not_cond , CR_GT.index , target_addr ); }
void _beqla    ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_____________cond , CR_EQ.index , target_addr ); }
void _bgela    ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_________not_cond , CR_LT.index , target_addr ); }
void _bgtla    ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_____________cond , CR_GT.index , target_addr ); }
void _bnlla    ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_________not_cond , CR_LT.index , target_addr ); }
void _bnela    ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_________not_cond , CR_EQ.index , target_addr ); }
void _bngla    ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_________not_cond , CR_GT.index , target_addr ); }
void _bsola    ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_____________cond , CR_SO.index , target_addr ); }
void _bnsla    ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_________not_cond , CR_SO.index , target_addr ); }
void _bunla    ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_____________cond , CR_SO.index , target_addr ); }
void _bnula    ( uint3_t crfD , sint32_t target_addr ) { _bcla   ( BO_________not_cond , CR_SO.index , target_addr ); }

void _blr      ( uint3_t crfD                        ) { _bclr   ( BO_________________ , 0                         ); }
void _btlr     ( uint3_t crfD                        ) { _bclr   ( BO_____________cond , 0                         ); }
void _bflr     ( uint3_t crfD                        ) { _bclr   ( BO_________not_cond , 0                         ); }
void _bdnzlr   ( uint3_t crfD                        ) { _bclr   ( BO_not_ctr_________ , 0                         ); }
void _bdnztlr  ( uint3_t crfD                        ) { _bclr   ( BO_not_ctr_____cond , 0                         ); }
void _bdnzflr  ( uint3_t crfD                        ) { _bclr   ( BO_not_ctr_not_cond , 0                         ); }
void _bdzlr    ( uint3_t crfD                        ) { _bclr   ( BO_____ctr_________ , 0                         ); }
void _bdztlr   ( uint3_t crfD                        ) { _bclr   ( BO_____ctr_____cond , 0                         ); }
void _bdzflr   ( uint3_t crfD                        ) { _bclr   ( BO_____ctr_not_cond , 0                         ); }
void _bltlr    ( uint3_t crfD                        ) { _bclr   ( BO_____________cond , CR_LT.index               ); }
void _blelr    ( uint3_t crfD                        ) { _bclr   ( BO_________not_cond , CR_GT.index               ); }
void _beqlr    ( uint3_t crfD                        ) { _bclr   ( BO_____________cond , CR_EQ.index               ); }
void _bgelr    ( uint3_t crfD                        ) { _bclr   ( BO_________not_cond , CR_LT.index               ); }
void _bgtlr    ( uint3_t crfD                        ) { _bclr   ( BO_____________cond , CR_GT.index               ); }
void _bnllr    ( uint3_t crfD                        ) { _bclr   ( BO_________not_cond , CR_LT.index               ); }
void _bnelr    ( uint3_t crfD                        ) { _bclr   ( BO_________not_cond , CR_EQ.index               ); }
void _bnglr    ( uint3_t crfD                        ) { _bclr   ( BO_________not_cond , CR_GT.index               ); }
void _bsolr    ( uint3_t crfD                        ) { _bclr   ( BO_____________cond , CR_SO.index               ); }
void _bnslr    ( uint3_t crfD                        ) { _bclr   ( BO_________not_cond , CR_SO.index               ); }
void _bunlr    ( uint3_t crfD                        ) { _bclr   ( BO_____________cond , CR_SO.index               ); }
void _bnulr    ( uint3_t crfD                        ) { _bclr   ( BO_________not_cond , CR_SO.index               ); }
			                            						                  
void _bctr     ( uint3_t crfD                        ) { _bcctr  ( BO_________________ , 0                         ); }
void _btctr    ( uint3_t crfD                        ) { _bcctr  ( BO_____________cond , 0                         ); }
void _bfctr    ( uint3_t crfD                        ) { _bcctr  ( BO_________not_cond , 0                         ); }			        
void _bltctr   ( uint3_t crfD                        ) { _bcctr  ( BO_____________cond , CR_LT.index               ); }
void _blectr   ( uint3_t crfD                        ) { _bcctr  ( BO_________not_cond , CR_GT.index               ); }
void _beqctr   ( uint3_t crfD                        ) { _bcctr  ( BO_____________cond , CR_EQ.index               ); }
void _bgectr   ( uint3_t crfD                        ) { _bcctr  ( BO_________not_cond , CR_LT.index               ); }
void _bgtctr   ( uint3_t crfD                        ) { _bcctr  ( BO_____________cond , CR_GT.index               ); }
void _bnlctr   ( uint3_t crfD                        ) { _bcctr  ( BO_________not_cond , CR_LT.index               ); }
void _bnectr   ( uint3_t crfD                        ) { _bcctr  ( BO_________not_cond , CR_EQ.index               ); }
void _bngctr   ( uint3_t crfD                        ) { _bcctr  ( BO_________not_cond , CR_GT.index               ); }
void _bsoctr   ( uint3_t crfD                        ) { _bcctr  ( BO_____________cond , CR_SO.index               ); }
void _bnsctr   ( uint3_t crfD                        ) { _bcctr  ( BO_________not_cond , CR_SO.index               ); }
void _bunctr   ( uint3_t crfD                        ) { _bcctr  ( BO_____________cond , CR_SO.index               ); }
void _bnuctr   ( uint3_t crfD                        ) { _bcctr  ( BO_________not_cond , CR_SO.index               ); }
			                            						                  
void _blrl     ( uint3_t crfD                        ) { _bclrl  ( BO_________________ , 0                         ); }
void _btlrl    ( uint3_t crfD                        ) { _bclrl  ( BO_____________cond , 0                         ); }
void _bflrl    ( uint3_t crfD                        ) { _bclrl  ( BO_________not_cond , 0                         ); }
void _bdnzlrl  ( uint3_t crfD                        ) { _bclrl  ( BO_not_ctr_________ , 0                         ); }
void _bdnztlrl ( uint3_t crfD                        ) { _bclrl  ( BO_not_ctr_____cond , 0                         ); }
void _bdnzflrl ( uint3_t crfD                        ) { _bclrl  ( BO_not_ctr_not_cond , 0                         ); }
void _bdzlrl   ( uint3_t crfD                        ) { _bclrl  ( BO_____ctr_________ , 0                         ); }
void _bdztlrl  ( uint3_t crfD                        ) { _bclrl  ( BO_____ctr_____cond , 0                         ); }
void _bdzflrl  ( uint3_t crfD                        ) { _bclrl  ( BO_____ctr_not_cond , 0                         ); }
void _bltlrl   ( uint3_t crfD                        ) { _bclrl  ( BO_____________cond , CR_LT.index               ); }
void _blelrl   ( uint3_t crfD                        ) { _bclrl  ( BO_________not_cond , CR_GT.index               ); }
void _beqlrl   ( uint3_t crfD                        ) { _bclrl  ( BO_____________cond , CR_EQ.index               ); }
void _bgelrl   ( uint3_t crfD                        ) { _bclrl  ( BO_________not_cond , CR_LT.index               ); }
void _bgtlrl   ( uint3_t crfD                        ) { _bclrl  ( BO_____________cond , CR_GT.index               ); }
void _bnllrl   ( uint3_t crfD                        ) { _bclrl  ( BO_________not_cond , CR_LT.index               ); }
void _bnelrl   ( uint3_t crfD                        ) { _bclrl  ( BO_________not_cond , CR_EQ.index               ); }
void _bnglrl   ( uint3_t crfD                        ) { _bclrl  ( BO_________not_cond , CR_GT.index               ); }
void _bsolrl   ( uint3_t crfD                        ) { _bclrl  ( BO_____________cond , CR_SO.index               ); }
void _bnslrl   ( uint3_t crfD                        ) { _bclrl  ( BO_________not_cond , CR_SO.index               ); }
void _bunlrl   ( uint3_t crfD                        ) { _bclrl  ( BO_____________cond , CR_SO.index               ); }
void _bnulrl   ( uint3_t crfD                        ) { _bclrl  ( BO_________not_cond , CR_SO.index               ); }
			                            						                  
void _bctrl    ( uint3_t crfD                        ) { _bcctrl ( BO_________________ , 0                         ); }
void _btctrl   ( uint3_t crfD                        ) { _bcctrl ( BO_____________cond , 0                         ); }
void _bfctrl   ( uint3_t crfD                        ) { _bcctrl ( BO_________not_cond , 0                         ); }	
void _bltctrl  ( uint3_t crfD                        ) { _bcctrl ( BO_____________cond , CR_LT.index               ); }
void _blectrl  ( uint3_t crfD                        ) { _bcctrl ( BO_________not_cond , CR_GT.index               ); }
void _beqctrl  ( uint3_t crfD                        ) { _bcctrl ( BO_____________cond , CR_EQ.index               ); }
void _bgectrl  ( uint3_t crfD                        ) { _bcctrl ( BO_________not_cond , CR_LT.index               ); }
void _bgtctrl  ( uint3_t crfD                        ) { _bcctrl ( BO_____________cond , CR_GT.index               ); }
void _bnlctrl  ( uint3_t crfD                        ) { _bcctrl ( BO_________not_cond , CR_LT.index               ); }
void _bnectrl  ( uint3_t crfD                        ) { _bcctrl ( BO_________not_cond , CR_EQ.index               ); }
void _bngctrl  ( uint3_t crfD                        ) { _bcctrl ( BO_________not_cond , CR_GT.index               ); }
void _bsoctrl  ( uint3_t crfD                        ) { _bcctrl ( BO_____________cond , CR_SO.index               ); }
void _bnsctrl  ( uint3_t crfD                        ) { _bcctrl ( BO_________not_cond , CR_SO.index               ); }
void _bunctrl  ( uint3_t crfD                        ) { _bcctrl ( BO_____________cond , CR_SO.index               ); }
void _bnuctrl  ( uint3_t crfD                        ) { _bcctrl ( BO_________not_cond , CR_SO.index               ); }

// Processor contreol instructions:
/* TODO: reimplement.
void _mfcr  ( uint5_t rD               ) { rD  = cr;                      }
void _mfxer ( uint5_t rD               ) { rD  = xer;                     }
void _mfctr ( uint5_t rD               ) { rD  = ctr;                     }
void _mfspr ( uint5_t rD , uint5_t spr ) { if (spr == 1) { _mfxer (rD); }
                                           if (spr == 9) { _mfctr (rD); } }

void _mtxer (               uint5_t rS ) { xer = rS;                      }
void _mtctr (               uint5_t rS ) { ctr = rS;                      }
void _mtspr ( uint5_t spr , uint5_t rS ) { if (spr == 1) { _mtxer (rS); }
                                           if (spr == 9) { _mtctr (rS); } }
*/
/* Flash: */

void Flash_Init() {
  Flash.burst_index = 0;
}

bool Flash_IsTerminated() {
  return _mustTerminate;
}

/* Static RAM (SRAM): */

void SRAM_Init() {
  SRAM.executing = false;
}

bool SRAM_IsAccessed() {
  return ((EUs.pipeline[EUS_PIPELINE_E] != -1) &amp;&amp;
          _INSTS[EUs.pipeline[EUS_PIPELINE_E]].do_memory);
}

bool SRAM_IsTerminated() {
  return _mustTerminate;
}

/* Instruction Memory Unit (IMU): */

void IMU_Init(){
  int w, s;

  IMU.FillBuffer   = IMU_EMPTY_FILLBUFFER_LINE;
  IMU.ICache.index = -1;
  IMU.ICache.rp_way =  0;
  for (w = 0; w &lt; IMU_WAYS_MAX; ++w)
    for (s = 0; s &lt; IMU_USED_SETS_MAX; ++s)
      IMU.ICache.tags[w][s] = -1;
}

bool IMU_IsAccessed(int index) {
  return (IMU.ICache.index == index);
}

bool IMU_IsTerminated() {
  return _mustTerminate;
}

void IMU_Set() {
  IMU.ICache.index = InCU.PC;
}

void IMU_FillBuffer_Update() {
  IMU.FillBuffer.filled[IMU.FillBuffer.dword] = true;
  IMU.FillBuffer.dword = (IMU.FillBuffer.dword +1) % IMU_FILLBUFFER_DWORDS_MAX;
}

int IMU_ICache_Lookup() {
  // return wether the current instruction is in the instruction cache (or line buffer) or not
  int                          addr  = _INSTS[IMU.ICache.index].addr;
  int[0, IMU_WAYS_MAX]         way;
  int[0, IMU_USED_SETS_MAX -1] set   = (addr /  32) % IMU_SETS_MAX;
  int                          tag   =  addr / (32  * IMU_SETS_MAX);
  int                          dword = (addr /   8) % IMU_FILLBUFFER_DWORDS_MAX;

  // Is in cache?
  int icache_tag;
  for (way = 0; way &lt; IMU_WAYS_MAX; ++way) {
    icache_tag = IMU.ICache.tags[way][set];

    if (icache_tag != -1
    &amp;&amp;  icache_tag == tag)
      return IMU_CACHE_HIT;
  }

  // Is in fill buffer?
  if (IMU.FillBuffer.set == set
  &amp;&amp;  IMU.FillBuffer.tag == tag) {
    if (IMU.FillBuffer.filled[dword]) return IMU_FILLBUFFER_HIT;
    else                              return IMU_FILLBUFFER_MISS;
  }

  return IMU_CACHE_MISS;
}

bool IMU_ICache_Hit      () { return ( IMU_ICache_Lookup() == IMU_CACHE_HIT       ); }
bool IMU_FillBuffer_Hit  () { return ( IMU_ICache_Lookup() == IMU_FILLBUFFER_HIT  ); }
bool IMU_FillBuffer_Miss () { return ( IMU_ICache_Lookup() == IMU_FILLBUFFER_MISS ); }
bool IMU_ICache_Miss     () { return ( IMU_ICache_Lookup() == IMU_CACHE_MISS      ); }

void IMU_ICache_Update() {
  // on a miss, insert the current instruction on the instruction cache
  int                          addr = _INSTS[IMU.FillBuffer.index].addr;
  int[0, IMU_WAYS_MAX]         way;
  int[0, IMU_USED_SETS_MAX -1] set   = (addr /  32) % IMU_SETS_MAX;
  int                          tag   =  addr / (32  * IMU_SETS_MAX);

  bool found = false;

  way = 0;
  while (!found &amp;&amp; way &lt; IMU_WAYS_MAX)
    if (IMU.ICache.tags[way][set] == -1)
      found = true;
    else ++way; // conditional increment (thus not a for loop)
  if (found) {
    // free slot found
    IMU.ICache.tags[way][set] = tag;

  } else {
    // no free slot found (pseudo round-robin replacement policy)
    way = IMU.ICache.rp_way;
    IMU.ICache.tags[way][set] = tag;
    IMU.ICache.rp_way = (IMU.ICache.rp_way +1) % IMU_WAYS_MAX;
  }
}

void IMU_FillBuffer_Set() {
  int                     addr = _INSTS[IMU.ICache.index].addr;
  int[0, IMU_SETS_MAX -1] set  = (addr /  32) % IMU_SETS_MAX;  // TODO: add _USED
  int                     tag  =  addr / (32  * IMU_SETS_MAX);

  IMU.FillBuffer       = IMU_EMPTY_FILLBUFFER_LINE;
  IMU.FillBuffer.index = IMU.ICache.index;
  IMU.FillBuffer.dword = (addr / 8) % IMU_FILLBUFFER_DWORDS_MAX;
  IMU.FillBuffer.set   = set;
  IMU.FillBuffer.tag   = tag;
}

/* Instruction and Control Unit (InCU): */

void InCU_Init() {
  int i;

  InCU.BTB.top = 0;
  for (i = 0; i &lt; INCU_BTB_MAX; ++i) {
    InCU.BTB.buffer[i].index = -1;
    InCU.BTB.buffer[i].prediction = -1;
  }

  InCU.PC = -1;
  InCU.IBuff.count = 0;
  for (i = 0; i &lt; INCU_IBUFF_MAX; ++i)
    InCU.IBuff.buffer[i] = INCU_EMPTY_IBUFF_ENTRY;  
  InCU.IR = INCU_EMPTY_IR;
}

int InCU_BTB_Predict(int index) {
  int i;
  int btb_index = -1;

  if (_INSTS[index].do_branch)
    for (i = 0; i &lt; INCU_BTB_MAX; ++i)
      if (InCU.BTB.buffer[i].index == index)
        btb_index = i;

  if (btb_index != -1) {
    if (InCU.BTB.buffer[btb_index].prediction == INCU_WEAKLY_______TAKEN
    ||  InCU.BTB.buffer[btb_index].prediction == INCU_STRONGLY_____TAKEN)
      return _INSTS[index].target;
  }

  return index +1;
}

void InCU_BTB_Update(int index, bool taken) {
  int i;
  int btb_index = -1;

  for (i = 0; i &lt; INCU_BTB_MAX; ++i)
    if (InCU.BTB.buffer[i].index == index)
      btb_index = i;
    
  if (btb_index != -1) {
    // Fix prediction
    if (taken) {
      InCU.BTB.buffer[btb_index].prediction =  InCU.BTB.buffer[btb_index].prediction +1;
      InCU.BTB.buffer[btb_index].prediction = (InCU.BTB.buffer[btb_index].prediction &gt; INCU_STRONGLY_____TAKEN) ? INCU_STRONGLY_____TAKEN : InCU.BTB.buffer[btb_index].prediction;
    } else {
      InCU.BTB.buffer[btb_index].prediction =  InCU.BTB.buffer[btb_index].prediction -1;
      InCU.BTB.buffer[btb_index].prediction = (InCU.BTB.buffer[btb_index].prediction &lt; INCU_STRONGLY_NOT_TAKEN) ? INCU_STRONGLY_NOT_TAKEN : InCU.BTB.buffer[btb_index].prediction;
    }

  } else {
    /* "On initial allocation of an entry to the BTB for a taken branch,
     *  the counter is initialized to the weakly-taken state."
     *  (cf. e200z4 manual, p. 4-7) */
    if (taken) { // Insert (FIFO)
      InCU_BTB_Entry_t new_entry = {index, INCU_WEAKLY_______TAKEN};

      InCU.BTB.buffer[InCU.BTB.top] = new_entry;
      InCU.BTB.top = (InCU.BTB.top +1) % INCU_BTB_MAX;
    }
  }
}

void InCU_PC_Update() {
  int i;
  int index;
  
  if (InCU.PC != IMU.ICache.index)
    return;

  InCU.PC = InCU_BTB_Predict(InCU.PC);
  for (i = 0; i &lt; INCU_BTB_MAX; ++i)
    if (InCU.BTB.buffer[i].index == InCU.PC) {
      
      _dynamic_prediction = true;
      index = InCU_BTB_Predict(InCU.PC);
      if (index != InCU.PC +1)
	    _predict_taken = true;

      return;
    }
}

bool InCU_IBuff_IsFull() {
  return (InCU.IBuff.count == INCU_IBUFF_MAX);
}

void InCU_IBuff_Push() {
  if (InCU.PC != IMU.ICache.index)
    return;

  if (InCU.IR.index == -1) {
    InCU.IR.index              = IMU.ICache.index;
    InCU.IR.predict_taken      = _predict_taken;
    InCU.IR.dynamic_prediction = _dynamic_prediction;
    InCU.IR.taken              = _taken;
    
  } else {
    InCU.IBuff.buffer[InCU.IBuff.count].index              = IMU.ICache.index;
    InCU.IBuff.buffer[InCU.IBuff.count].predict_taken      = _predict_taken;
    InCU.IBuff.buffer[InCU.IBuff.count].dynamic_prediction = _dynamic_prediction;
    InCU.IBuff.buffer[InCU.IBuff.count].taken              = _taken;
    InCU.IBuff.count++;
  }
  
  _predict_taken      = false;
  _dynamic_prediction = false;
  _taken              = false;
}

InCU_IR_t InCU_IBuff_Pop() {
  InCU_IR_t entry = INCU_EMPTY_IR;

  if (InCU.IBuff.count &gt; 0) {
    entry.index              = InCU.IBuff.buffer[0].index;
    entry.predict_taken      = InCU.IBuff.buffer[0].predict_taken;
    entry.dynamic_prediction = InCU.IBuff.buffer[0].dynamic_prediction;
    entry.taken              = InCU.IBuff.buffer[0].taken;
    
    InCU.IBuff.buffer[0] = InCU.IBuff.buffer[1];
    InCU.IBuff.buffer[1] = InCU.IBuff.buffer[2];
    InCU.IBuff.buffer[2] = InCU.IBuff.buffer[3];
    InCU.IBuff.buffer[3] = InCU.IBuff.buffer[4];
    InCU.IBuff.buffer[4] = InCU.IBuff.buffer[5];
    InCU.IBuff.buffer[5] = InCU.IBuff.buffer[6];
    InCU.IBuff.buffer[6] = InCU.IBuff.buffer[7];
    InCU.IBuff.buffer[7] = INCU_EMPTY_IBUFF_ENTRY;
    
    InCU.IBuff.count--;
    return entry;
  }

  return entry;
}

bool InCU_IsTerminated() {
  return _mustTerminate;
}

void InCU_Flush() {
  int i;

  InCU.IBuff.count = 0;
  for (i = 0; i &lt; INCU_IBUFF_MAX; ++i)
    InCU.IBuff.buffer[i] = INCU_EMPTY_IBUFF_ENTRY;
  InCU.IR = INCU_EMPTY_IR;
}

void InCU_Update() {
  InCU_IBuff_Push();
  InCU_PC_Update();
}

/* Execution Units (EUs): */

void EUs_Init() {
  int i;

  for (i = 0; i &lt; EUS_PIPELINE_MAX; ++i)
    EUs.pipeline[i] = -1;
  
  EUs.predict_taken      = false;
  EUs.dynamic_prediction = false;
  EUs.taken              = false;
  
  EUs.cycles = 0;
}

bool EUs_IsExecuting(int index) {
  return (EUs.pipeline[EUS_PIPELINE_D] == index);
}

bool EUs_IsTerminated() {
  return (_mustTerminate
       &amp;&amp; InCU.IR.index                == -1
       &amp;&amp; EUs.pipeline[EUS_PIPELINE_D] == -1
       &amp;&amp; EUs.pipeline[EUS_PIPELINE_E] == -1
       &amp;&amp; EUs.pipeline[EUS_PIPELINE_M] == -1
       &amp;&amp; EUs.pipeline[EUS_PIPELINE_W] == -1);
}

bool EUs_D_DoStall() { return EUs.pipeline[EUS_PIPELINE_D] != -1; }
bool EUs_E_DoStall() { return EUs.cycles != 0 || EUs.pipeline[EUS_PIPELINE_E] != -1; }
bool EUs_M_DoStall() { return SRAM.executing || EUs.cycles != 0 || EUs.pipeline[EUS_PIPELINE_M] != -1; }
bool EUs_W_DoStall() { return SRAM.executing; }

void EUs_Update() {
  bool do_stall = false;
  
  // Execute W (if doesn't stall):
  EUs.pipeline[EUS_PIPELINE_W] = -1;
  if (!EUs_W_DoStall()) {
    EUs.pipeline[EUS_PIPELINE_W] = EUs.pipeline[EUS_PIPELINE_M];
    EUs.pipeline[EUS_PIPELINE_M] = -1;
  }

  // Execute M (if doesn't stall):
  if (!EUs_M_DoStall()) {
    EUs.pipeline[EUS_PIPELINE_M] = EUs.pipeline[EUS_PIPELINE_E];
    EUs.pipeline[EUS_PIPELINE_E] = -1;
  }

  // Execute E (if doesn't stall):
  if (EUs.cycles &gt; 0)
    EUs.cycles--;

  /* Don't move inst in D to E if there are
   * data dependencies between D and M:
   */
  if (EUs.pipeline[EUS_PIPELINE_D] != -1
   &amp;&amp; EUs.pipeline[EUS_PIPELINE_E] == -1
   &amp;&amp; EUs.pipeline[EUS_PIPELINE_M] != -1
   &amp;&amp; _INSTS[EUs.pipeline[EUS_PIPELINE_M]].do_memory) {
    int i;
    _Inst_t inD = _INSTS[EUs.pipeline[EUS_PIPELINE_D]];
    _Inst_t inM = _INSTS[EUs.pipeline[EUS_PIPELINE_M]];

    for (i = 0; i &lt; _REGS_MAX; ++i)
      if (inM.write_regs[i] &amp; inD.read_regs[i])
        do_stall = true;
  }

  if (!EUs_E_DoStall() &amp;&amp; !do_stall) {
    EUs.pipeline[EUS_PIPELINE_E] = EUs.pipeline[EUS_PIPELINE_D];
    EUs.pipeline[EUS_PIPELINE_D] = -1;

    if (EUs.pipeline[EUS_PIPELINE_E] != -1) {
      EUs.cycles = _INSTS[EUs.pipeline[EUS_PIPELINE_E]].cycles -1;
      
      // Instruction is a branch
      if (_INSTS[EUs.pipeline[EUS_PIPELINE_E]].do_branch) {
	    // Update the BTB
	    InCU_BTB_Update(EUs.pipeline[EUS_PIPELINE_E], EUs.taken);
 
	    // Check for incorrect predictions:
	    if (EUs.predict_taken &amp;&amp; !EUs.taken) {
	      InCU.PC = EUs.pipeline[EUS_PIPELINE_E] +1;
	      InCU_Flush();
	    }
        if (!EUs.predict_taken &amp;&amp; EUs.taken) {
	      InCU.PC = _INSTS[EUs.pipeline[EUS_PIPELINE_E]].target;
	      InCU_Flush();
	    }
      }
    }
  }

  // Execute D (if doesn't stall):
  if (!EUs_D_DoStall()) {
    EUs.pipeline[EUS_PIPELINE_D] = InCU.IR.index;
    EUs.predict_taken            = InCU.IR.predict_taken;
    EUs.dynamic_prediction       = InCU.IR.dynamic_prediction;
    EUs.taken                    = InCU.IR.taken;
    
    InCU.IR = InCU_IBuff_Pop();

    // inst. in D is a backward branch then statically predict taken
    if (!EUs.dynamic_prediction
    &amp;&amp;  EUs.pipeline[EUS_PIPELINE_D] != -1
    &amp;&amp;  _INSTS[EUs.pipeline[EUS_PIPELINE_D]].do_branch
    &amp;&amp;  _INSTS[EUs.pipeline[EUS_PIPELINE_D]].target &lt; EUs.pipeline[EUS_PIPELINE_D]) {
      EUs.predict_taken = true;
      InCU.PC = _INSTS[EUs.pipeline[EUS_PIPELINE_D]].target;
      InCU_Flush(); // TODO: check wether it should be done or not
    }
  }
}

//////////////////////////////////////////
////////////////// Generated semantics: //
//////////////////////////////////////////
</declaration>
	<template>
		<name>Binary</name>
	</template>
	<template>
		<name>sched</name>
		<location id="id0" x="0" y="102" color="#ffc0cb">
			<name x="17" y="93">end</name>
			<committed/>
		</location>
		<location id="id1" x="0" y="0">
		</location>
		<location id="id2" x="-34" y="102">
			<urgent/>
		</location>
		<init ref="id2"/>
		<transition>
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="17" y="34">_doTerminate?</label>
			<label kind="assignment" x="17" y="51">_clock = 0</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-59" y="-59">_do?</label>
			<nail x="0" y="-102"/>
			<nail x="34" y="-102"/>
			<nail x="34" y="0"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-144" y="25">_doInitialize!</label>
			<label kind="assignment" x="-144" y="42">_Init(),
_clock = 0</label>
			<nail x="-34" y="0"/>
		</transition>
	</template>
	<template>
		<name>Flash_Memory</name>
		<location id="id3" x="0" y="-102">
		</location>
		<location id="id4" x="-68" y="204">
		</location>
		<location id="id5" x="-102" y="204">
			<urgent/>
		</location>
		<location id="id6" x="-68" y="102">
		</location>
		<location id="id7" x="-34" y="0">
			<label kind="invariant" x="-280" y="-25">Flash_clock &lt;= FLASH_LATENCY</label>
		</location>
		<init ref="id5"/>
		<transition>
			<source ref="id3"/>
			<target ref="id7"/>
			<label kind="guard" x="17" y="-93">Flash.burst_index != FLASH_BURST_MAX -1</label>
			<label kind="synchronisation" x="17" y="-76">Flash_doneBurst[Flash.burst_index]!</label>
			<label kind="assignment" x="17" y="-59">IMU_FillBuffer_Update(),
Flash.burst_index++,
Flash_clock = 0</label>
			<nail x="0" y="0"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id4"/>
			<label kind="guard" x="-51" y="136">Flash_IsTerminated()</label>
			<label kind="synchronisation" x="-51" y="153">_do!</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-212" y="136">_doInitialize?</label>
			<label kind="assignment" x="-212" y="153">Flash_Init()</label>
			<nail x="-102" y="102"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="guard" x="-246" y="8">!Flash_IsTerminated()</label>
			<label kind="synchronisation" x="-246" y="25">Flash_doBurst?</label>
			<label kind="assignment" x="-246" y="42">IMU_FillBuffer_Set(),
Flash.burst_index = 0,
Flash_clock = 0</label>
			<nail x="-68" y="0"/>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id6"/>
			<label kind="guard" x="17" y="17">Flash.burst_index == FLASH_BURST_MAX -1</label>
			<label kind="synchronisation" x="17" y="34">Flash_doneBurst[Flash.burst_index]!</label>
			<label kind="assignment" x="17" y="51">IMU_FillBuffer_Update(),
IMU_ICache_Update()</label>
			<nail x="0" y="102"/>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id3"/>
			<label kind="guard" x="-289" y="-85">Flash_clock == FLASH_LATENCY</label>
			<label kind="synchronisation" x="-289" y="-68">EUs_doStep?</label>
			<nail x="-34" y="-102"/>
		</transition>
	</template>
	<template>
		<name>Static_RAM</name>
		<location id="id8" x="170" y="306">
		</location>
		<location id="id9" x="136" y="306">
			<urgent/>
		</location>
		<location id="id10" x="170" y="204">
		</location>
		<location id="id11" x="204" y="102">
			<label kind="invariant" x="221" y="110">SRAM_clock &lt;= SRAM_LATENCY</label>
		</location>
		<init ref="id9"/>
		<transition>
			<source ref="id10"/>
			<target ref="id8"/>
			<label kind="guard" x="187" y="238">SRAM_IsTerminated()</label>
			<label kind="synchronisation" x="187" y="255">_do!</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id10"/>
			<label kind="synchronisation" x="25" y="238">_doInitialize?</label>
			<label kind="assignment" x="25" y="255">SRAM_Init()</label>
			<nail x="136" y="289"/>
			<nail x="136" y="204"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id11"/>
			<label kind="guard" x="-34" y="110">!SRAM_IsTerminated() &amp;&amp;
SRAM_IsAccessed()</label>
			<label kind="synchronisation" x="-34" y="144">EUs_doStep?</label>
			<label kind="assignment" x="-34" y="161">SRAM_clock = 0,
SRAM.executing = true</label>
			<nail x="170" y="102"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id10"/>
			<label kind="guard" x="221" y="144">SRAM_clock == SRAM_LATENCY</label>
			<label kind="synchronisation" x="221" y="161">EUs_doStep?</label>
			<label kind="assignment" x="221" y="178">SRAM.executing = false</label>
			<nail x="204" y="204"/>
		</transition>
	</template>
	<template>
		<name>Instruction_Memory_Unit</name>
		<location id="id12" x="-612" y="-102">
		</location>
		<location id="id13" x="-850" y="204">
		</location>
		<location id="id14" x="-782" y="-102">
		</location>
		<location id="id15" x="-646" y="0">
			<label kind="invariant" x="-629" y="17">IMU_clock &lt;= 1</label>
		</location>
		<location id="id16" x="-816" y="0">
		</location>
		<location id="id17" x="-850" y="102">
		</location>
		<location id="id18" x="-884" y="204">
			<urgent/>
		</location>
		<init ref="id18"/>
		<transition>
			<source ref="id12"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="-595" y="-68">IMU_doneAccess!</label>
			<label kind="assignment" x="-595" y="-51">IMU_clock = 0</label>
			<nail x="-612" y="0"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id17"/>
			<label kind="guard" x="-629" y="51">IMU_clock == 1</label>
			<label kind="synchronisation" x="-629" y="68">EUs_doStep?</label>
			<nail x="-646" y="102"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-765" y="-144">Flash_doneBurst[0]?</label>
			<label kind="assignment" x="-765" y="-127">IMU_clock = 0</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id14"/>
			<label kind="guard" x="-969" y="-68">IMU_ICache_Miss()</label>
			<label kind="synchronisation" x="-969" y="-51">Flash_doBurst!</label>
			<nail x="-816" y="-102"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id15"/>
			<label kind="guard" x="-799" y="-42">IMU_ICache_Hit() ||
IMU_FillBuffer_Hit()</label>
			<label kind="synchronisation" x="-799" y="8">IMU_doneAccess!</label>
			<label kind="assignment" x="-799" y="25">IMU_clock = 0</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id16"/>
			<label kind="guard" x="-1020" y="25">!IMU_IsTerminated()</label>
			<label kind="synchronisation" x="-1020" y="42">IMU_doAccess?</label>
			<label kind="assignment" x="-1020" y="59">IMU_Set()</label>
			<nail x="-850" y="0"/>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id13"/>
			<label kind="guard" x="-833" y="136">IMU_IsTerminated()</label>
			<label kind="synchronisation" x="-833" y="153">_do!</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-994" y="136">_doInitialize?</label>
			<label kind="assignment" x="-994" y="153">IMU_Init()</label>
			<nail x="-884" y="102"/>
		</transition>
	</template>
	<template>
		<name>Instruction_and_Control_Unit</name>
		<location id="id19" x="306" y="68">
		</location>
		<location id="id20" x="272" y="68">
			<urgent/>
		</location>
		<location id="id21" x="340" y="-136">
		</location>
		<location id="id22" x="306" y="-34">
		</location>
		<init ref="id20"/>
		<transition>
			<source ref="id22"/>
			<target ref="id19"/>
			<label kind="guard" x="323" y="0">InCU_IsTerminated()</label>
			<label kind="synchronisation" x="323" y="17">_do!</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="161" y="0">_doInitialize?</label>
			<label kind="assignment" x="161" y="17">InCU_Init()</label>
			<nail x="272" y="-34"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="357" y="-102">IMU_doneAccess?</label>
			<label kind="assignment" x="357" y="-85">InCU_Update()</label>
			<nail x="340" y="-34"/>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id21"/>
			<label kind="guard" x="110" y="-110">!InCU_IsTerminated() &amp;&amp;
!InCU_IBuff_IsFull()</label>
			<label kind="synchronisation" x="110" y="-76">IMU_doAccess!</label>
			<nail x="306" y="-136"/>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Execution_Units</name>
		<location id="id23" x="238" y="102">
		</location>
		<location id="id24" x="204" y="102">
			<urgent/>
		</location>
		<location id="id25" x="238" y="0">
			<label kind="invariant" x="102" y="-25">EUs_clock  &lt;= 1</label>
		</location>
		<init ref="id24"/>
		<transition>
			<source ref="id24"/>
			<target ref="id25"/>
			<label kind="synchronisation" x="59" y="25">_doInitialize?</label>
			<label kind="assignment" x="59" y="42">EUs_Init(),
EUs_clock  = 0</label>
			<nail x="204" y="0"/>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id23"/>
			<label kind="guard" x="255" y="34">EUs_IsTerminated()</label>
			<label kind="synchronisation" x="255" y="51">_doTerminate!</label>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id25"/>
			<label kind="guard" x="289" y="-93">!EUs_IsTerminated() &amp;&amp;
EUs_clock == 1</label>
			<label kind="synchronisation" x="289" y="-59">EUs_doStep!</label>
			<label kind="assignment" x="289" y="-42">EUs_Update(),
EUs_clock  = 0</label>
			<nail x="238" y="-102"/>
			<nail x="272" y="-102"/>
			<nail x="272" y="0"/>
		</transition>
	</template>
	<system>system
    sched
  , Flash_Memory
  , Static_RAM
  , Instruction_Memory_Unit
  , Instruction_and_Control_Unit
  , Execution_Units
  , Binary
  ;
</system>
	<queries>
		<query>
			<formula>A&lt;&gt; sched.end
			</formula>
			<comment>...
			</comment>
		</query>
		<query>
			<formula>sup: _clock
			</formula>
			<comment>...
			</comment>
		</query>
	</queries>
</nta>
