/**
 * generated by HARMLESS : 'Hardware ARchitecture Modeling Language
 *                          for Embedded Software Simulation'
 * model : e200z4
 *
 */

#ifndef __e200z4_INSTRUCTION_BASE_H__
#define __e200z4_INSTRUCTION_BASE_H__

#include "types.h"
#include "staticInfo.h"
#include <stdio.h>
#include <string> /* for instruction mnemonique */

class arch;

/** base class of all the instruction object. Should not be instantiated.
  */
class e200z4_instruction {
	/// use for the retain/release mechanism.
	int m_user;

	/// class code of the instruction (used by pipeline model)
	//const unsigned int m_classCode;

	/** instruction pointer, corresponding to the value
	* when the instruction is read. It corresponds to the pipeline
	* register of the instruction pointer.
	*/
	const u32 m_pc;
	#ifdef __P2AC_MEM__  
		u32 m_memOffset;
		u32 m_memReg;
		u32 m_memRegOffset;
	#endif
	public:

    e200z4_instruction(const u32 instructionPointer);
    virtual ~e200z4_instruction() {};

	/// this method is only used to know if an the instruction is a 
	// 'executeInstAction'. This is because there is no introspection
	// in C++  :-/
	virtual bool isInstAction() {return false;};

	/// \return the value of the instruction pointer in the pipeline.
	inline u32 const getInstructionPointer() {return m_pc;};	
	///mnemonic of the instruction
	virtual const char* const mnemo() {return "MNEMO_NOT_DEFINED";};
	virtual const char* const funct() {return "FUNCT_NOT_DEFINED";};
	
	/** Fonction that effectively execute the instruction. This methods
	 *  body is lead by the 'behavior' description in Harmless.
	 *  the arch pointer is not stored in the instruction to save space 
	 *  many instruction may be in cache.
	 */
	virtual void execute(arch *) = 0;

	/** @return the size of the instruction code in bytes.
        if the instruction size is not based on a multiple
        of 8 bits, the C type that can match is used.
        For instance: if the instruction size is 10 bits,
        the size will be 2 (16 bits) if one fetch is used,
        4 if 2 fetches are used, and so on.
	 */
	virtual unsigned char const size() = 0;

	/** @return the number of binary chunks of the instruction binary code. 
	    To get the real instruction size, simply mulptiplys this value by the 
	    instruction default code size ( bits for the ).
     */
	virtual unsigned char const chunks() = 0;

	//must be call by the class that gets the instance.
	inline void retain() {m_user++;};
	// The condition is deleted only if the number of users is nul.
	void release();

	//P2AC related methods.
	#ifdef __P2AC_MEM__
		inline void setP2ACMemOffset(u32 val)    {m_memOffset = val;};
		inline void setP2ACMemReg(u32 val)       {m_memReg = val;};
		inline void setP2ACMemRegOffset(u32 val) {m_memRegOffset = val;};
	#endif

	//***************************
	// Branch related methods.
	//***************************

	/** This fonction returns true if a jump is taken. Obviously it should
	 *  be called AFTER the execute method.
	 * For instruction that do not perform a jump it always return false.
	 */
	virtual bool jumpTaken() {return false;};

	/** static branch detection. 
	 * WARNING: This function update the context of arch!
	 *          The resulting value is the updated value of the Program Counter.
	 */
	virtual void detectBranch(arch *_arch) {};

	/// @return true if this instruction may update the program counter
	virtual bool isBranch() {return false;};

	/// @return true if branch is unconditionnal (always taken). 
	/// Not useful for non branching instructions
	virtual bool isBranchUnconditional() {return false;};

	/// @return true if branch target cannot be resolved at compile time
	/// Not useful for non branching instructions
	virtual bool isBranchStaticallyUnknown() {return false;};

	
	//***************************
	// Cycle Accurate Simulation related methods.
	//***************************

	/** \return the code of the instruction class. 
	*
	* This information is needed by the pipeline model
	* to get the right automata transition.
	*/
	virtual unsigned int const instClass() = 0;

	//DDC related function.
	virtual void lockDDCWriteRegs(u64 &) {};
	virtual void getDDCReadRegs(u64 &) {};
	

    /**Return static information about an instruction 
     * that could be used by p2ac. This is used through a Python
     * script, that cannot handle a pointer to powerpc_instruction
     * directly.
	 * WARNING: update the simulation context!
     */
    staticInfo *getStaticInfo(arch *_arch);
    virtual u32 getBI() { return 0; };
    virtual u32 getBO() { return 0; };
    virtual u32 getcrfD() { return 0; };
    virtual u32 getcrfS() { return 0; };

	//***************************
	// instruction Tags related methods
	//***************************

	virtual bool hasID_CR0() {return false;};
	virtual bool hasID_CR1() {return false;};
	virtual bool hasID_CR2() {return false;};
	virtual bool hasID_CR3() {return false;};
	virtual bool hasID_CR4() {return false;};
	virtual bool hasID_CR5() {return false;};
	virtual bool hasID_CR6() {return false;};
	virtual bool hasID_CR7() {return false;};
	virtual bool hasID_SP_Check() {return false;};
	virtual bool hasID_abs() {return false;};
	virtual bool hasID_add() {return false;};
	virtual bool hasID_adde() {return false;};
	virtual bool hasID_addi() {return false;};
	virtual bool hasID_addic() {return false;};
	virtual bool hasID_addis() {return false;};
	virtual bool hasID_addme() {return false;};
	virtual bool hasID_addze() {return false;};
	virtual bool hasID_aftercomplemented() {return false;};
	virtual bool hasID_algebraic() {return false;};
	virtual bool hasID_and() {return false;};
	virtual bool hasID_arith() {return false;};
	virtual bool hasID_b() {return false;};
	virtual bool hasID_bc() {return false;};
	virtual bool hasID_bd() {return false;};
	virtual bool hasID_bi() {return false;};
	virtual bool hasID_bo() {return false;};
	virtual bool hasID_br() {return false;};
	virtual bool hasID_byte() {return false;};
	virtual bool hasID_c() {return false;};
	virtual bool hasID_cmp() {return false;};
	virtual bool hasID_cntlzw() {return false;};
	virtual bool hasID_complemented() {return false;};
	virtual bool hasID_crand() {return false;};
	virtual bool hasID_crandc() {return false;};
	virtual bool hasID_crba() {return false;};
	virtual bool hasID_crbb() {return false;};
	virtual bool hasID_crbd() {return false;};
	virtual bool hasID_creqv() {return false;};
	virtual bool hasID_crfd() {return false;};
	virtual bool hasID_crfs() {return false;};
	virtual bool hasID_crm() {return false;};
	virtual bool hasID_crnand() {return false;};
	virtual bool hasID_crnor() {return false;};
	virtual bool hasID_cror() {return false;};
	virtual bool hasID_crorc() {return false;};
	virtual bool hasID_crxor() {return false;};
	virtual bool hasID_ctr() {return false;};
	virtual bool hasID_d() {return false;};
	virtual bool hasID_dcba() {return false;};
	virtual bool hasID_dcbf() {return false;};
	virtual bool hasID_dcbi() {return false;};
	virtual bool hasID_dcbst() {return false;};
	virtual bool hasID_dcbt() {return false;};
	virtual bool hasID_dcbtst() {return false;};
	virtual bool hasID_dcbz() {return false;};
	virtual bool hasID_divw() {return false;};
	virtual bool hasID_divwu() {return false;};
	virtual bool hasID_eciwx() {return false;};
	virtual bool hasID_ecowx() {return false;};
	virtual bool hasID_eieio() {return false;};
	virtual bool hasID_eq() {return false;};
	virtual bool hasID_extsb() {return false;};
	virtual bool hasID_extsh() {return false;};
	virtual bool hasID_f() {return false;};
	virtual bool hasID_fabs() {return false;};
	virtual bool hasID_fadd() {return false;};
	virtual bool hasID_fadds() {return false;};
	virtual bool hasID_fcmpo() {return false;};
	virtual bool hasID_fcmpu() {return false;};
	virtual bool hasID_fctiw() {return false;};
	virtual bool hasID_fctiwz() {return false;};
	virtual bool hasID_fd() {return false;};
	virtual bool hasID_fdiv() {return false;};
	virtual bool hasID_fdivs() {return false;};
	virtual bool hasID_fiw() {return false;};
	virtual bool hasID_fm() {return false;};
	virtual bool hasID_fmadd() {return false;};
	virtual bool hasID_fmadds() {return false;};
	virtual bool hasID_fmr() {return false;};
	virtual bool hasID_fmsub() {return false;};
	virtual bool hasID_fmsubs() {return false;};
	virtual bool hasID_fmul() {return false;};
	virtual bool hasID_fmuls() {return false;};
	virtual bool hasID_fnabs() {return false;};
	virtual bool hasID_fneg() {return false;};
	virtual bool hasID_fnmadd() {return false;};
	virtual bool hasID_fnmadds() {return false;};
	virtual bool hasID_fnmsub() {return false;};
	virtual bool hasID_fnmsubs() {return false;};
	virtual bool hasID_fra() {return false;};
	virtual bool hasID_frb() {return false;};
	virtual bool hasID_frc() {return false;};
	virtual bool hasID_frd() {return false;};
	virtual bool hasID_fres() {return false;};
	virtual bool hasID_frs() {return false;};
	virtual bool hasID_frsp() {return false;};
	virtual bool hasID_frsqrte() {return false;};
	virtual bool hasID_fs() {return false;};
	virtual bool hasID_fsel() {return false;};
	virtual bool hasID_fsqrt() {return false;};
	virtual bool hasID_fsqrts() {return false;};
	virtual bool hasID_fsub() {return false;};
	virtual bool hasID_fsubs() {return false;};
	virtual bool hasID_ge() {return false;};
	virtual bool hasID_gt() {return false;};
	virtual bool hasID_half() {return false;};
	virtual bool hasID_i() {return false;};
	virtual bool hasID_icbi() {return false;};
	virtual bool hasID_imm() {return false;};
	virtual bool hasID_immediate() {return false;};
	virtual bool hasID_isync() {return false;};
	virtual bool hasID_l() {return false;};
	virtual bool hasID_le() {return false;};
	virtual bool hasID_lge() {return false;};
	virtual bool hasID_lgt() {return false;};
	virtual bool hasID_li() {return false;};
	virtual bool hasID_lle() {return false;};
	virtual bool hasID_llt() {return false;};
	virtual bool hasID_load() {return false;};
	virtual bool hasID_logical() {return false;};
	virtual bool hasID_lt() {return false;};
	virtual bool hasID_mb() {return false;};
	virtual bool hasID_mcrf() {return false;};
	virtual bool hasID_mcrfs() {return false;};
	virtual bool hasID_mcrxr() {return false;};
	virtual bool hasID_me() {return false;};
	virtual bool hasID_mfcr() {return false;};
	virtual bool hasID_mffs() {return false;};
	virtual bool hasID_mfmsr() {return false;};
	virtual bool hasID_mfspr() {return false;};
	virtual bool hasID_mfsr() {return false;};
	virtual bool hasID_mfsrin() {return false;};
	virtual bool hasID_mftb() {return false;};
	virtual bool hasID_mtcrf() {return false;};
	virtual bool hasID_mtfsb0() {return false;};
	virtual bool hasID_mtfsb1() {return false;};
	virtual bool hasID_mtfsf() {return false;};
	virtual bool hasID_mtfsfi() {return false;};
	virtual bool hasID_mtmsr() {return false;};
	virtual bool hasID_mtspr() {return false;};
	virtual bool hasID_mtsr() {return false;};
	virtual bool hasID_mtsrin() {return false;};
	virtual bool hasID_mulhw() {return false;};
	virtual bool hasID_mulhwu() {return false;};
	virtual bool hasID_mulli() {return false;};
	virtual bool hasID_mullw() {return false;};
	virtual bool hasID_mw() {return false;};
	virtual bool hasID_nb() {return false;};
	virtual bool hasID_nd() {return false;};
	virtual bool hasID_ne() {return false;};
	virtual bool hasID_neg() {return false;};
	virtual bool hasID_noCond() {return false;};
	virtual bool hasID_noOv() {return false;};
	virtual bool hasID_noStatus() {return false;};
	virtual bool hasID_notSimple() {return false;};
	virtual bool hasID_notaftercomplemented() {return false;};
	virtual bool hasID_notcomplemented() {return false;};
	virtual bool hasID_notshifted() {return false;};
	virtual bool hasID_notu() {return false;};
	virtual bool hasID_nz() {return false;};
	virtual bool hasID_or() {return false;};
	virtual bool hasID_r() {return false;};
	virtual bool hasID_ra() {return false;};
	virtual bool hasID_rb() {return false;};
	virtual bool hasID_rd() {return false;};
	virtual bool hasID_reg() {return false;};
	virtual bool hasID_rel() {return false;};
	virtual bool hasID_revStatPred() {return false;};
	virtual bool hasID_rfi() {return false;};
	virtual bool hasID_rlw() {return false;};
	virtual bool hasID_rlwimi() {return false;};
	virtual bool hasID_rlwinm() {return false;};
	virtual bool hasID_rlwnm() {return false;};
	virtual bool hasID_rs() {return false;};
	virtual bool hasID_sc() {return false;};
	virtual bool hasID_sh() {return false;};
	virtual bool hasID_shifted() {return false;};
	virtual bool hasID_simm() {return false;};
	virtual bool hasID_slw() {return false;};
	virtual bool hasID_spr() {return false;};
	virtual bool hasID_sr() {return false;};
	virtual bool hasID_sraw() {return false;};
	virtual bool hasID_srw() {return false;};
	virtual bool hasID_statPred() {return false;};
	virtual bool hasID_store() {return false;};
	virtual bool hasID_subf() {return false;};
	virtual bool hasID_subfe() {return false;};
	virtual bool hasID_subfic() {return false;};
	virtual bool hasID_subfme() {return false;};
	virtual bool hasID_subfze() {return false;};
	virtual bool hasID_sw() {return false;};
	virtual bool hasID_sync() {return false;};
	virtual bool hasID_t() {return false;};
	virtual bool hasID_tbr() {return false;};
	virtual bool hasID_tlbia() {return false;};
	virtual bool hasID_tlbie() {return false;};
	virtual bool hasID_tlbsync() {return false;};
	virtual bool hasID_to_f() {return false;};
	virtual bool hasID_tolr() {return false;};
	virtual bool hasID_tw() {return false;};
	virtual bool hasID_u() {return false;};
	virtual bool hasID_uimm() {return false;};
	virtual bool hasID_updatelr() {return false;};
	virtual bool hasID_useOv() {return false;};
	virtual bool hasID_useStatus() {return false;};
	virtual bool hasID_withCarry() {return false;};
	virtual bool hasID_word() {return false;};
	virtual bool hasID_x() {return false;};
	virtual bool hasID_xor() {return false;};
	virtual bool hasID_z() {return false;};
	virtual bool hasID_zero() {return false;};
};

/** instruction object that represents a stall
 * this class is used when an instruction enters in the 
 * pipeline and is not taken into account after (instruction that
 * follows a branch instruction, misprediction of an instruction, ..)
 */
class e200z4_instructionStall : public e200z4_instruction
{
  const u32 m_code; //code of the first chunk of the instruction.
  public:
	///class code should be 0
	e200z4_instructionStall(const u32 instructionPointer=0, const u32 code = 0)
		: e200z4_instruction(instructionPointer), m_code(code) {};
	virtual ~e200z4_instructionStall() {};
	virtual void execute(arch *); // nop
	virtual const char* const mnemo() 
	{
		char *result = new char[64];
		int index = 0;	
		index += sprintf (result + index,"Stall");
		if(m_code)
			index += sprintf (result + index," (%08x)",m_code);
		return result;
	};
	virtual const char* const funct() 
	{
		char *result = new char[64];
		sprintf (result, "Stall()");
		return result;
	};
	virtual unsigned char const size() {return 4;};
	virtual unsigned char const chunks() {return 1;};
	virtual unsigned int const instClass() {return 0;};
};

#endif

