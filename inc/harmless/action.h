/**
 * generated by HARMLESS : 'Hardware ARchitecture Modeling Language
 *                          for Embedded Software Simulation'
 * model : e200z4
 *
 */

#ifndef __ACTION_H__
#define __ACTION_H__

#include "types.h"
#ifdef TRACK_VARIABLE
	#include "C166_Spy_info.h"
#endif
#ifndef NULL
	#define NULL 0
#endif

class storage;

class action
{
	action *m_next;
  public:
	action() : m_next(NULL) {};
	action(const action &) {m_next = NULL;};
	virtual ~action() {};  
	//single linked list.
	inline action *next() {return m_next;};
	//single linked list.
	inline void setNext(action *nextAct) {m_next = nextAct;};
	//virtual method to get information about action.
	virtual std::string toString() {return std::string();};
};

//unused at this time.
class spyInfo
{
};

/** This class is used to connect an action with a write access to a specified
 * address
 **/
class writeAction : public action
{
  public:
    writeAction() :action() {};  
	virtual ~writeAction() {};  
    virtual bool trigger(storage *,u8 data, spyInfo *s) = 0;
	virtual bool isSpyAction() {return false;};
};

/** This class is used to connect an action with a read access to a specified
 * address
 **/
class readAction : public action
{
  public:
    readAction() : action() {};  
    virtual ~readAction() {};  
    virtual bool trigger(storage *, spyInfo *s) = 0;
};

class arch;

class executeAction : public action
{
	public:
    executeAction() : action() {};  
    virtual ~executeAction() {};
    virtual bool trigger(arch *a) = 0;
};

#include "instructionBase.h"
/* new implementation of executeAction 
 * using the decorator design pattern (between instructions).
 * There is only one executeInstAction at one address,
 * but one can have more than one executeAction;
 *
 * only the 'execute' method of instruction is decorated here,
 * it calls all the executeActions that are associated to this
 * decorated instruction.
 */
class executeInstAction : public e200z4_instruction
{
	e200z4_instruction *m_inst;
	executeAction *m_action;
	//single list management when instruction is not in the cache.
	executeInstAction *m_next; 
	private:
	void triggerAction(arch *a);
	public:
	executeInstAction(const u32 address);
	void setInstruction(e200z4_instruction *inst) {m_inst=inst;};
	e200z4_instruction *instruction() {return m_inst;};

	//action handling.
	virtual bool isInstAction() {return true;};
	void addExecuteAction(executeAction* act);
	///@return true if action is found and correctly removed.
	bool removeExecuteAction(executeAction* act);

	//methods when instructions are not in the cache
	//We need to list them.
	executeInstAction *next() {return m_next;};
	void setNext(executeInstAction *n) {m_next = n;};
	
	//only this following function is decorated.
	virtual void execute(arch *a);
	virtual unsigned char const size()	{return m_inst->size();};
	virtual unsigned char const chunks(){return m_inst->chunks();};
	virtual const char* const mnemo()   {return m_inst->mnemo();};	
	virtual bool jumpTaken()			{return m_inst->jumpTaken();};
   
	virtual unsigned int const instClass() {return m_inst->instClass();};
		virtual bool hasID_SP_Check() {return m_inst->hasID_SP_Check();};
	virtual bool hasID_abs() {return m_inst->hasID_abs();};
	virtual bool hasID_add() {return m_inst->hasID_add();};
	virtual bool hasID_adde() {return m_inst->hasID_adde();};
	virtual bool hasID_addi() {return m_inst->hasID_addi();};
	virtual bool hasID_addic() {return m_inst->hasID_addic();};
	virtual bool hasID_addis() {return m_inst->hasID_addis();};
	virtual bool hasID_addme() {return m_inst->hasID_addme();};
	virtual bool hasID_addze() {return m_inst->hasID_addze();};
	virtual bool hasID_aftercomplemented() {return m_inst->hasID_aftercomplemented();};
	virtual bool hasID_algebraic() {return m_inst->hasID_algebraic();};
	virtual bool hasID_and() {return m_inst->hasID_and();};
	virtual bool hasID_arith() {return m_inst->hasID_arith();};
	virtual bool hasID_b() {return m_inst->hasID_b();};
	virtual bool hasID_bc() {return m_inst->hasID_bc();};
	virtual bool hasID_bd() {return m_inst->hasID_bd();};
	virtual bool hasID_bi() {return m_inst->hasID_bi();};
	virtual bool hasID_bo() {return m_inst->hasID_bo();};
	virtual bool hasID_br() {return m_inst->hasID_br();};
	virtual bool hasID_byte() {return m_inst->hasID_byte();};
	virtual bool hasID_c() {return m_inst->hasID_c();};
	virtual bool hasID_cmp() {return m_inst->hasID_cmp();};
	virtual bool hasID_cntlzw() {return m_inst->hasID_cntlzw();};
	virtual bool hasID_complemented() {return m_inst->hasID_complemented();};
	virtual bool hasID_crand() {return m_inst->hasID_crand();};
	virtual bool hasID_crandc() {return m_inst->hasID_crandc();};
	virtual bool hasID_crba() {return m_inst->hasID_crba();};
	virtual bool hasID_crbb() {return m_inst->hasID_crbb();};
	virtual bool hasID_crbd() {return m_inst->hasID_crbd();};
	virtual bool hasID_creqv() {return m_inst->hasID_creqv();};
	virtual bool hasID_crfd() {return m_inst->hasID_crfd();};
	virtual bool hasID_crfs() {return m_inst->hasID_crfs();};
	virtual bool hasID_crm() {return m_inst->hasID_crm();};
	virtual bool hasID_crnand() {return m_inst->hasID_crnand();};
	virtual bool hasID_crnor() {return m_inst->hasID_crnor();};
	virtual bool hasID_cror() {return m_inst->hasID_cror();};
	virtual bool hasID_crorc() {return m_inst->hasID_crorc();};
	virtual bool hasID_crxor() {return m_inst->hasID_crxor();};
	virtual bool hasID_ctr() {return m_inst->hasID_ctr();};
	virtual bool hasID_d() {return m_inst->hasID_d();};
	virtual bool hasID_dcba() {return m_inst->hasID_dcba();};
	virtual bool hasID_dcbf() {return m_inst->hasID_dcbf();};
	virtual bool hasID_dcbi() {return m_inst->hasID_dcbi();};
	virtual bool hasID_dcbst() {return m_inst->hasID_dcbst();};
	virtual bool hasID_dcbt() {return m_inst->hasID_dcbt();};
	virtual bool hasID_dcbtst() {return m_inst->hasID_dcbtst();};
	virtual bool hasID_dcbz() {return m_inst->hasID_dcbz();};
	virtual bool hasID_divw() {return m_inst->hasID_divw();};
	virtual bool hasID_divwu() {return m_inst->hasID_divwu();};
	virtual bool hasID_eciwx() {return m_inst->hasID_eciwx();};
	virtual bool hasID_ecowx() {return m_inst->hasID_ecowx();};
	virtual bool hasID_eieio() {return m_inst->hasID_eieio();};
	virtual bool hasID_eq() {return m_inst->hasID_eq();};
	virtual bool hasID_extsb() {return m_inst->hasID_extsb();};
	virtual bool hasID_extsh() {return m_inst->hasID_extsh();};
	virtual bool hasID_f() {return m_inst->hasID_f();};
	virtual bool hasID_fabs() {return m_inst->hasID_fabs();};
	virtual bool hasID_fadd() {return m_inst->hasID_fadd();};
	virtual bool hasID_fadds() {return m_inst->hasID_fadds();};
	virtual bool hasID_fcmpo() {return m_inst->hasID_fcmpo();};
	virtual bool hasID_fcmpu() {return m_inst->hasID_fcmpu();};
	virtual bool hasID_fctiw() {return m_inst->hasID_fctiw();};
	virtual bool hasID_fctiwz() {return m_inst->hasID_fctiwz();};
	virtual bool hasID_fd() {return m_inst->hasID_fd();};
	virtual bool hasID_fdiv() {return m_inst->hasID_fdiv();};
	virtual bool hasID_fdivs() {return m_inst->hasID_fdivs();};
	virtual bool hasID_fiw() {return m_inst->hasID_fiw();};
	virtual bool hasID_fm() {return m_inst->hasID_fm();};
	virtual bool hasID_fmadd() {return m_inst->hasID_fmadd();};
	virtual bool hasID_fmadds() {return m_inst->hasID_fmadds();};
	virtual bool hasID_fmr() {return m_inst->hasID_fmr();};
	virtual bool hasID_fmsub() {return m_inst->hasID_fmsub();};
	virtual bool hasID_fmsubs() {return m_inst->hasID_fmsubs();};
	virtual bool hasID_fmul() {return m_inst->hasID_fmul();};
	virtual bool hasID_fmuls() {return m_inst->hasID_fmuls();};
	virtual bool hasID_fnabs() {return m_inst->hasID_fnabs();};
	virtual bool hasID_fneg() {return m_inst->hasID_fneg();};
	virtual bool hasID_fnmadd() {return m_inst->hasID_fnmadd();};
	virtual bool hasID_fnmadds() {return m_inst->hasID_fnmadds();};
	virtual bool hasID_fnmsub() {return m_inst->hasID_fnmsub();};
	virtual bool hasID_fnmsubs() {return m_inst->hasID_fnmsubs();};
	virtual bool hasID_fra() {return m_inst->hasID_fra();};
	virtual bool hasID_frb() {return m_inst->hasID_frb();};
	virtual bool hasID_frc() {return m_inst->hasID_frc();};
	virtual bool hasID_frd() {return m_inst->hasID_frd();};
	virtual bool hasID_fres() {return m_inst->hasID_fres();};
	virtual bool hasID_frs() {return m_inst->hasID_frs();};
	virtual bool hasID_frsp() {return m_inst->hasID_frsp();};
	virtual bool hasID_frsqrte() {return m_inst->hasID_frsqrte();};
	virtual bool hasID_fs() {return m_inst->hasID_fs();};
	virtual bool hasID_fsel() {return m_inst->hasID_fsel();};
	virtual bool hasID_fsqrt() {return m_inst->hasID_fsqrt();};
	virtual bool hasID_fsqrts() {return m_inst->hasID_fsqrts();};
	virtual bool hasID_fsub() {return m_inst->hasID_fsub();};
	virtual bool hasID_fsubs() {return m_inst->hasID_fsubs();};
	virtual bool hasID_ge() {return m_inst->hasID_ge();};
	virtual bool hasID_gt() {return m_inst->hasID_gt();};
	virtual bool hasID_half() {return m_inst->hasID_half();};
	virtual bool hasID_i() {return m_inst->hasID_i();};
	virtual bool hasID_icbi() {return m_inst->hasID_icbi();};
	virtual bool hasID_imm() {return m_inst->hasID_imm();};
	virtual bool hasID_immediate() {return m_inst->hasID_immediate();};
	virtual bool hasID_isync() {return m_inst->hasID_isync();};
	virtual bool hasID_l() {return m_inst->hasID_l();};
	virtual bool hasID_le() {return m_inst->hasID_le();};
	virtual bool hasID_lge() {return m_inst->hasID_lge();};
	virtual bool hasID_lgt() {return m_inst->hasID_lgt();};
	virtual bool hasID_li() {return m_inst->hasID_li();};
	virtual bool hasID_lle() {return m_inst->hasID_lle();};
	virtual bool hasID_llt() {return m_inst->hasID_llt();};
	virtual bool hasID_load() {return m_inst->hasID_load();};
	virtual bool hasID_logical() {return m_inst->hasID_logical();};
	virtual bool hasID_lt() {return m_inst->hasID_lt();};
	virtual bool hasID_mb() {return m_inst->hasID_mb();};
	virtual bool hasID_mcrf() {return m_inst->hasID_mcrf();};
	virtual bool hasID_mcrfs() {return m_inst->hasID_mcrfs();};
	virtual bool hasID_mcrxr() {return m_inst->hasID_mcrxr();};
	virtual bool hasID_me() {return m_inst->hasID_me();};
	virtual bool hasID_mfcr() {return m_inst->hasID_mfcr();};
	virtual bool hasID_mffs() {return m_inst->hasID_mffs();};
	virtual bool hasID_mfmsr() {return m_inst->hasID_mfmsr();};
	virtual bool hasID_mfspr() {return m_inst->hasID_mfspr();};
	virtual bool hasID_mfsr() {return m_inst->hasID_mfsr();};
	virtual bool hasID_mfsrin() {return m_inst->hasID_mfsrin();};
	virtual bool hasID_mftb() {return m_inst->hasID_mftb();};
	virtual bool hasID_mtcrf() {return m_inst->hasID_mtcrf();};
	virtual bool hasID_mtfsb0() {return m_inst->hasID_mtfsb0();};
	virtual bool hasID_mtfsb1() {return m_inst->hasID_mtfsb1();};
	virtual bool hasID_mtfsf() {return m_inst->hasID_mtfsf();};
	virtual bool hasID_mtfsfi() {return m_inst->hasID_mtfsfi();};
	virtual bool hasID_mtmsr() {return m_inst->hasID_mtmsr();};
	virtual bool hasID_mtspr() {return m_inst->hasID_mtspr();};
	virtual bool hasID_mtsr() {return m_inst->hasID_mtsr();};
	virtual bool hasID_mtsrin() {return m_inst->hasID_mtsrin();};
	virtual bool hasID_mulhw() {return m_inst->hasID_mulhw();};
	virtual bool hasID_mulhwu() {return m_inst->hasID_mulhwu();};
	virtual bool hasID_mulli() {return m_inst->hasID_mulli();};
	virtual bool hasID_mullw() {return m_inst->hasID_mullw();};
	virtual bool hasID_mw() {return m_inst->hasID_mw();};
	virtual bool hasID_nb() {return m_inst->hasID_nb();};
	virtual bool hasID_nd() {return m_inst->hasID_nd();};
	virtual bool hasID_ne() {return m_inst->hasID_ne();};
	virtual bool hasID_neg() {return m_inst->hasID_neg();};
	virtual bool hasID_noCond() {return m_inst->hasID_noCond();};
	virtual bool hasID_noOv() {return m_inst->hasID_noOv();};
	virtual bool hasID_noStatus() {return m_inst->hasID_noStatus();};
	virtual bool hasID_notSimple() {return m_inst->hasID_notSimple();};
	virtual bool hasID_notaftercomplemented() {return m_inst->hasID_notaftercomplemented();};
	virtual bool hasID_notcomplemented() {return m_inst->hasID_notcomplemented();};
	virtual bool hasID_notshifted() {return m_inst->hasID_notshifted();};
	virtual bool hasID_notu() {return m_inst->hasID_notu();};
	virtual bool hasID_nz() {return m_inst->hasID_nz();};
	virtual bool hasID_or() {return m_inst->hasID_or();};
	virtual bool hasID_r() {return m_inst->hasID_r();};
	virtual bool hasID_ra() {return m_inst->hasID_ra();};
	virtual bool hasID_rb() {return m_inst->hasID_rb();};
	virtual bool hasID_rd() {return m_inst->hasID_rd();};
	virtual bool hasID_reg() {return m_inst->hasID_reg();};
	virtual bool hasID_rel() {return m_inst->hasID_rel();};
	virtual bool hasID_revStatPred() {return m_inst->hasID_revStatPred();};
	virtual bool hasID_rfi() {return m_inst->hasID_rfi();};
	virtual bool hasID_rlw() {return m_inst->hasID_rlw();};
	virtual bool hasID_rlwimi() {return m_inst->hasID_rlwimi();};
	virtual bool hasID_rlwinm() {return m_inst->hasID_rlwinm();};
	virtual bool hasID_rlwnm() {return m_inst->hasID_rlwnm();};
	virtual bool hasID_rs() {return m_inst->hasID_rs();};
	virtual bool hasID_sc() {return m_inst->hasID_sc();};
	virtual bool hasID_sh() {return m_inst->hasID_sh();};
	virtual bool hasID_shifted() {return m_inst->hasID_shifted();};
	virtual bool hasID_simm() {return m_inst->hasID_simm();};
	virtual bool hasID_slw() {return m_inst->hasID_slw();};
	virtual bool hasID_spr() {return m_inst->hasID_spr();};
	virtual bool hasID_sr() {return m_inst->hasID_sr();};
	virtual bool hasID_sraw() {return m_inst->hasID_sraw();};
	virtual bool hasID_srw() {return m_inst->hasID_srw();};
	virtual bool hasID_statPred() {return m_inst->hasID_statPred();};
	virtual bool hasID_store() {return m_inst->hasID_store();};
	virtual bool hasID_subf() {return m_inst->hasID_subf();};
	virtual bool hasID_subfe() {return m_inst->hasID_subfe();};
	virtual bool hasID_subfic() {return m_inst->hasID_subfic();};
	virtual bool hasID_subfme() {return m_inst->hasID_subfme();};
	virtual bool hasID_subfze() {return m_inst->hasID_subfze();};
	virtual bool hasID_sw() {return m_inst->hasID_sw();};
	virtual bool hasID_sync() {return m_inst->hasID_sync();};
	virtual bool hasID_t() {return m_inst->hasID_t();};
	virtual bool hasID_tbr() {return m_inst->hasID_tbr();};
	virtual bool hasID_tlbia() {return m_inst->hasID_tlbia();};
	virtual bool hasID_tlbie() {return m_inst->hasID_tlbie();};
	virtual bool hasID_tlbsync() {return m_inst->hasID_tlbsync();};
	virtual bool hasID_to_f() {return m_inst->hasID_to_f();};
	virtual bool hasID_tolr() {return m_inst->hasID_tolr();};
	virtual bool hasID_tw() {return m_inst->hasID_tw();};
	virtual bool hasID_u() {return m_inst->hasID_u();};
	virtual bool hasID_uimm() {return m_inst->hasID_uimm();};
	virtual bool hasID_updatelr() {return m_inst->hasID_updatelr();};
	virtual bool hasID_useOv() {return m_inst->hasID_useOv();};
	virtual bool hasID_useStatus() {return m_inst->hasID_useStatus();};
	virtual bool hasID_withCarry() {return m_inst->hasID_withCarry();};
	virtual bool hasID_word() {return m_inst->hasID_word();};
	virtual bool hasID_x() {return m_inst->hasID_x();};
	virtual bool hasID_xor() {return m_inst->hasID_xor();};
	virtual bool hasID_z() {return m_inst->hasID_z();};
	virtual bool hasID_zero() {return m_inst->hasID_zero();};

};

// This class is a container that record execute actions for actions that are not yet in cache 
// (or that are ejected from cache)
// If action was previously in cache, the m_inst refers to an existing instruction.
// If action refers to a location not yet found, the instruction is not yet decoded and the instruction
// pointer is NULL.
//
// executeInstAction are sorted according to the address.
class executeInstActionList
{
	executeInstAction	*m_root; //first item.
	int m_size;
	public:
	executeInstActionList() : m_root(NULL), m_size(0) {};
	//insert (no doubles...)
	void insert(executeInstAction *eia);
	//void remove(executeInstAction *eia);
	executeInstAction *getAndRemoveAt(const u32 address);
	//@returns the executeInstAction at address, or NULL if not found.
	executeInstAction *get(const u32 address);
	///remove an action (but DO NOT remove executeInstAction, even if it contains no more action).
	///@return true if found.
	bool removeExecAction(const u32 address, executeAction *ea);
	//test purpose.
	void dump();
	int const size() {return m_size;};
};
#endif

