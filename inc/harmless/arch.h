/**
 * generated by HARMLESS : 'Hardware ARchitecture Modeling Language
 *                          for Embedded Software Simulation'
 * model : e200z4
 *
 */

#ifndef __e200z4_ARCH_H__
#define __e200z4_ARCH_H__

#include "types.h"
#include "storage.h"
#include "macro.h"
#include "instructionBase.h"
#include "fifo.h"
#include "componentTypeDef.h" //typedefs in components.
#include <vector> 
#include <string>
#include <string.h> //required by Linux for memcpy...

#include <map> //used for breakpoints.
class breakpointAction;
class executeAction;
class e200z4_instDecoder;
class e200z4_instruction;
class codeReader;

// SP Check
#ifdef GADL_SP_CHECK_ALLOWED
	class stackSpyController;
#endif
#ifdef GADL_WITH_PIPELINE_TRACE
	class pipelineTraceDebug;
#endif

//timing parts.
#include "timingSignal.h"
class timingBase;
#include "timing_ICacheE200Z4.h"
#include "timing_ICacheE200Z4LineBuffer.h"
#include "timing_mem.h"
//pipeline models declaration
class pipelineExample;
//DDC register mask definition
#define DDC_REGISTER_MASK_CR (1<<0)
#define DDC_REGISTER_MASK_CTR (1<<1)
#define DDC_REGISTER_MASK_L1CSR0 (1<<2)
#define DDC_REGISTER_MASK_L1CSR1 (1<<3)
#define DDC_REGISTER_MASK_L1FINV1 (1<<4)
#define DDC_REGISTER_MASK_LR (1<<5)
#define DDC_REGISTER_MASK_MSR (1<<6)
#define DDC_REGISTER_MASK_PC (1<<7)
#define DDC_REGISTER_MASK_SERIAL0 (1<<8)
#define DDC_REGISTER_MASK_SRR0 (1<<9)
#define DDC_REGISTER_MASK_SRR1 (1<<10)
#define DDC_REGISTER_MASK_XER (1<<11)
#define DDC_REGISTER_MASK_hit (1<<12)
#define DDC_REGISTER_MASK_miss (1<<13)

//cyclic part related structure (every)
struct cyclicPartNode {
	int id; //id of the cyclic part to run
	u64 wakeUpDate;
	cyclicPartNode *next;
	cyclicPartNode(int _id, u64 _wakeUpDate, cyclicPartNode *_next) : id(_id), wakeUpDate(_wakeUpDate), next(_next) {}
};

//cyclic part related typedefs ('every' construction)
typedef void (arch::*__cyclicFunc_e200z4)();
typedef int  (arch::*__cyclicNextFunc_e200z4)();

class arch
{
	public:
		/** ISS (Instruction Set Simulation) mode or
		 *  CAS (Cycle Accurate Simulation) mode.
		 */ 
		enum executionMode {ISS, CAS};
		
		///constructor
		arch();

		/** 
		 * Stop the simulation (breakpoint, ..)
		 * \param : reason: see m_stopSimu var
		 */
		void stopSimu(int);

	private:
		/** values are the same than in gdb-server.
		 *  0  : Run
		 *  18 : Stopped by user
		 *  5  : Breakpoint found 
		 */
		int m_stopSimu; 

		/** used for breakpoints (interactive simulation). Breakpoints use actions.
		 * When a breakpoint is defined at an address, an action is inserted. 
		 * This variable store the address of the last breakpoint found.
		 */
		u32  m_lastBreakpointAddr;
		
		/** map that stores a pointer for each action. This is useful to
		*  remove all breakpoints. Key is the address (in program chunk).
		*/  
		std::map<u32, breakpointAction *> m_breakpointActionMap; 
		
		/** object that read a program file from a Intel Hex, 
		 *  Motorola SRecord or Elf format and store code in memory.
		 *  It can also handle symbols.
		 */
		codeReader *m_reader;

		u32 m_PC;
	
		///memory chunks declaration.
		rwStorage *FSRU_FPRChunk;
		rwStorage *SRU_GPRChunk;
		rwStorage *mem_ramChunk;

		///component local var declaration
		/* component ICacheE200Z4, local var cacheArray*/
		gadl_type_ICacheE200Z4_cacheWay gadl_ICacheE200Z4_cacheArray[2]; //ICacheE200Z4_cacheWay
		/* component ICacheE200Z4LineBuffer, local var basePC*/
		u32 gadl_ICacheE200Z4LineBuffer_basePC; //u32
		/* component ICacheE200Z4LineBuffer, local var currentId*/
		u8 gadl_ICacheE200Z4LineBuffer_currentId; //u2
		/* component ICacheE200Z4LineBuffer, local var currentLineId*/
		u32 gadl_ICacheE200Z4LineBuffer_currentLineId; //u27
		/* component ICacheE200Z4LineBuffer, local var dblWordInBuffer*/
		u8 gadl_ICacheE200Z4LineBuffer_dblWordInBuffer; //u4
		/* component ICacheE200Z4LineBuffer, local var filling*/
		u8 gadl_ICacheE200Z4LineBuffer_filling; //u1

		///registers (global use) var declaration
		u32 __L1CSR0;
		u32 __L1CSR1;
		u32 __L1FINV1;
		u32 __hit;
		u32 __miss;
		u32 __CR;
		u32 __CTR;
		u32 __LR;
		u32 __MSR;
		u32 __SRR0;
		u32 __SRR1;
		u32 __XER;

		///store the number of cycles executed since the beginning of the simulation.
		///value is not updated in ISS mode.
		u64 m_nbCycles;
		///store the number of instruction executed since the beginning of the simulation.
		///value is updated both in CAS and ISS modes.
		u64 m_nbInst;
		
		///pointer to the decoder... that decodes instructions :-)
		e200z4_instDecoder *m_decoder;
	
		///ISS (Instruction Set Simulation) mode or
		///CAS (Cycle Accurate Simulation) mode.
		executionMode m_executionMode;
	
		/// Exec instruction (ISS mode)
		/// \param nb number of instruction to execute.
		int emuInst(const unsigned int nb);


		/* Stack Spy */
		#ifdef	GADL_SP_CHECK_ALLOWED
		stackSpyController *m_stackController;
		#endif

		//internal function related to file I/O stubs.
		bool addIOStub(executeAction *act, std::string funcName);

		//part related to cyclic behaviors ('every')
		u64 m_nextCyclicWakeUpDate; //date of the next cyclic part.
		cyclicPartNode *m_cyclicRootNode; //single linked list ordered by wakeUpDate
		void manageCyclicPart();
		void insertCyclicNode(cyclicPartNode *node);

		static const __cyclicFunc_e200z4 cyclicFuncFor[1];
		static const __cyclicNextFunc_e200z4 cyclicNextDate[1];

		//pipeline models instance

		pipelineExample *m_pipelinepipelineExample;
		e200z4_instruction *m_nextInstruction_pipelineExample;
		e200z4_instruction *m_instructionsInPipeline_pipelineExample[8];
		u64 m_instInPipe_pipelineExample;
		//*******  Data Cache (TODO:Hand coded).*****
		u64 m_memStage; //TODO: will not work if more than 1 pipeline!
		fifo<u32> *m_fifoMemAccessTab[8];
   

		#ifdef GADL_WITH_PIPELINE_TRACE
		pipelineTraceDebug *m_pipelineTrace;
		#endif
   
		//*******  DDC related part.
		u64 m_DDCInstRequireStage; //used to get instruction in stage 'F'
		u64 m_DDCInstLockStage;    //used to get instruction in stage 'D'
		fifo<u64> *m_fifoDDC;      //fifo to store registers locked in the DDC.
		//registers that are used in the pipeline (locked).
		u64 m_DDCregsInUse;
		//registers that are required to get into the exec pipeline stage (not to get it from inst each time)
		u64 m_DDCCurrentReadRegs; 
		//return 0 if there is no DDC related lock.
		inline bool testDDCLock() {return ((m_DDCregsInUse & m_DDCCurrentReadRegs) != 0);}
		//main function for DDC management. Used each cycle.
		void DDCManagement(const unsigned int notification);
		void debugDDCRegField(); //debug.
		//DDC register file access (R/W);
		u64 m_DDCreadRegFileFSRU_FPRAccess;
		u64 m_DDCwriteRegFileFSRU_FPRAccess;
		u64 m_DDCreadRegFileSRU_GPRAccess;
		u64 m_DDCwriteRegFileSRU_GPRAccess;
		u64 m_DDCreadRegAccess;
		u64 m_DDCwriteRegAccess;

		//timing related automata.
		timingICacheE200Z4 *m_timingICache;
		timingICacheE200Z4LineBuffer *m_timingICacheLineBuffer;
		timingmem *m_timingMemDev;
		timingBase *m_pendingSignalEmitTab[NB_SIGNAL_EMIT];
		timingBase *m_pendingSignalWaitTab[NB_SIGNAL_WAIT];
		timingBase *m_timingListRoot;
		u64 m_timingNextWakeUp;
		//this function is called when this is the date to wake up an automata
		void manageTiming();
public:

		/*******************************************************************
		 *  status
		 *******************************************************************/
		///debugging info
		void decoderStats();
		/** get number of cycles executed since the beginning of the simulation.
		 * This value is not modified in ISS mode (functional)
		 */
		inline unsigned long long const getNBCycles() const {return m_nbCycles;};
		/// get number of instruction executed since the beginning of the simulation.
		inline unsigned long long const getNBInstructions() const {return m_nbInst;};
		/** generic function to access the program counter */
		inline u32 programCounter() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_PC; 
			return m_PC;};
		
		/** specific functions to access the program counter (use processor real name) */
		inline void setPC(const u32 val) {setProgramCounter(val);};
		/** specific functions to access the program counter (use processor real name) */
		inline u32 PC() {return programCounter();};
		/** returns the function symbol for a given address (typically program counter). (for ELF files). */
		std::string whichFunctionAtAddress(const u32 v_addr);

		/** Disassemble binary code.
		* \param ipStart Instruction Pointer from which the disassemble is started
		* \param nbBytes Number of bytes to disassemble: Value may be exceeded: 
		* i.e. if set to 1 to decode a 32 bits instruction, 1 instruction will be decoded.
		* \param verbose return also the address where the code is decoded and the opcode of the instruction.
		*/ 
		std::string disassemble(const unsigned int pcStart, const int nbBytes, bool verbose = false);
		/** print the value of all variables defined as 'register' in the description
          * It does not take into account memory chunk defined has 'register'
          */
		void printRegs();
		/* @return the physical address. 
		 * If no physical address is matching, the virtual address is returned
		 * and found is set to false.
	 	 */
		#ifdef SWIG /*Swig wrapper (for Python interface)*/
			u32 getPhysicalAddress(const u32 v_addr, bool &OUTPUT);
		#else
			u32 getPhysicalAddress(const u32 v_addr, bool &found);
		#endif
		/* this function search for the virtual address and size of the symbol name (first parameter).
		 * @return true if a symbol have been found, and updates v_addr and size
		 * @return false if no symbol is matching. v_addr and size are not updated.
		 */
		#ifdef SWIG /*Swig wrapper (for Python interface)*/
			bool getSymbolObjectAddress(const char *symbolName, u32 &OUTPUT, u32 &OUTPUT);
		#else
			bool getSymbolObjectAddress(const char *symbolName, u32 &v_addr, u32 &size);
		#endif
		/* this function search for the virtual address of the function (first parameter).
		 * @return true if a function have been found, and updates v_addr 
		 * @return false if no function is matching. v_addr and size are not updated.
		 */
		#ifdef SWIG /*Swig wrapper (for Python interface)*/
			bool getFunctionName(const char *symbolName, u32 &OUTPUT);
		#else
			bool getFunctionName(const char *symbolName, u32 &v_addr);
		#endif
		
		/** print all object symbols (for ELF files)*/
		void dumpObjects();
		/** print all function symbols  (for ELF files)*/
		void dumpFunctions();

		/** Use this function to record the pipeline trace.. Simulation is quite slower. */
		void usePipelineTrace();
		/** Output pipeline trace to a .ptr file 
		 *  @see pipelineTraceDebug.h
		 */
		void outputPipelineTrace(const std::string filename);

		/** return the instruction object at address. Note that p_addr is modified and 
		 * updated to point to the next instruction address.
		 **/
		#ifdef SWIG /*Swig wrapper (for Python interface)*/		
		        std::string *string getInstructionStaticInfo(unsigned int &INOUT);
		#else
			staticInfo *getInstructionStaticInfo(unsigned int &p_addr);
		#endif

		/*******************************************************************
		 *  Breakpoints
		 *******************************************************************/
		/** remove all breakpoints (interactive simulation) */
		void removeAllBreakpoints();
		/** remove a breakpoint for interactive simulation */
		void removeBreakpoint(const unsigned int addr);
		/** remove a breakpoint for interactive simulation */
		void removeBreakpoint(const char *symbolName);
		/** add a breakpoint for interactive simulation
		 *  An error is generated if there is already a breakpoint at this addr.
		 */
		void addBreakpoint(const unsigned int addr);
		/** add a breakpoint for interactive simulation */
		void addBreakpoint(const char *symbolName);

		/*******************************************************************
		 *  Configuration
		 *******************************************************************/
		/** Set the simulator mode:
		 *  - ISS: Instruction Set Simulator
		 *  - CAS: Cycle Accurate Simulator
		 */
		void setExecutionMode(const executionMode mode);
		/** install io stubs to support open, close, read and write functions.
		 * These functions are mapped to the host, using actions.
		 * It returns true if there was no error.
		 * This function requires extra files (ioStubs.cpp and .h) that are nor yet
		 * generated by the Harmless compiler (have a look in the example folder)
		 * Moreover, the USE_IO_STUBS should be set to 1 in the Makefile and it requires
		 * actions.
		 */
		bool useIOStubs();
		
		/*******************************************************************
		 *  Execution
		 *******************************************************************/
		/// restore the cpu in the init state (called in constructor)
		void reset();
		/** Read a code file with 
		 *  - Intel Hex format
		 *  - Motorola SRecord format
		 *  - ELF format (if linked with the appropriate library).
		 *  (no CRC verification)
		 *  \return true if the code file is correctly read.
		 */  
		bool readCodeFile(const char *filename, const bool verbose = false);
		/** simulate instructions of the processor.
		* The simulator may be in CAS or ISS mode
		* \param nb number of instruction to execute.
		* \return what causes the execution to stop : 18 on user stop, 5 on breakpoint or 0 on success
		*/ 
		int execInst(const unsigned int nb);

		/** run simulation until PC=addr. It does not take into account segmentation!!
		 *  \param addr the address compared to the program counter
		 *  \param max the max number of instruction to execute.
		 */
		void runUntil(const unsigned int addr, const unsigned int max);

		/** generic function to access the program counter */
		inline void setProgramCounter(const u32 val) { 
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_PC; 
			m_PC = val;};

		/** return the object that reads the binary application code */
		codeReader *getCodeReader() {return m_reader;};

		/*******************************************************************
		 * Stack/Task observation.
		 *******************************************************************/
		/* Stack SPY */
		#ifdef	GADL_SP_CHECK_ALLOWED
		inline stackSpyController* getStackSpyController(){return m_stackController;};
		#endif
		/*******************************************************************
		 *  Internals :public functions that are accessed by other
		 *             simulators objects: memory, actions, ...
		 *             THEY SHOULD NOT BE CALLED DURING SIMULATION.
		 *******************************************************************/
		/**
		 * This is an internal function that SHOULD ONLY be called 
		 * from harmless instructions.
		 */
		inline void interruptHandling(u32 trapId) {  };
		/**
		 * This is an internal function that SHOULD ONLY be called 
		 * from harmless instructions.
		 */
		inline void addCycle(unsigned int val) {m_nbCycles += val;};

		void removeExecuteActionAtAddress(const u32 addr, executeAction *ea);
		void addExecuteActionAtAddress(const u32 addr, executeAction *ea);
		/** this method should ONLY be called by an action that is 
		 *  associated to a breakpoint (interactive simulation)
		 */
		inline void actionFoundABreakpoint(const u32 addr) {stopSimu(5); m_lastBreakpointAddr = addr;};
		/** return the memory chunk that contains 'address'. This is used for program loading. */
		storage * getProgramChunk(const unsigned int address);
		/** this method is called by instructions that have a 'nop' statement:
         *  'add xx nop'
		 * This method will be called to decode (and NOT execute) the next xx (val)
		 * instructions. Instructions should be decoded if not all the instructions
		 * have the same size: TODO: optimize for the other case.
		 */
		void doNotExececuteNextInstructions(const u32 val);

		/** pipeline model related function */
		unsigned int getNextInstructionCodeIn_pipelineExample();
		/** pipeline model related function */
		unsigned int getExternalResourcesState_pipelineExample();

		bool execOneCycle(); //TODO: remove.

		/** internal function that translates an address from the linker
          * to a real address in the global memory address.
          */
		u32 linkerAddressTranslation(u32 addr);
		/** This is the default fetch function used in the decode phase. Another Fetch function can be defined
         *  and should be declared in the default section of the .hadl processor description
         *  This function just get a word (size is defined in instruction size in the default section) in 
         *  memory, update the pc in parameter and returns the value reads in memory.
		 * If no user fetch function is defined, this one is used each time a program word is read. Note that
		 * due to the instruction cache, the function may not be called!
		 * If a user fetch function is defined, the default fetch function is used for the disassembler.
         */
		#ifdef SWIG /*Swig wrapper (for Python interface)*/
			inline u32 defaultFetch(u32 &INOUT)
		#else
			inline u32 defaultFetch(u32 &pc)
		#endif
		{
			unsigned int realAddress = getFetchAddress(pc);
			roStorage *codeMem = (roStorage *)getProgramChunk(realAddress);
			const u32 instCode = codeMem->read32AtAddress(realAddress);
			pc += 4;
			return instCode;
		}

		inline u32 getFetchAddress(u32 address)
		{
			 return address;
		}

		//this function should be called ONLY by the execute method of an instruction.
		inline void initDDCRegAccess() {
			
			m_DDCreadRegFileFSRU_FPRAccess  = 0;
			m_DDCwriteRegFileFSRU_FPRAccess = 0;
			
			m_DDCreadRegFileSRU_GPRAccess  = 0;
			m_DDCwriteRegFileSRU_GPRAccess = 0;
			
			m_DDCreadRegAccess = 0;
			m_DDCwriteRegAccess = 0;
		};

		//this function should be called ONLY by the execute method of an instruction.
		inline void getDDCRegFileFSRU_FPRAccessMask(u64 &r, u64 &w) {
			r=m_DDCreadRegFileFSRU_FPRAccess;
			w=m_DDCwriteRegFileFSRU_FPRAccess;
		};

		//this function should be called ONLY by the execute method of an instruction.
		inline void getDDCRegFileSRU_GPRAccessMask(u64 &r, u64 &w) {
			r=m_DDCreadRegFileSRU_GPRAccess;
			w=m_DDCwriteRegFileSRU_GPRAccess;
		};

		//this function should be called ONLY by the execute method of an instruction.
		inline void getDDCRegAccessMask(u64 &r, u64 &w) {
			r=m_DDCreadRegAccess;
			w=m_DDCwriteRegAccess;
		};

		//timing simulation steps accessors
		void timingWaitForCycles(timingBase *,const u64 nbCycles);
		bool timingSynchroEmit(timingBase *,unsigned int sigName, const bool broadcast);
		bool timingSynchroWait(timingBase *,unsigned int sigName);

		/*******************************************************************
		 * Automatically generated functions.
		 *******************************************************************/
		
		/** components and memory implementation*/
		/*********** component FSRU ************/
		inline u16 FSRU_FPR_read16(const u32 address) {
			//DDC related function (read)
			m_DDCreadRegFileFSRU_FPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.178
			u32 addressWithStride = address << 3;
			// 'ppc_e200z4.hadl', l.178
			roStorage *ro = (roStorage *)FSRU_FPRChunk;
			// 'ppc_e200z4.hadl', l.178
			return ro->read16AtAddress(addressWithStride);
		}
		inline u32 FSRU_FPR_read32(const u32 address) {
			//DDC related function (read)
			m_DDCreadRegFileFSRU_FPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.178
			u32 addressWithStride = address << 3;
			// 'ppc_e200z4.hadl', l.178
			roStorage *ro = (roStorage *)FSRU_FPRChunk;
			// 'ppc_e200z4.hadl', l.178
			return ro->read32AtAddress(addressWithStride);
		}
		inline u8 FSRU_FPR_read8(const u32 address) {
			//DDC related function (read)
			m_DDCreadRegFileFSRU_FPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.178
			u32 addressWithStride = address << 3;
			// 'ppc_e200z4.hadl', l.178
			roStorage *ro = (roStorage *)FSRU_FPRChunk;
			// 'ppc_e200z4.hadl', l.178
			return ro->read8AtAddress(addressWithStride);
		}
		inline void FSRU_FPR_write16(const u32 address, const u16 value) {
			//DDC related function (write)
			m_DDCwriteRegFileFSRU_FPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.178
			u32 addressWithStride = address << 3;
			// 'ppc_e200z4.hadl', l.178
			rwStorage *rw = (rwStorage *)FSRU_FPRChunk;
			// 'ppc_e200z4.hadl', l.178
			rw->write16AtAddress(addressWithStride, value);
		}
		inline void FSRU_FPR_write32(const u32 address, const u32 value) {
			//DDC related function (write)
			m_DDCwriteRegFileFSRU_FPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.178
			u32 addressWithStride = address << 3;
			// 'ppc_e200z4.hadl', l.178
			rwStorage *rw = (rwStorage *)FSRU_FPRChunk;
			// 'ppc_e200z4.hadl', l.178
			rw->write32AtAddress(addressWithStride, value);
		}
		inline void FSRU_FPR_write8(const u32 address, const u8 value) {
			//DDC related function (write)
			m_DDCwriteRegFileFSRU_FPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.178
			u32 addressWithStride = address << 3;
			// 'ppc_e200z4.hadl', l.178
			rwStorage *rw = (rwStorage *)FSRU_FPRChunk;
			// 'ppc_e200z4.hadl', l.178
			rw->write8AtAddress(addressWithStride, value);
		}
		inline storage * FSRU_getChunk(const u32 address) {
			// 'ppc_e200z4.hadl', l.178
			if(address<=127U) return FSRU_FPRChunk;
			// 'ppc_e200z4.hadl', l.178
			return NULL;
		}
		inline u16 FSRU_read16(const u32 address) {
			//DDC related function (read)
			m_DDCreadRegFileFSRU_FPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.178
			u32 addressWithStride = address << 3;
			// 'ppc_e200z4.hadl', l.178
			roStorage *ro = (roStorage *)FSRU_getChunk(addressWithStride);
			// 'ppc_e200z4.hadl', l.178
			if(ro) return ro->read16AtAddress(addressWithStride);
			// 'ppc_e200z4.hadl', l.178
			else return 0;
		}
		inline u32 FSRU_read32(const u32 address) {
			//DDC related function (read)
			m_DDCreadRegFileFSRU_FPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.178
			u32 addressWithStride = address << 3;
			// 'ppc_e200z4.hadl', l.178
			roStorage *ro = (roStorage *)FSRU_getChunk(addressWithStride);
			// 'ppc_e200z4.hadl', l.178
			if(ro) return ro->read32AtAddress(addressWithStride);
			// 'ppc_e200z4.hadl', l.178
			else return 0;
		}
		inline u8 FSRU_read8(const u32 address) {
			//DDC related function (read)
			m_DDCreadRegFileFSRU_FPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.178
			u32 addressWithStride = address << 3;
			// 'ppc_e200z4.hadl', l.178
			roStorage *ro = (roStorage *)FSRU_getChunk(addressWithStride);
			// 'ppc_e200z4.hadl', l.178
			if(ro) return ro->read8AtAddress(addressWithStride);
			// 'ppc_e200z4.hadl', l.178
			else return 0;
		}
		inline void FSRU_write16(const u32 address, const u16 value) {
			//DDC related function (write)
			m_DDCwriteRegFileFSRU_FPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.178
			u32 addressWithStride = address << 3;
			// 'ppc_e200z4.hadl', l.178
			rwStorage *rw = (rwStorage *)FSRU_getChunk(addressWithStride);
			// 'ppc_e200z4.hadl', l.178
			if(rw) rw->write16AtAddress(addressWithStride, value);
		}
		inline void FSRU_write32(const u32 address, const u32 value) {
			//DDC related function (write)
			m_DDCwriteRegFileFSRU_FPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.178
			u32 addressWithStride = address << 3;
			// 'ppc_e200z4.hadl', l.178
			rwStorage *rw = (rwStorage *)FSRU_getChunk(addressWithStride);
			// 'ppc_e200z4.hadl', l.178
			if(rw) rw->write32AtAddress(addressWithStride, value);
		}
		inline void FSRU_write8(const u32 address, const u8 value) {
			//DDC related function (write)
			m_DDCwriteRegFileFSRU_FPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.178
			u32 addressWithStride = address << 3;
			// 'ppc_e200z4.hadl', l.178
			rwStorage *rw = (rwStorage *)FSRU_getChunk(addressWithStride);
			// 'ppc_e200z4.hadl', l.178
			if(rw) rw->write8AtAddress(addressWithStride, value);
		}
		/*********** component ICacheE200Z4 ************/
		inline void ICacheE200Z4_insertInCache(const u32 base) {
			// 'ppc_e200z4.hadl', l.435
			u32 tag; //u21
			// 'ppc_e200z4.hadl', l.435
			tag = (FIELD(base,(31U),(11U))) & 0x1FFFFF;

			// 'ppc_e200z4.hadl', l.436
			u8 index; //u6
			// 'ppc_e200z4.hadl', l.436
			index = (FIELD(base,(10U),(5U))) & 0x3F;

			// 'ppc_e200z4.hadl', l.439
			u32 i; //u32
			// 'ppc_e200z4.hadl', l.439
			i = (0U) & 0xFFFFFFFF;

			// 'ppc_e200z4.hadl', l.440
			u8 found; //u1
			// 'ppc_e200z4.hadl', l.440
			found = (0U) & 0x1;

			// 'ppc_e200z4.hadl', l.453
			u32 __tmp_0__; //u32
			__tmp_0__ = 0;

			while((__tmp_0__ < 0x2) && (((((i)<(2U)))&&(((!found) & 0x1))))) {
				// 'ppc_e200z4.hadl', l.443
				u8 currentWay; //u2
				// 'ppc_e200z4.hadl', l.443
				currentWay = ((((L1FINV1_CWAY()))&((u8)(1U)))) & 0x3;

				// 'ppc_e200z4.hadl', l.450
				if(((!FIELD((L1CSR0_wid()),(((3U)-(currentWay))),(((3U)-(currentWay))))) & 0x1)){
					// 'ppc_e200z4.hadl', l.449
					if(((!gadl_ICacheE200Z4_cacheArray[currentWay].lines[index].lock) & 0x1)){
						// 'ppc_e200z4.hadl', l.447
						gadl_ICacheE200Z4_cacheArray[currentWay].lines[index].tag = (tag) & 0x1FFFFF;

						// 'ppc_e200z4.hadl', l.448
						gadl_ICacheE200Z4_cacheArray[currentWay].lines[index].valid = (1U) & 0x1;

						// 'ppc_e200z4.hadl', l.449
						found = (1U) & 0x1;

					}
				}
				// 'ppc_e200z4.hadl', l.452
				setL1FINV1_CWAY(((((((u8)((L1FINV1_CWAY())))+((u8)(1U))))&((u8)(1U)))) & 0x3);

				// 'ppc_e200z4.hadl', l.453
				i = ((((u64)(i))+((u64)(1U)))) & 0xFFFFFFFF;

				__tmp_0__++;

			}
		}
		inline u8 ICacheE200Z4_isInCache(const u32 addr) {
			// 'ppc_e200z4.hadl', l.413
			u32 tag; //u21
			// 'ppc_e200z4.hadl', l.413
			tag = (FIELD(addr,(31U),(11U))) & 0x1FFFFF;

			// 'ppc_e200z4.hadl', l.414
			u8 index; //u6
			// 'ppc_e200z4.hadl', l.414
			index = (FIELD(addr,(10U),(5U))) & 0x3F;

			// 'ppc_e200z4.hadl', l.415
			u8 found; //u1
			// 'ppc_e200z4.hadl', l.415
			found = (0U) & 0x1;

			// 'ppc_e200z4.hadl', l.416
			u32 wayId; //u32
			// 'ppc_e200z4.hadl', l.416
			wayId = (0U) & 0xFFFFFFFF;

			// 'ppc_e200z4.hadl', l.425
			u32 __tmp_0__; //u32
			__tmp_0__ = 0;

			while((__tmp_0__ < 0x2) && (((((wayId)<(2U)))&&(((!found) & 0x1))))) {
				// 'ppc_e200z4.hadl', l.419
				gadl_type_ICacheE200Z4_cacheLine currentLine; //gadl_type_ICacheE200Z4_cacheLine
				// 'ppc_e200z4.hadl', l.419
				memcpy(&(currentLine), &(gadl_ICacheE200Z4_cacheArray[wayId].lines[index]), sizeof(gadl_type_ICacheE200Z4_cacheLine));

				// 'ppc_e200z4.hadl', l.424
				if(((((currentLine.tag)==(tag)))&&(currentLine.valid))){
					// 'ppc_e200z4.hadl', l.422
					found = (1U) & 0x1;

				} else {
					// 'ppc_e200z4.hadl', l.424
					wayId = ((((u64)(wayId))+((u64)(1U)))) & 0xFFFFFFFF;

				}
				__tmp_0__++;

			}
			// 'ppc_e200z4.hadl', l.428
			if(found){
				// 'ppc_e200z4.hadl', l.427
				sethit(((((u64)((hit())))+((u64)(1U)))) & 0xFFFFFFFF);

			} else {
				// 'ppc_e200z4.hadl', l.428
				setmiss(((((u64)((miss())))+((u64)(1U)))) & 0xFFFFFFFF);

			}
			// 'ppc_e200z4.hadl', l.430
			return found;
		}
		inline void ICacheE200Z4_reset() {
			// 'ppc_e200z4.hadl', l.387
			u32 wayId; //u32
			// 'ppc_e200z4.hadl', l.387
			wayId = (0U) & 0xFFFFFFFF;

			// 'ppc_e200z4.hadl', l.388
			u8 index; //u6
			// 'ppc_e200z4.hadl', l.388
			index = (0U) & 0x3F;

			// 'ppc_e200z4.hadl', l.389
			setL1CSR0((0U) & 0xFFFFFFFF);

			// 'ppc_e200z4.hadl', l.390
			sethit((0U) & 0xFFFFFFFF);

			// 'ppc_e200z4.hadl', l.391
			setmiss((0U) & 0xFFFFFFFF);

			// 'ppc_e200z4.hadl', l.403
			u32 __tmp_0__; //u32
			__tmp_0__ = 0;

			while((__tmp_0__ < 0x2) && (((wayId)<(2U)))) {
				// 'ppc_e200z4.hadl', l.396
				index = (0U) & 0x3F;

				// 'ppc_e200z4.hadl', l.401
				u32 __tmp_0__; //u32
				__tmp_0__ = 0;

				while((__tmp_0__ < 0x40) && (((index)<(64U)))) {
					// 'ppc_e200z4.hadl', l.399
					gadl_ICacheE200Z4_cacheArray[wayId].lines[index].valid = (0U) & 0x1;

					// 'ppc_e200z4.hadl', l.400
					gadl_ICacheE200Z4_cacheArray[wayId].lines[index].lock = (0U) & 0x1;

					// 'ppc_e200z4.hadl', l.401
					index = ((((u8)(index))+((u8)(1U)))) & 0x3F;

					__tmp_0__++;

				}
				// 'ppc_e200z4.hadl', l.403
				wayId = ((((u64)(wayId))+((u64)(1U)))) & 0xFFFFFFFF;

				__tmp_0__++;

			}
		}
		/*********** component ICacheE200Z4LineBuffer ************/
		inline u32 ICacheE200Z4LineBuffer_baseAddress() {
			// 'ppc_e200z4.hadl', l.488
			return gadl_ICacheE200Z4LineBuffer_basePC;
		}
		inline void ICacheE200Z4LineBuffer_dataReceived() {
			// 'ppc_e200z4.hadl', l.483
			gadl_ICacheE200Z4LineBuffer_dblWordInBuffer = (((gadl_ICacheE200Z4LineBuffer_dblWordInBuffer)|((u8)(((1U)<<(gadl_ICacheE200Z4LineBuffer_currentId)))))) & 0xF;

			// 'ppc_e200z4.hadl', l.484
			gadl_ICacheE200Z4LineBuffer_currentId = ((((u8)(gadl_ICacheE200Z4LineBuffer_currentId))+((u8)(1U)))) & 0x3;

		}
		inline void ICacheE200Z4LineBuffer_endFilling() {
			// 'ppc_e200z4.hadl', l.494
			gadl_ICacheE200Z4LineBuffer_filling = (0U) & 0x1;

		}
		inline u8 ICacheE200Z4LineBuffer_isFilling() {
			// 'ppc_e200z4.hadl', l.498
			return gadl_ICacheE200Z4LineBuffer_filling;
		}
		inline u8 ICacheE200Z4LineBuffer_isInBuffer() {
			// 'ppc_e200z4.hadl', l.478
			return ((gadl_ICacheE200Z4LineBuffer_dblWordInBuffer)&((u8)(((1U)<<(FIELD((PC()),(4U),(3U)))))));
		}
		inline void ICacheE200Z4LineBuffer_startToFill() {
			// 'ppc_e200z4.hadl', l.468
			gadl_ICacheE200Z4LineBuffer_filling = (1U) & 0x1;

			// 'ppc_e200z4.hadl', l.469
			gadl_ICacheE200Z4LineBuffer_dblWordInBuffer = (0U) & 0xF;

			// 'ppc_e200z4.hadl', l.470
			gadl_ICacheE200Z4LineBuffer_currentId = (FIELD((PC()),(4U),(3U))) & 0x3;

			// 'ppc_e200z4.hadl', l.471
			gadl_ICacheE200Z4LineBuffer_basePC = ((PC())) & 0xFFFFFFFF;

		}
		/*********** component Integer_Unit ************/
		inline u8 Integer_Unit_arithCompare(const s32 op1, const s32 op2) {
			// 'ppc_e200z4.hadl', l.312
			u8 res; //u4
			// 'ppc_e200z4.hadl', l.318
			if(((op1)<(op2))){
				// 'ppc_e200z4.hadl', l.314
				res = (8U) & 0xF;

			} else {
				// 'ppc_e200z4.hadl', l.318
				if(((op1)>(op2))){
					// 'ppc_e200z4.hadl', l.316
					res = (4U) & 0xF;

				} else {
					// 'ppc_e200z4.hadl', l.318
					res = (2U) & 0xF;

				}
			}
			// 'ppc_e200z4.hadl', l.321
			res = (((res)|((u8)(((XER_SO())) & 0xF)))) & 0xF;

			// 'ppc_e200z4.hadl', l.323
			return res;
		}
		inline void Integer_Unit_div_ov_signed(const s32 ra, const s32 rb) {
			// 'ppc_e200z4.hadl', l.220
			if((((((((u32)(ra))==(134217728U)))&&((((u32)(rb))==((u32)((s32)((SIGN_EXTEND(((-1U) & 0x3),2U,32U)) & 0xFFFFFFFF)))))))||(((rb)==((u8)(0U)))))){
				// 'ppc_e200z4.hadl', l.219
				setXER_OV((1U) & 0x1);

				// 'ppc_e200z4.hadl', l.220
				setXER_SO(((((XER_SO()))|((XER_OV())))) & 0x1);

			}
		}
		inline void Integer_Unit_div_ov_signed_withUpdateStatus(const s32 ra, const s32 rb, const u64 result) {
			// 'ppc_e200z4.hadl', l.227
			if((((((((u32)(ra))==(134217728U)))&&((((u32)(rb))==((u32)((s32)((SIGN_EXTEND(((-1U) & 0x3),2U,32U)) & 0xFFFFFFFF)))))))||(((rb)==((u8)(0U)))))){
				// 'ppc_e200z4.hadl', l.226
				setXER_OV((1U) & 0x1);

				// 'ppc_e200z4.hadl', l.227
				setXER_SO(((((XER_SO()))|((XER_OV())))) & 0x1);

			}
			// 'ppc_e200z4.hadl', l.229
			Integer_Unit_updateStatus(result);
		}
		inline void Integer_Unit_div_ov_unsigned(const u32 ra, const u32 rb) {
			// 'ppc_e200z4.hadl', l.235
			if(((rb)==(0U))){
				// 'ppc_e200z4.hadl', l.234
				setXER_OV((1U) & 0x1);

				// 'ppc_e200z4.hadl', l.235
				setXER_SO(((((XER_SO()))|((XER_OV())))) & 0x1);

			}
		}
		inline void Integer_Unit_div_ov_unsigned_withUpdateStatus(const u32 ra, const u32 rb, const u64 result) {
			// 'ppc_e200z4.hadl', l.242
			if(((rb)==(0U))){
				// 'ppc_e200z4.hadl', l.241
				setXER_OV((1U) & 0x1);

				// 'ppc_e200z4.hadl', l.242
				setXER_SO(((((XER_SO()))|((XER_OV())))) & 0x1);

			}
			// 'ppc_e200z4.hadl', l.244
			Integer_Unit_updateStatus(result);
		}
		inline u32 Integer_Unit_insertWithMask(const u32 src, const u32 mask, const u32 insert) {
			// 'ppc_e200z4.hadl', l.327
			return ((((insert)&(mask)))|(((src)&(((~mask) & 0xFFFFFFFF)))));
		}
		inline u32 Integer_Unit_insertWithMaskAndUpdateStatus(const u32 src, const u32 mask, const u32 insert) {
			// 'ppc_e200z4.hadl', l.331
			u64 result; //u33
			// 'ppc_e200z4.hadl', l.331
			result = (((((insert)&(mask)))|(((src)&(((~mask) & 0xFFFFFFFF)))))) & 0x1FFFFFFFFULL;

			// 'ppc_e200z4.hadl', l.332
			Integer_Unit_updateStatus(result);
			// 'ppc_e200z4.hadl', l.333
			return result;
		}
		inline u8 Integer_Unit_logicalCompare(const u32 op1, const u32 op2) {
			// 'ppc_e200z4.hadl', l.297
			u8 res; //u4
			// 'ppc_e200z4.hadl', l.303
			if(((op1)<(op2))){
				// 'ppc_e200z4.hadl', l.299
				res = (8U) & 0xF;

			} else {
				// 'ppc_e200z4.hadl', l.303
				if(((op1)>(op2))){
					// 'ppc_e200z4.hadl', l.301
					res = (4U) & 0xF;

				} else {
					// 'ppc_e200z4.hadl', l.303
					res = (2U) & 0xF;

				}
			}
			// 'ppc_e200z4.hadl', l.306
			res = (((res)|((u8)(((XER_SO())) & 0xF)))) & 0xF;

			// 'ppc_e200z4.hadl', l.308
			return res;
		}
		inline void Integer_Unit_mul_ov(const u64 result) {
			// 'ppc_e200z4.hadl', l.252
			if((((((s64)(result))>=((s64)((SIGN_EXTEND((s32)((2147483648U) & 0xFFFFFFFF),32U,64U)) & 0xFFFFFFFFFFFFFFFFULL))))&&((((s64)(result))<=((s64)((SIGN_EXTEND(2147483647U,32U,64U)) & 0xFFFFFFFFFFFFFFFFULL)))))){
				// 'ppc_e200z4.hadl', l.250
				setXER_OV((0U) & 0x1);

			} else {
				// 'ppc_e200z4.hadl', l.252
				setXER_OV((1U) & 0x1);

			}
			// 'ppc_e200z4.hadl', l.254
			setXER_SO(((((XER_SO()))|((XER_OV())))) & 0x1);

		}
		inline void Integer_Unit_mul_ov_withUpdateStatus(const u64 result, const u64 res) {
			// 'ppc_e200z4.hadl', l.262
			if((((((s64)(result))>=((s64)((SIGN_EXTEND((s32)((2147483648U) & 0xFFFFFFFF),32U,64U)) & 0xFFFFFFFFFFFFFFFFULL))))&&((((s64)(result))<=((s64)((SIGN_EXTEND(2147483647U,32U,64U)) & 0xFFFFFFFFFFFFFFFFULL)))))){
				// 'ppc_e200z4.hadl', l.260
				setXER_OV((0U) & 0x1);

			} else {
				// 'ppc_e200z4.hadl', l.262
				setXER_OV((1U) & 0x1);

			}
			// 'ppc_e200z4.hadl', l.264
			setXER_SO(((((XER_SO()))|((XER_OV())))) & 0x1);

			// 'ppc_e200z4.hadl', l.265
			Integer_Unit_updateStatus(res);
		}
		inline void Integer_Unit_updateCarry(const u64 result) {
			// 'ppc_e200z4.hadl', l.184
			setXER_CA((FIELD(result,(32U),(32U))) & 0x1);

		}
		inline void Integer_Unit_updateOverflowArith(const u64 result, const u32 op1, const u32 op2) {
			// 'ppc_e200z4.hadl', l.270
			setXER_OV((((((((FIELD(op1,(31U),(31U)))&&(FIELD(op2,(31U),(31U)))))&&(((!FIELD(result,(31U),(31U))) & 0x1))))||(((((((!FIELD(op1,(31U),(31U))) & 0x1))&&(((!FIELD(op2,(31U),(31U))) & 0x1))))&&(FIELD(result,(31U),(31U))))))) & 0x1);

			// 'ppc_e200z4.hadl', l.271
			setXER_SO(((((XER_SO()))|((XER_OV())))) & 0x1);

		}
		inline void Integer_Unit_updateOverflowArith_withUpdateCarry(const u64 result, const u32 op1, const u32 op2) {
			// 'ppc_e200z4.hadl', l.283
			setXER_OV((((((((FIELD(op1,(31U),(31U)))&&(FIELD(op2,(31U),(31U)))))&&(((!FIELD(result,(31U),(31U))) & 0x1))))||(((((((!FIELD(op1,(31U),(31U))) & 0x1))&&(((!FIELD(op2,(31U),(31U))) & 0x1))))&&(FIELD(result,(31U),(31U))))))) & 0x1);

			// 'ppc_e200z4.hadl', l.284
			setXER_SO(((((XER_SO()))|((XER_OV())))) & 0x1);

			// 'ppc_e200z4.hadl', l.285
			Integer_Unit_updateCarry(result);
		}
		inline void Integer_Unit_updateOverflowArith_withUpdateStatus(const u64 result, const u32 op1, const u32 op2) {
			// 'ppc_e200z4.hadl', l.276
			setXER_OV((((((((FIELD(op1,(31U),(31U)))&&(FIELD(op2,(31U),(31U)))))&&(((!FIELD(result,(31U),(31U))) & 0x1))))||(((((((!FIELD(op1,(31U),(31U))) & 0x1))&&(((!FIELD(op2,(31U),(31U))) & 0x1))))&&(FIELD(result,(31U),(31U))))))) & 0x1);

			// 'ppc_e200z4.hadl', l.277
			setXER_SO(((((XER_SO()))|((XER_OV())))) & 0x1);

			// 'ppc_e200z4.hadl', l.278
			Integer_Unit_updateStatus(result);
		}
		inline void Integer_Unit_updateOverflowArith_withUpdateStatusAndCarry(const u64 result, const u32 op1, const u32 op2) {
			// 'ppc_e200z4.hadl', l.290
			setXER_OV((((((((FIELD(op1,(31U),(31U)))&&(FIELD(op2,(31U),(31U)))))&&(((!FIELD(result,(31U),(31U))) & 0x1))))||(((((((!FIELD(op1,(31U),(31U))) & 0x1))&&(((!FIELD(op2,(31U),(31U))) & 0x1))))&&(FIELD(result,(31U),(31U))))))) & 0x1);

			// 'ppc_e200z4.hadl', l.291
			setXER_SO(((((XER_SO()))|((XER_OV())))) & 0x1);

			// 'ppc_e200z4.hadl', l.292
			Integer_Unit_updateStatus(result);
			// 'ppc_e200z4.hadl', l.293
			Integer_Unit_updateCarry(result);
		}
		inline void Integer_Unit_updateStatus(const u64 result) {
			// 'ppc_e200z4.hadl', l.188
			s32 tmp; //s32
			// 'ppc_e200z4.hadl', l.188
			tmp = ((s32)(FIELD(result,(31U),(0U)))) & 0xFFFFFFFF;

			// 'ppc_e200z4.hadl', l.195
			if(((tmp)==((u8)(0U)))){
				// 'ppc_e200z4.hadl', l.191
				setCR_CR0((2U) & 0xF);

			} else {
				// 'ppc_e200z4.hadl', l.195
				if(((tmp)>((u8)(0U)))){
					// 'ppc_e200z4.hadl', l.193
					setCR_CR0((4U) & 0xF);

				} else {
					// 'ppc_e200z4.hadl', l.195
					setCR_CR0((8U) & 0xF);

				}
			}
			// 'ppc_e200z4.hadl', l.198
			setCR_CR0((FIELD_ASSIGN((CR_CR0()),(0U),(0U),((XER_SO())))) & 0xF);

		}
		inline void Integer_Unit_updateStatusAndCarry(const u64 result) {
			// 'ppc_e200z4.hadl', l.202
			s32 tmp; //s32
			// 'ppc_e200z4.hadl', l.202
			tmp = ((s32)(FIELD(result,(31U),(0U)))) & 0xFFFFFFFF;

			// 'ppc_e200z4.hadl', l.209
			if(((tmp)==((u8)(0U)))){
				// 'ppc_e200z4.hadl', l.205
				setCR_CR0((2U) & 0xF);

			} else {
				// 'ppc_e200z4.hadl', l.209
				if(((tmp)>((u8)(0U)))){
					// 'ppc_e200z4.hadl', l.207
					setCR_CR0((4U) & 0xF);

				} else {
					// 'ppc_e200z4.hadl', l.209
					setCR_CR0((8U) & 0xF);

				}
			}
			// 'ppc_e200z4.hadl', l.212
			setCR_CR0((FIELD_ASSIGN((CR_CR0()),(0U),(0U),((XER_SO())))) & 0xF);

			// 'ppc_e200z4.hadl', l.213
			Integer_Unit_updateCarry(result);
		}
		/*********** component SERIAL ************/
		/*********** component SRU ************/
		inline u16 SRU_GPR_read16(const u32 address) {
			//DDC related function (read)
			m_DDCreadRegFileSRU_GPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.68
			u32 addressWithStride = address << 2;
			// 'ppc_e200z4.hadl', l.68
			roStorage *ro = (roStorage *)SRU_GPRChunk;
			// 'ppc_e200z4.hadl', l.68
			return ro->read16AtAddress(addressWithStride);
		}
		inline u32 SRU_GPR_read32(const u32 address) {
			//DDC related function (read)
			m_DDCreadRegFileSRU_GPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.68
			u32 addressWithStride = address << 2;
			// 'ppc_e200z4.hadl', l.68
			roStorage *ro = (roStorage *)SRU_GPRChunk;
			// 'ppc_e200z4.hadl', l.68
			return ro->read32AtAddress(addressWithStride);
		}
		inline u8 SRU_GPR_read8(const u32 address) {
			//DDC related function (read)
			m_DDCreadRegFileSRU_GPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.68
			u32 addressWithStride = address << 2;
			// 'ppc_e200z4.hadl', l.68
			roStorage *ro = (roStorage *)SRU_GPRChunk;
			// 'ppc_e200z4.hadl', l.68
			return ro->read8AtAddress(addressWithStride);
		}
		inline void SRU_GPR_write16(const u32 address, const u16 value) {
			//DDC related function (write)
			m_DDCwriteRegFileSRU_GPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.68
			u32 addressWithStride = address << 2;
			// 'ppc_e200z4.hadl', l.68
			rwStorage *rw = (rwStorage *)SRU_GPRChunk;
			// 'ppc_e200z4.hadl', l.68
			rw->write16AtAddress(addressWithStride, value);
		}
		inline void SRU_GPR_write32(const u32 address, const u32 value) {
			//DDC related function (write)
			m_DDCwriteRegFileSRU_GPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.68
			u32 addressWithStride = address << 2;
			// 'ppc_e200z4.hadl', l.68
			rwStorage *rw = (rwStorage *)SRU_GPRChunk;
			// 'ppc_e200z4.hadl', l.68
			rw->write32AtAddress(addressWithStride, value);
		}
		inline void SRU_GPR_write8(const u32 address, const u8 value) {
			//DDC related function (write)
			m_DDCwriteRegFileSRU_GPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.68
			u32 addressWithStride = address << 2;
			// 'ppc_e200z4.hadl', l.68
			rwStorage *rw = (rwStorage *)SRU_GPRChunk;
			// 'ppc_e200z4.hadl', l.68
			rw->write8AtAddress(addressWithStride, value);
		}
		inline storage * SRU_getChunk(const u32 address) {
			// 'ppc_e200z4.hadl', l.160
			if(address<=127U) return SRU_GPRChunk;
			// 'ppc_e200z4.hadl', l.160
			return NULL;
		}
		inline u16 SRU_read16(const u32 address) {
			//DDC related function (read)
			m_DDCreadRegFileSRU_GPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.68
			u32 addressWithStride = address << 2;
			// 'ppc_e200z4.hadl', l.68
			roStorage *ro = (roStorage *)SRU_getChunk(addressWithStride);
			// 'ppc_e200z4.hadl', l.68
			if(ro) return ro->read16AtAddress(addressWithStride);
			// 'ppc_e200z4.hadl', l.68
			else return 0;
		}
		inline u32 SRU_read32(const u32 address) {
			//DDC related function (read)
			m_DDCreadRegFileSRU_GPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.68
			u32 addressWithStride = address << 2;
			// 'ppc_e200z4.hadl', l.68
			roStorage *ro = (roStorage *)SRU_getChunk(addressWithStride);
			// 'ppc_e200z4.hadl', l.68
			if(ro) return ro->read32AtAddress(addressWithStride);
			// 'ppc_e200z4.hadl', l.68
			else return 0;
		}
		inline u8 SRU_read8(const u32 address) {
			//DDC related function (read)
			m_DDCreadRegFileSRU_GPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.68
			u32 addressWithStride = address << 2;
			// 'ppc_e200z4.hadl', l.68
			roStorage *ro = (roStorage *)SRU_getChunk(addressWithStride);
			// 'ppc_e200z4.hadl', l.68
			if(ro) return ro->read8AtAddress(addressWithStride);
			// 'ppc_e200z4.hadl', l.68
			else return 0;
		}
		inline u32 SRU_spr_read(const u16 spr_no) {
			// 'ppc_e200z4.hadl', l.129
			u32 result; //u32
			// 'ppc_e200z4.hadl', l.141
			if(((spr_no)==(1U))){
				// 'ppc_e200z4.hadl', l.131
				result = ((XER())) & 0xFFFFFFFF;

			} else {
				// 'ppc_e200z4.hadl', l.141
				if(((spr_no)==(8U))){
					// 'ppc_e200z4.hadl', l.133
					result = ((LR())) & 0xFFFFFFFF;

				} else {
					// 'ppc_e200z4.hadl', l.141
					if(((spr_no)==(9U))){
						// 'ppc_e200z4.hadl', l.135
						result = ((CTR())) & 0xFFFFFFFF;

					} else {
						// 'ppc_e200z4.hadl', l.141
						if(((spr_no)==(26U))){
							// 'ppc_e200z4.hadl', l.137
							result = ((SRR0())) & 0xFFFFFFFF;

						} else {
							// 'ppc_e200z4.hadl', l.141
							if(((spr_no)==(27U))){
								// 'ppc_e200z4.hadl', l.139
								result = ((SRR1())) & 0xFFFFFFFF;

							} else {
								// 'ppc_e200z4.hadl', l.141
								std::cerr << "RUNTIME WARNING at file '/Users/briday-m/Documents/ADLMateriel/HADL/branches/p2ac/gadl/examples/PPC/./ppc_e200z4.hadl', line 141:41. Message is \"read from a non existing SPR\"" << std::endl;

							}
						}
					}
				}
			}
			// 'ppc_e200z4.hadl', l.143
			return result;
		}
		inline void SRU_spr_write(const u16 spr_no, const u32 value) {
			// 'ppc_e200z4.hadl', l.124
			if(((spr_no)==(1U))){
				// 'ppc_e200z4.hadl', l.114
				setXER((value) & 0xFFFFFFFF);

			} else {
				// 'ppc_e200z4.hadl', l.124
				if(((spr_no)==(8U))){
					// 'ppc_e200z4.hadl', l.116
					setLR((value) & 0xFFFFFFFF);

				} else {
					// 'ppc_e200z4.hadl', l.124
					if(((spr_no)==(9U))){
						// 'ppc_e200z4.hadl', l.118
						setCTR((value) & 0xFFFFFFFF);

					} else {
						// 'ppc_e200z4.hadl', l.124
						if(((spr_no)==(26U))){
							// 'ppc_e200z4.hadl', l.120
							setSRR0((value) & 0xFFFFFFFF);

						} else {
							// 'ppc_e200z4.hadl', l.124
							if(((spr_no)==(27U))){
								// 'ppc_e200z4.hadl', l.122
								setSRR1((value) & 0xFFFFFFFF);

							} else {
								// 'ppc_e200z4.hadl', l.124
								std::cerr << "RUNTIME WARNING at file '/Users/briday-m/Documents/ADLMateriel/HADL/branches/p2ac/gadl/examples/PPC/./ppc_e200z4.hadl', line 124:40. Message is \"Write to a non existing SPR\"" << std::endl;

							}
						}
					}
				}
			}
		}
		inline void SRU_storeMultiWord(const u32 addr, const u8 index) {
			// 'ppc_e200z4.hadl', l.148
			u32 currentAddr; //u32
			// 'ppc_e200z4.hadl', l.149
			u8 currentIndex; //u5
			// 'ppc_e200z4.hadl', l.150
			u32 regVal; //u32
			// 'ppc_e200z4.hadl', l.151
			currentAddr = (addr) & 0xFFFFFFFF;

			// 'ppc_e200z4.hadl', l.152
			currentIndex = (index) & 0x1F;

			// 'ppc_e200z4.hadl', l.158
			u32 __tmp_0__; //u32
			__tmp_0__ = 0;

			while((__tmp_0__ < 0x20) && (((index)<=(31U)))) {
				// 'ppc_e200z4.hadl', l.155
				regVal = (SRU_GPR_read32(currentIndex)) & 0xFFFFFFFF;

				// 'ppc_e200z4.hadl', l.156
				mem_write32(currentAddr, regVal);
				// 'ppc_e200z4.hadl', l.157
				currentAddr = ((((u64)(currentAddr))+((u64)(4U)))) & 0xFFFFFFFF;

				// 'ppc_e200z4.hadl', l.158
				currentIndex = ((((u8)(currentIndex))+((u8)(1U)))) & 0x1F;

				__tmp_0__++;

			}
		}
		inline void SRU_write16(const u32 address, const u16 value) {
			//DDC related function (write)
			m_DDCwriteRegFileSRU_GPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.68
			u32 addressWithStride = address << 2;
			// 'ppc_e200z4.hadl', l.68
			rwStorage *rw = (rwStorage *)SRU_getChunk(addressWithStride);
			// 'ppc_e200z4.hadl', l.68
			if(rw) rw->write16AtAddress(addressWithStride, value);
		}
		inline void SRU_write32(const u32 address, const u32 value) {
			//DDC related function (write)
			m_DDCwriteRegFileSRU_GPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.68
			u32 addressWithStride = address << 2;
			// 'ppc_e200z4.hadl', l.68
			rwStorage *rw = (rwStorage *)SRU_getChunk(addressWithStride);
			// 'ppc_e200z4.hadl', l.68
			if(rw) rw->write32AtAddress(addressWithStride, value);
		}
		inline void SRU_write8(const u32 address, const u8 value) {
			//DDC related function (write)
			m_DDCwriteRegFileSRU_GPRAccess |= 1<<address;
			// 'ppc_e200z4.hadl', l.68
			u32 addressWithStride = address << 2;
			// 'ppc_e200z4.hadl', l.68
			rwStorage *rw = (rwStorage *)SRU_getChunk(addressWithStride);
			// 'ppc_e200z4.hadl', l.68
			if(rw) rw->write8AtAddress(addressWithStride, value);
		}
		/*********** component effective_address_Unit ************/
		inline void effective_address_Unit_eff_addr_add(u32 &rd, const u32 ra, const u32 rb) {
			// 'ppc_e200z4.hadl', l.339
			rd = ((((u64)(ra))+((u64)(rb)))) & 0xFFFFFFFF;

		}
		/*********** component fetcher ************/
		inline void fetcher_absBranch(const u32 newPC, const u8 cond) {
			// 'ppc_e200z4.hadl', l.43
			if(cond){
				// 'ppc_e200z4.hadl', l.43
				setPC((newPC) & 0xFFFFFFFF);

			}
		}
		inline void fetcher_reset() {
			// 'ppc_e200z4.hadl', l.37
			setPC((0U) & 0xFFFFFFFF);

		}
		inline void fetcher_test() {
			// 'ppc_e200z4.hadl', l.33
			gadl_type_fetcher_cacheLine lines[2]; //fetcher_cacheLine
			// 'ppc_e200z4.hadl', l.34
			lines[0U].valid = (0U) & 0x1;

		}
		/*********** component gdbppc ************/
		inline u8 gdbppc_getNBRegister() {
			// 'ppc_e200z4.hadl', l.3490
			return 70U;
		}
		inline u32 gdbppc_getRegister(const u8 id, u8 &sizeInBits) {
			// 'ppc_e200z4.hadl', l.3498
			u32 result; //u32
			// 'ppc_e200z4.hadl', l.3525
			if(((id)<=(31U))){
				// 'ppc_e200z4.hadl', l.3500
				result = (SRU_GPR_read32(id)) & 0xFFFFFFFF;

				// 'ppc_e200z4.hadl', l.3501
				sizeInBits = (32U) & 0xFF;

			} else {
				// 'ppc_e200z4.hadl', l.3525
				if(((id)<=(63U))){
					// 'ppc_e200z4.hadl', l.3504
					result = (0U) & 0xFFFFFFFF;

					// 'ppc_e200z4.hadl', l.3505
					sizeInBits = (64U) & 0xFF;

				} else {
					// 'ppc_e200z4.hadl', l.3525
					if(((id)==(64U))){
						// 'ppc_e200z4.hadl', l.3507
						result = ((PC())) & 0xFFFFFFFF;

						// 'ppc_e200z4.hadl', l.3508
						sizeInBits = (32U) & 0xFF;

					} else {
						// 'ppc_e200z4.hadl', l.3525
						if(((id)==(65U))){
							// 'ppc_e200z4.hadl', l.3510
							result = ((MSR())) & 0xFFFFFFFF;

							// 'ppc_e200z4.hadl', l.3511
							sizeInBits = (32U) & 0xFF;

						} else {
							// 'ppc_e200z4.hadl', l.3525
							if(((id)==(66U))){
								// 'ppc_e200z4.hadl', l.3513
								result = ((CR())) & 0xFFFFFFFF;

								// 'ppc_e200z4.hadl', l.3514
								sizeInBits = (32U) & 0xFF;

							} else {
								// 'ppc_e200z4.hadl', l.3525
								if(((id)==(67U))){
									// 'ppc_e200z4.hadl', l.3516
									result = ((LR())) & 0xFFFFFFFF;

									// 'ppc_e200z4.hadl', l.3517
									sizeInBits = (32U) & 0xFF;

								} else {
									// 'ppc_e200z4.hadl', l.3525
									if(((id)==(68U))){
										// 'ppc_e200z4.hadl', l.3519
										result = ((CTR())) & 0xFFFFFFFF;

										// 'ppc_e200z4.hadl', l.3520
										sizeInBits = (32U) & 0xFF;

									} else {
										// 'ppc_e200z4.hadl', l.3525
										if(((id)==(69U))){
											// 'ppc_e200z4.hadl', l.3522
											result = ((XER())) & 0xFFFFFFFF;

											// 'ppc_e200z4.hadl', l.3523
											sizeInBits = (32U) & 0xFF;

										} else {
											// 'ppc_e200z4.hadl', l.3525
											std::cerr << "RUNTIME WARNING at file '/Users/briday-m/Documents/ADLMateriel/HADL/branches/p2ac/gadl/examples/PPC/./ppc_e200z4.hadl', line 3525:55. Message is \"trying to read in a non described register\"" << std::endl;

										}
									}
								}
							}
						}
					}
				}
			}
			// 'ppc_e200z4.hadl', l.3528
			return result;
		}
		inline u8 gdbppc_read8(const u32 v_addr) {
			// 'ppc_e200z4.hadl', l.3480
			return mem_read8(v_addr);
		}
		inline void gdbppc_setRegister(const u8 id, const u32 value) {
			// 'ppc_e200z4.hadl', l.3550
			if(((id)<=(31U))){
				// 'ppc_e200z4.hadl', l.3534
				SRU_GPR_write32(id, value);
			} else {
				// 'ppc_e200z4.hadl', l.3550
				if(((id)<=(63U))){

				} else {
					// 'ppc_e200z4.hadl', l.3550
					if(((id)==(64U))){
						// 'ppc_e200z4.hadl', l.3538
						setPC((value) & 0xFFFFFFFF);

					} else {
						// 'ppc_e200z4.hadl', l.3550
						if(((id)==(65U))){
							// 'ppc_e200z4.hadl', l.3540
							setMSR((value) & 0xFFFFFFFF);

						} else {
							// 'ppc_e200z4.hadl', l.3550
							if(((id)==(66U))){
								// 'ppc_e200z4.hadl', l.3542
								setCR((value) & 0xFFFFFFFF);

							} else {
								// 'ppc_e200z4.hadl', l.3550
								if(((id)==(67U))){
									// 'ppc_e200z4.hadl', l.3544
									setLR((value) & 0xFFFFFFFF);

								} else {
									// 'ppc_e200z4.hadl', l.3550
									if(((id)==(68U))){
										// 'ppc_e200z4.hadl', l.3546
										setCTR((value) & 0xFFFFFFFF);

									} else {
										// 'ppc_e200z4.hadl', l.3550
										if(((id)==(69U))){
											// 'ppc_e200z4.hadl', l.3548
											setXER((value) & 0xFFFFFFFF);

										} else {
											// 'ppc_e200z4.hadl', l.3550
											std::cerr << "RUNTIME WARNING at file '/Users/briday-m/Documents/ADLMateriel/HADL/branches/p2ac/gadl/examples/PPC/./ppc_e200z4.hadl', line 3550:56. Message is \"trying to write in a non described register\"" << std::endl;

										}
									}
								}
							}
						}
					}
				}
			}
		}
		inline void gdbppc_write8(const u32 v_addr, const u8 val) {
			// 'ppc_e200z4.hadl', l.3485
			mem_write8(v_addr, val);
		}
		/*********** component mem ************/
		inline storage * mem_getChunk(const u32 address) {
			// 'ppc_e200z4.hadl', l.56
			if(address<=33554432U) return mem_ramChunk;
			// 'ppc_e200z4.hadl', l.56
			return NULL;
		}
		inline u16 mem_ram_read16(const u32 address) {
			// 'ppc_e200z4.hadl', l.56
			roStorage *ro = (roStorage *)mem_ramChunk;
			// 'ppc_e200z4.hadl', l.56
			return ro->read16AtAddress(address);
		}
		inline u32 mem_ram_read32(const u32 address) {
			// 'ppc_e200z4.hadl', l.56
			roStorage *ro = (roStorage *)mem_ramChunk;
			// 'ppc_e200z4.hadl', l.56
			return ro->read32AtAddress(address);
		}
		inline u8 mem_ram_read8(const u32 address) {
			// 'ppc_e200z4.hadl', l.56
			roStorage *ro = (roStorage *)mem_ramChunk;
			// 'ppc_e200z4.hadl', l.56
			return ro->read8AtAddress(address);
		}
		inline void mem_ram_write16(const u32 address, const u16 value) {
			// 'ppc_e200z4.hadl', l.56
			rwStorage *rw = (rwStorage *)mem_ramChunk;
			// 'ppc_e200z4.hadl', l.56
			rw->write16AtAddress(address, value);
		}
		inline void mem_ram_write32(const u32 address, const u32 value) {
			// 'ppc_e200z4.hadl', l.56
			rwStorage *rw = (rwStorage *)mem_ramChunk;
			// 'ppc_e200z4.hadl', l.56
			rw->write32AtAddress(address, value);
		}
		inline void mem_ram_write8(const u32 address, const u8 value) {
			// 'ppc_e200z4.hadl', l.56
			rwStorage *rw = (rwStorage *)mem_ramChunk;
			// 'ppc_e200z4.hadl', l.56
			rw->write8AtAddress(address, value);
		}
		inline u16 mem_read16(const u32 address) {
			// 'ppc_e200z4.hadl', l.56
			roStorage *ro = (roStorage *)mem_getChunk(address);
			// 'ppc_e200z4.hadl', l.56
			if(ro) return ro->read16AtAddress(address);
			// 'ppc_e200z4.hadl', l.56
			else return 0;
		}
		inline u32 mem_read32(const u32 address) {
			// 'ppc_e200z4.hadl', l.56
			roStorage *ro = (roStorage *)mem_getChunk(address);
			// 'ppc_e200z4.hadl', l.56
			if(ro) return ro->read32AtAddress(address);
			// 'ppc_e200z4.hadl', l.56
			else return 0;
		}
		inline u8 mem_read8(const u32 address) {
			// 'ppc_e200z4.hadl', l.56
			roStorage *ro = (roStorage *)mem_getChunk(address);
			// 'ppc_e200z4.hadl', l.56
			if(ro) return ro->read8AtAddress(address);
			// 'ppc_e200z4.hadl', l.56
			else return 0;
		}
		inline void mem_write16(const u32 address, const u16 value) {
			// 'ppc_e200z4.hadl', l.56
			rwStorage *rw = (rwStorage *)mem_getChunk(address);
			// 'ppc_e200z4.hadl', l.56
			if(rw) rw->write16AtAddress(address, value);
		}
		inline void mem_write32(const u32 address, const u32 value) {
			// 'ppc_e200z4.hadl', l.56
			rwStorage *rw = (rwStorage *)mem_getChunk(address);
			// 'ppc_e200z4.hadl', l.56
			if(rw) rw->write32AtAddress(address, value);
		}
		inline void mem_write8(const u32 address, const u8 value) {
			// 'ppc_e200z4.hadl', l.56
			rwStorage *rw = (rwStorage *)mem_getChunk(address);
			// 'ppc_e200z4.hadl', l.56
			if(rw) rw->write8AtAddress(address, value);
		}

		
		/** registers declaration for each component */
		//registers defined in component ICacheE200Z4:
		//register L1CSR0 access
		inline u32 L1CSR0() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_L1CSR0;
			return __L1CSR0;};
		inline void setL1CSR0(const u32 value) {__L1CSR0 = value & 0xFFFFFFFF;
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_L1CSR0;};

		//register L1CSR0.wid access
		inline u8 L1CSR0_wid() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_L1CSR0;
			return FIELD(L1CSR0(),(31U),(28U));};
		inline void setL1CSR0_wid(const u8 value) {
			u32 __temp = L1CSR0();
			__temp = (FIELD_ASSIGN(__temp,(31U),(28U),(value))) & 0xFFFFFFFF;
			setL1CSR0(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_L1CSR0;
		};

		//register L1CSR1 access
		inline u32 L1CSR1() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_L1CSR1;
			return __L1CSR1;};
		inline void setL1CSR1(const u32 value) {__L1CSR1 = value & 0xFFFFFFFF;
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_L1CSR1;};

		//register L1CSR1.ICINV access
		inline u8 L1CSR1_ICINV() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_L1CSR1;
			return FIELD(L1CSR1(),(1U),(1U));};
		inline void setL1CSR1_ICINV(const u8 value) {
			u32 __temp = L1CSR1();
			__temp = (FIELD_ASSIGN(__temp,(1U),(1U),(value))) & 0xFFFFFFFF;
			setL1CSR1(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_L1CSR1;
		};

		//register L1CSR1.ICE access
		inline u8 L1CSR1_ICE() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_L1CSR1;
			return FIELD(L1CSR1(),(0U),(0U));};
		inline void setL1CSR1_ICE(const u8 value) {
			u32 __temp = L1CSR1();
			__temp = (FIELD_ASSIGN(__temp,(0U),(0U),(value))) & 0xFFFFFFFF;
			setL1CSR1(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_L1CSR1;
		};

		//register L1FINV1 access
		inline u32 L1FINV1() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_L1FINV1;
			return __L1FINV1;};
		inline void setL1FINV1(const u32 value) {__L1FINV1 = value & 0xFFFFFFFF;
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_L1FINV1;};

		//register L1FINV1.CWAY access
		inline u8 L1FINV1_CWAY() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_L1FINV1;
			return FIELD(L1FINV1(),(25U),(24U));};
		inline void setL1FINV1_CWAY(const u8 value) {
			u32 __temp = L1FINV1();
			__temp = (FIELD_ASSIGN(__temp,(25U),(24U),(value))) & 0xFFFFFFFF;
			setL1FINV1(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_L1FINV1;
		};

		//register L1FINV1.CSET access
		inline u8 L1FINV1_CSET() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_L1FINV1;
			return FIELD(L1FINV1(),(10U),(5U));};
		inline void setL1FINV1_CSET(const u8 value) {
			u32 __temp = L1FINV1();
			__temp = (FIELD_ASSIGN(__temp,(10U),(5U),(value))) & 0xFFFFFFFF;
			setL1FINV1(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_L1FINV1;
		};

		//register L1FINV1.CCMD access
		inline u8 L1FINV1_CCMD() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_L1FINV1;
			return FIELD(L1FINV1(),(1U),(0U));};
		inline void setL1FINV1_CCMD(const u8 value) {
			u32 __temp = L1FINV1();
			__temp = (FIELD_ASSIGN(__temp,(1U),(0U),(value))) & 0xFFFFFFFF;
			setL1FINV1(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_L1FINV1;
		};

		//register hit access
		inline u32 hit() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_hit;
			return __hit;};
		inline void sethit(const u32 value) {__hit = value & 0xFFFFFFFF;
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_hit;};

		//register miss access
		inline u32 miss() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_miss;
			return __miss;};
		inline void setmiss(const u32 value) {__miss = value & 0xFFFFFFFF;
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_miss;};
		//registers defined in component SRU:
		//register CR access
		inline u32 CR() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_CR;
			return __CR;};
		inline void setCR(const u32 value) {__CR = value & 0xFFFFFFFF;
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_CR;};

		//register CR.CR0 access
		inline u8 CR_CR0() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_CR;
			return FIELD(CR(),(31U),(28U));};
		inline void setCR_CR0(const u8 value) {
			u32 __temp = CR();
			__temp = (FIELD_ASSIGN(__temp,(31U),(28U),(value))) & 0xFFFFFFFF;
			setCR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_CR;
		};

		//register CR.CR1 access
		inline u8 CR_CR1() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_CR;
			return FIELD(CR(),(27U),(24U));};
		inline void setCR_CR1(const u8 value) {
			u32 __temp = CR();
			__temp = (FIELD_ASSIGN(__temp,(27U),(24U),(value))) & 0xFFFFFFFF;
			setCR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_CR;
		};

		//register CR.CR2 access
		inline u8 CR_CR2() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_CR;
			return FIELD(CR(),(23U),(20U));};
		inline void setCR_CR2(const u8 value) {
			u32 __temp = CR();
			__temp = (FIELD_ASSIGN(__temp,(23U),(20U),(value))) & 0xFFFFFFFF;
			setCR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_CR;
		};

		//register CR.CR3 access
		inline u8 CR_CR3() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_CR;
			return FIELD(CR(),(19U),(16U));};
		inline void setCR_CR3(const u8 value) {
			u32 __temp = CR();
			__temp = (FIELD_ASSIGN(__temp,(19U),(16U),(value))) & 0xFFFFFFFF;
			setCR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_CR;
		};

		//register CR.CR4 access
		inline u8 CR_CR4() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_CR;
			return FIELD(CR(),(15U),(12U));};
		inline void setCR_CR4(const u8 value) {
			u32 __temp = CR();
			__temp = (FIELD_ASSIGN(__temp,(15U),(12U),(value))) & 0xFFFFFFFF;
			setCR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_CR;
		};

		//register CR.CR5 access
		inline u8 CR_CR5() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_CR;
			return FIELD(CR(),(11U),(8U));};
		inline void setCR_CR5(const u8 value) {
			u32 __temp = CR();
			__temp = (FIELD_ASSIGN(__temp,(11U),(8U),(value))) & 0xFFFFFFFF;
			setCR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_CR;
		};

		//register CR.CR6 access
		inline u8 CR_CR6() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_CR;
			return FIELD(CR(),(7U),(4U));};
		inline void setCR_CR6(const u8 value) {
			u32 __temp = CR();
			__temp = (FIELD_ASSIGN(__temp,(7U),(4U),(value))) & 0xFFFFFFFF;
			setCR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_CR;
		};

		//register CR.CR7 access
		inline u8 CR_CR7() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_CR;
			return FIELD(CR(),(3U),(0U));};
		inline void setCR_CR7(const u8 value) {
			u32 __temp = CR();
			__temp = (FIELD_ASSIGN(__temp,(3U),(0U),(value))) & 0xFFFFFFFF;
			setCR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_CR;
		};

		//register CTR access
		inline u32 CTR() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_CTR;
			return __CTR;};
		inline void setCTR(const u32 value) {__CTR = value & 0xFFFFFFFF;
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_CTR;};

		//register LR access
		inline u32 LR() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_LR;
			return __LR;};
		inline void setLR(const u32 value) {__LR = value & 0xFFFFFFFF;
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_LR;};

		//register MSR access
		inline u32 MSR() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return __MSR;};
		inline void setMSR(const u32 value) {__MSR = value & 0xFFFFFFFF;
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;};

		//register MSR.POW access
		inline u8 MSR_POW() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(18U),(18U));};
		inline void setMSR_POW(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(18U),(18U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register MSR.ILE access
		inline u8 MSR_ILE() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(16U),(16U));};
		inline void setMSR_ILE(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(16U),(16U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register MSR.EE access
		inline u8 MSR_EE() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(15U),(15U));};
		inline void setMSR_EE(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(15U),(15U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register MSR.PR access
		inline u8 MSR_PR() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(14U),(14U));};
		inline void setMSR_PR(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(14U),(14U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register MSR.FP access
		inline u8 MSR_FP() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(13U),(13U));};
		inline void setMSR_FP(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(13U),(13U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register MSR.ME access
		inline u8 MSR_ME() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(12U),(12U));};
		inline void setMSR_ME(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(12U),(12U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register MSR.FE0 access
		inline u8 MSR_FE0() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(11U),(11U));};
		inline void setMSR_FE0(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(11U),(11U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register MSR.SE access
		inline u8 MSR_SE() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(10U),(10U));};
		inline void setMSR_SE(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(10U),(10U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register MSR.BE access
		inline u8 MSR_BE() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(9U),(9U));};
		inline void setMSR_BE(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(9U),(9U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register MSR.FE1 access
		inline u8 MSR_FE1() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(8U),(8U));};
		inline void setMSR_FE1(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(8U),(8U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register MSR.IP access
		inline u8 MSR_IP() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(6U),(6U));};
		inline void setMSR_IP(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(6U),(6U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register MSR.IR access
		inline u8 MSR_IR() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(5U),(5U));};
		inline void setMSR_IR(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(5U),(5U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register MSR.DR access
		inline u8 MSR_DR() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(4U),(4U));};
		inline void setMSR_DR(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(4U),(4U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register MSR.RI access
		inline u8 MSR_RI() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(1U),(1U));};
		inline void setMSR_RI(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(1U),(1U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register MSR.LE access
		inline u8 MSR_LE() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_MSR;
			return FIELD(MSR(),(0U),(0U));};
		inline void setMSR_LE(const u8 value) {
			u32 __temp = MSR();
			__temp = (FIELD_ASSIGN(__temp,(0U),(0U),(value))) & 0xFFFFFFFF;
			setMSR(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_MSR;
		};

		//register SRR0 access
		inline u32 SRR0() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_SRR0;
			return __SRR0;};
		inline void setSRR0(const u32 value) {__SRR0 = value & 0xFFFFFFFF;
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_SRR0;};

		//register SRR1 access
		inline u32 SRR1() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_SRR1;
			return __SRR1;};
		inline void setSRR1(const u32 value) {__SRR1 = value & 0xFFFFFFFF;
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_SRR1;};

		//register XER access
		inline u32 XER() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_XER;
			return __XER;};
		inline void setXER(const u32 value) {__XER = value & 0xFFFFFFFF;
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_XER;};

		//register XER.SO access
		inline u8 XER_SO() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_XER;
			return FIELD(XER(),(31U),(31U));};
		inline void setXER_SO(const u8 value) {
			u32 __temp = XER();
			__temp = (FIELD_ASSIGN(__temp,(31U),(31U),(value))) & 0xFFFFFFFF;
			setXER(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_XER;
		};

		//register XER.OV access
		inline u8 XER_OV() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_XER;
			return FIELD(XER(),(30U),(30U));};
		inline void setXER_OV(const u8 value) {
			u32 __temp = XER();
			__temp = (FIELD_ASSIGN(__temp,(30U),(30U),(value))) & 0xFFFFFFFF;
			setXER(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_XER;
		};

		//register XER.CA access
		inline u8 XER_CA() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_XER;
			return FIELD(XER(),(29U),(29U));};
		inline void setXER_CA(const u8 value) {
			u32 __temp = XER();
			__temp = (FIELD_ASSIGN(__temp,(29U),(29U),(value))) & 0xFFFFFFFF;
			setXER(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_XER;
		};

		//register XER.byte_count access
		inline u8 XER_byte_count() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_XER;
			return FIELD(XER(),(6U),(0U));};
		inline void setXER_byte_count(const u8 value) {
			u32 __temp = XER();
			__temp = (FIELD_ASSIGN(__temp,(6U),(0U),(value))) & 0xFFFFFFFF;
			setXER(__temp);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_XER;
		};
		//registers defined in component mem:
		//register SERIAL0 access
		inline u8 SERIAL0() {
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_SERIAL0;
			return mem_ram_read8(0x2FFF);};
		inline void setSERIAL0(const u8 value) {mem_ram_write8(0x2FFF, value);
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_SERIAL0;};

};
#endif
