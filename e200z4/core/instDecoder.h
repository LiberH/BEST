/**
 * generated by HARMLESS : 'Hardware ARchitecture Modeling Language
 *                          for Embedded Software Simulation'
 * model : e200z4
 *
 */

#ifndef __e200z4_INST_DECODER_H__
#define __e200z4_INST_DECODER_H__

#include "types.h"
#include "action.h" //execute action handling.

/** uncomment the following line not to use the internal 
 *  instruction cache. This leads to computation overhead and should
 *  only be used for benchmarks
 */
//#define DO_NOT_USE_INTERNAL_INSTRUCTION_CACHE

class e200z4_instruction;
class context;
class arch;
class e200z4_instDecoderCache;
class executeInstAction;

/** class that decodes instruction. The main
 * method is "decode" which will return the decoded 
 * instruction, and increment the Program Counter accordingly
 */
class e200z4_instDecoder
{	
	
	#ifndef DO_NOT_USE_INTERNAL_INSTRUCTION_CACHE
		e200z4_instDecoderCache *cache;
	#endif

	//this list records all the execute actions that are not in the cache.
	executeInstActionList m_execActionNotInCache;
	
	unsigned int m_nbMemAccessForNextInst;

	//effectively decode the instruction.
	e200z4_instruction* decodeDirect(arch *_arch, u32 &ip);
public:
	/** \brief main function to decode instructions. 
	 *
	 * The number of accesses required to obtain the value is stored in an internal
	 * value and is available with method getNumberOfMemoryAccessesForLastDecode().
	 * \param ctx The context of the cpu (contains memory)
	 * \param ip the value of the instruction pointer. It points
	 * to the value that will be decoded.
	 * \param defaultFetch use the default fetch function, instead of the user defined 
	 *  one. This is mandatory for disassemble, because it should not alter the processor 
	 *  state. This parameter is not generated if no user fetch is declared in description.
	 * \return an instruction object that correspond to the code pointed by
	 * the instructtion pointer.
	 */
	e200z4_instruction* decode(arch *_arch, u32 &ip);

	/** instruction that effectively decode the instruction code.
	 * This method is called by the internal instruction cache if 
	 * the instruction code is not found in the internal cache.
	 * IT SHOULD ONLY BE CALLED BY THE INTERNAL CACHE!
	 */
	e200z4_instruction* decodeWithExecActionCache(arch *_arch, u32 &ip);
	/* constructor. Build the internal instruction cache.*/
	e200z4_instDecoder();
	/** return the instruction at address if it is in the cache
	 *  and returns NULL if instruction is NOT in the cache
	 *  It does not decode anything!!
	 *  (if simulator is compiled without instruction cache, it always returns NULL).
	 */
	e200z4_instruction *isInCache(const u32 address);
	/** should be called when an executeInstAction is added
	 * The executeInstAction embedds both an instruction AND a list of execute actions.
	 */
	void replaceInCache(const u32 addr, e200z4_instruction *inst,executeInstAction *eia);

	/** number of memory accesses required to decode the last instruction
	 * useful in the case of variable length instructions. TODO: not yet used.
	 */
	inline unsigned int const getNumberOfMemoryAccessesForLastDecode() 
		{return m_nbMemAccessForNextInst;};
	
	void addExecuteActionAtAddress(const u32 addr, executeAction *ea);

	//this method should ONLY be called by the cache to inform the decoder
	//that an instruction is removed.
	void cacheRemoveInstruction(e200z4_instruction *instToRemove);

	//remove an execute action at address.
	//@return true if the action is effectively removed.
	bool removeExecuteActionAtAddress(const u32 addr, executeAction *ea);
	
	void decoderStats();
};

#endif
