/**
 * generated by HARMLESS : 'Hardware ARchitecture Modeling Language
 *                          for Embedded Software Simulation'
 * model : e200z4
 *
 */

#ifndef __INST_DECODER_CACHE_H__
#define __INST_DECODER_CACHE_H__

#ifndef DO_NOT_USE_INTERNAL_INSTRUCTION_CACHE

#include "types.h"

class e200z4_instDecoder;
class e200z4_instruction;
class arch;

#define IDC_VALID_OFFSET 0
#define IDC_CHUNKS_OFFSET  1
#define IDC_TAG_OFFSET   5

#define IDC_TAG_CHUNKS    (32-IDC_TAG_OFFSET)
/* number of instruction chunks used to fetch the instruction IDC_CHUNKS_MAX-1*/
#define IDC_CHUNKS_MAX    (1 << (IDC_TAG_OFFSET - IDC_CHUNKS_OFFSET))
#define IDC_CHUNKS_MASK   (IDC_CHUNKS_MAX-1)

//uncomment the following line to get information about cache usage (hit/miss ratio)
//#define INST_DECODER_CACHE_STATS

//structure that correspond to a cache entry. It stores :
//	* the instruction
//	* a tag
//	* a valid bit
//	* the number of instruction code chunks
struct e200z4_instDecoderCacheEntry
{
	/**instruction stored in the cache*/
	e200z4_instruction *inst;
	/** the control bit field is composed of
	 * bit 0 : valid bit -> the entry contains an instruction (0 -> no data).
	 * bit 1..4 : nb of chunks required. (i.e. the number of time the fetch 
	 *                                    function should be called)
	 * bit 5.. : tag. index length may be from 1??? to 14 bits. The size of the 
	 *           cache will be 2^(index length) entries. The instruction 
	 *           pointer (32 bits) is composed of a  
	 *           -- tag -- index -- zeros ( 2 '0' according to alignment)
	 *           => tagLength+indexLength = 32-2
	 */
	u32 control;
};

class executeInstAction;

class e200z4_instDecoderCache
{
	//buffer that stores instructions.
	e200z4_instDecoderCacheEntry *m_buffer;

	//size of the block
	const unsigned int m_indexLengthBits;

	#ifdef INST_DECODER_CACHE_STATS
		/// statistics: number of hits.
		unsigned int m_hitCount;
		/// statistics: number of misses.
		unsigned int m_missCount;
	#endif

	/** check that an instruction is in the cache buffer. If this is the case, codeAddr is 
     *  updated accordingly and the instruction pointer is returned. In the other case, a
	 *  NULL pointer is returned.
     */
    e200z4_instruction *isInBuffer(const u32 index, 
										const u32 tag, 
										u32 &codeAddr);

	/** decode a new instruction (that was not in the cache), update the instruction 
	 *  pointer, and set it in the buffer. 
     *  If there is no entry available, the last recently used entry is removed
     */
    e200z4_instruction* storeInBuffer(arch *_arch,
							               u32 &codeAddress,
							               e200z4_instDecoder *decoder,	
							               const u32 index, 
							               const u32 tag);

    public:
	/** get instruction in the cache (and update instruction pointer) if it was previously used. 
	 *  In the other case, the instruction is decoded, the instruction pointer is updated and 
	 *  the new instruction is stored in the buffer.
	 */
    e200z4_instruction *getInstruction(arch *_arch, u32 &pc, e200z4_instDecoder *);
	/** constructor.
	 * \param indexLengthBits size of the buffer in bits. For instance 8 will build 
	 * a direct cache with 256 entries.
	 */
    e200z4_instDecoderCache(const unsigned int indexLengthBits);
	/** print useful information on std output (cache use, nb of hits/miss) 
	 */
	void printCacheStats();

	//just to know if an instruction is in the cache.
	e200z4_instruction *isInCache(const u32 address);
	
	/** should be called when an executeInstAction is added
	 * The executeInstAction embedds both an instruction AND a list of execute actions.
	 */
	void replaceInCache(const u32 addr, e200z4_instruction *inst,executeInstAction *eia);	
	/** deconstructor.
	 */
	~e200z4_instDecoderCache();

    private:
};

#endif //DO_NOT_USE_INTERNAL_INSTRUCTION_CACHE
#endif
