/**
 * generated by HARMLESS : 'Hardware ARchitecture Modeling Language
 *                          for Embedded Software Simulation'
 * model : e200z4
 *
 */

#include <iostream>
#include <iomanip> //setioflags (setw)
#include "arch.h"
#include "instructionBase.h"
#include "instDecoder.h"
#include "macro.h"
#include "breakpointAction.h"
#include "peripherals.h"
#include "utils.h"
#include "fifo.h"

#ifdef GADL_SP_CHECK_ALLOWED
#include "stackController.h"
#endif // GADL_SP_CHECK_ALLOWED

#include <sstream> //stringstream

#include "iHexReader.h"
#include "sRecordReader.h"
#ifdef USE_LIBELF
	#include "elfReader.h"
#endif
#ifdef GADL_WITH_PIPELINE_TRACE
	#include "pipelineTraceDebug.h"
#endif
//timing part
#include "timingSignal.h"
#include "timing_ICacheE200Z4.h"
#include "timing_ICacheE200Z4LineBuffer.h"
#include "timing_mem.h"
#include "pipelineExample.h"


using namespace std;

void arch::decoderStats()
{
	m_decoder->decoderStats();
}

arch::arch()
{
	m_reader = NULL;
	m_nbCycles = 0;
	m_nbInst = 0;
	//m_context = new context();
	m_decoder = new e200z4_instDecoder();
    //m_executionMode = arch::ISS;
	m_executionMode = arch::CAS;
#ifdef GADL_WITH_PIPELINE_TRACE
	m_pipelineTrace = NULL;
#endif
	
	
	FSRU_FPRChunk = new rwStorage("FSRU_FPRChunk", 128, 0);
	SRU_GPRChunk = new rwStorage("SRU_GPRChunk", 128, 0);
	mem_ramChunk = new rwStorage("mem_ramChunk", 33554433, 0);
	//init locals of component FSRU

	//init locals of component ICacheE200Z4

	//init locals of component ICacheE200Z4LineBuffer

	//init locals of component Integer_Unit

	//init locals of component SERIAL

	//init locals of component SRU

	//init locals of component effective_address_Unit

	//init locals of component fetcher

	//init locals of component gdbppc

	//init locals of component mem



	//cyclic init
	m_cyclicRootNode = NULL;
	m_nextCyclicWakeUpDate = 0;
	m_lastBreakpointAddr = 0;
	/// init peripherals, read or write actions associated to a register.
	#ifndef GADL_NO_ACTION
	mem_ramChunk->addWriteActionAtAddress(12287, new SERIAL0write(this));
	#endif

	//pipeline model init
	m_nextInstruction_pipelineExample = NULL;
	m_pipelinepipelineExample = new pipelineExample();
	m_pipelinepipelineExample->init(this);
	m_instInPipe_pipelineExample = 0;

	e200z4_instruction *stall = new e200z4_instructionStall(); //stall used 1
	for(unsigned int i=0;i<8; i++)
	{
		if(i != 0) stall->retain();
		m_instructionsInPipeline_pipelineExample[i] = stall;
	}

	//DDC related part.
	m_DDCInstRequireStage = 0;
	m_DDCInstLockStage = 0;
	m_DDCregsInUse = 0;
	m_DDCCurrentReadRegs = 0;

	m_fifoDDC = new fifo<u64>("DDC lock registers",5);


	//*******  Data Cache (TODO partially hand coded..) ***** 
	for(unsigned int i=0;i<8; i++)
	{
		//(4 is hand-coded: This should be the max number of access in one cycle.
		m_fifoMemAccessTab[i] = new fifo<u32>("mem access fifo",4);
	}
	m_memStage = 0; //instruction in MEM stage.
	// STACK Spying
	#ifdef	GADL_SP_CHECK_ALLOWED
	m_stackController=new stackSpyController(this);
	#endif

	m_timingICache = new timingICacheE200Z4(SIGNAL_WAIT_ICache_OFFSET,
		SIGNAL_EMIT_ICache_OFFSET);
	m_timingICacheLineBuffer = new timingICacheE200Z4LineBuffer(SIGNAL_WAIT_ICacheLineBuffer_OFFSET,
		SIGNAL_EMIT_ICacheLineBuffer_OFFSET);
	m_timingMemDev = new timingmem(SIGNAL_WAIT_MemDev_OFFSET,
		SIGNAL_EMIT_MemDev_OFFSET);
	reset();
}

void arch::reset()
{
	m_nbCycles = 0;
	m_nbInst = 0;
	m_PC = 0;

	m_stopSimu = 0;

	ICacheE200Z4_reset();
	fetcher_reset();
	setSERIAL0(0U);



	m_timingICache->init();
	m_timingICacheLineBuffer->init();
	m_timingMemDev->init();
	for(unsigned int i = 0;i < NB_SIGNAL_EMIT;i++) m_pendingSignalEmitTab[i]=NULL;
	for(unsigned int i = 0;i < NB_SIGNAL_WAIT;i++) m_pendingSignalWaitTab[i]=NULL;
	m_timingListRoot = NULL;
	m_timingNextWakeUp = 0xFFFFFFFFFFFFFFFFULL; //max u64 value.
	m_timingICacheLineBuffer->run(this); //start automata (not related to a shared port)
	m_timingMemDev->run(this); //start automata (not related to a shared port)
}

void arch::removeAllBreakpoints()
{
	map<u32, breakpointAction *>::iterator it = m_breakpointActionMap.begin();
	const map<u32, breakpointAction *>::const_iterator itEnd = m_breakpointActionMap.end();
	while(it != itEnd)
	{
		u32 addr = (*it).first;
		breakpointAction *ba = (*it).second;
		removeExecuteActionAtAddress(addr, ba);
		delete ba;
		it++;
	}
	m_breakpointActionMap.clear();
}

void arch::removeBreakpoint(const unsigned int addr)
{
	map<u32, breakpointAction *>::iterator it = m_breakpointActionMap.find(addr);
	if(it != m_breakpointActionMap.end())
	{
		breakpointAction *ba = (*it).second;
		removeExecuteActionAtAddress(addr, ba);
		m_breakpointActionMap.erase(it);
		delete ba;
	} else cerr << "no breakpoint defined at address 0x" << hex << addr << endl;
}

void arch::removeExecuteActionAtAddress(const u32 addr, executeAction *ea)
{
	if(!m_decoder->removeExecuteActionAtAddress(addr,ea))
		cerr << "error: the execute action cannot be removed at address 0x" << hex << addr << endl;
}

void arch::addExecuteActionAtAddress(const u32 addr, executeAction *ea)
{
	m_decoder->addExecuteActionAtAddress(addr, ea);
}

void arch::addBreakpoint(const unsigned int addr)
{
		map<u32, breakpointAction *>::iterator it = m_breakpointActionMap.find(addr);
		if(it == m_breakpointActionMap.end())
		{
			breakpointAction *ba = new breakpointAction(addr);
			addExecuteActionAtAddress(addr, ba);
			m_breakpointActionMap[addr] = ba;
		} else cerr << "There is already a breakpoint defined at address 0x" << hex << addr << endl;
}

void arch::removeBreakpoint(const char *symbolName)
{
	u32 v_addr;
	if(getFunctionName(symbolName, v_addr))
	{
		bool found = false;
		u32 p_addr = getPhysicalAddress(v_addr, found);
		if(!found) cerr << "symbol " << symbolName << " have a virtual address (0x" <<
			hex << v_addr << "), but no physical address.";
		removeBreakpoint(p_addr);
	} else cerr << "no symbol found for " << symbolName << endl;
}

void arch::addBreakpoint(const char *symbolName)
{
	u32 v_addr;
	if(getFunctionName(symbolName, v_addr))
	{
		bool found = false;
		u32 p_addr = getPhysicalAddress(v_addr, found);
		if(!found) cerr << "symbol " << symbolName << " have a virtual address (0x" <<
			hex << v_addr << "), but no physical address.";
		addBreakpoint(p_addr);
	} else cerr << "no symbol found for " << symbolName << endl;
}

storage * arch::getProgramChunk(const unsigned int address)
{
	if(address<=33554432U) return mem_ramChunk;

	return NULL;	
}

void arch::setExecutionMode(const executionMode mode)
{
	if(m_nbCycles)
	{
		std::cerr << "switch ISS <-> CAS mode not yet implemented dynamically!" << std::endl;
		std::cerr << "Warning : change is not taken into account!" << std::endl;
	} else m_executionMode = mode;

}

int arch::execInst(const unsigned int nb)
{
	m_stopSimu = 0;

	if(m_executionMode == arch::ISS) return emuInst(nb);
	else { //CAS simulation.
		if(!m_nextInstruction_pipelineExample) //first time
		{
			m_nextInstruction_pipelineExample = m_decoder->decode(this, m_PC );
			const unsigned int instIndex = m_instInPipe_pipelineExample & 0x7; //range 0 -> 7.
			m_instructionsInPipeline_pipelineExample[instIndex]->release();
			m_instructionsInPipeline_pipelineExample[instIndex] = m_nextInstruction_pipelineExample;
			m_instInPipe_pipelineExample++;
		}
	//and prepare the next.
		for(unsigned int i = 0; i < nb && !m_stopSimu; i++)
		{
			while(!execOneCycle() && !m_stopSimu);
		}
	}
	return m_stopSimu;

}

//hash_length const arch::getInstructionDdClassCode() {return 0;}
void arch::runUntil(const unsigned int addr, const unsigned int max)
{
		unsigned int _max = getNBInstructions()+max;
		while(programCounter() != addr && getNBInstructions() < _max) execInst(1);
}

unsigned int arch::getNextInstructionCodeIn_pipelineExample()
{
	return m_nextInstruction_pipelineExample->instClass();
}


unsigned int arch::getExternalResourcesState_pipelineExample()
{
	//0 <-> resource is FREE
	//1 <-> resource is TAKEN (not available)
	//From external resources defined in the .config file
	//first external resource is lowest significant bit.
	unsigned int result = 0;
	result |= (!(m_timingICache->isInit())) << EXT_RES_MEMDEV_FETCH;
	return result | (testDDCLock() << EXT_RES_DDCRES);
}

bool arch::execOneCycle()
{
	#ifdef GADL_CYCLIC_ENABLE
		if(m_nextCyclicWakeUpDate <= m_nbCycles) manageCyclicPart();
	#endif
	if(m_timingNextWakeUp <= m_nbCycles) manageTiming();
	const unsigned int notification = m_pipelinepipelineExample -> execOneState(getExternalResourcesState_pipelineExample(),m_nextInstruction_pipelineExample->instClass());
	bool instExecuted = false;
	//we have to deal with notifications.
	//TODO: hard coded at this date
	if(notification & ENTER_FETCH_MASK) //fetch
	{
		m_nextInstruction_pipelineExample->execute(this);						//execute
		m_nextInstruction_pipelineExample = m_decoder->decode(this, m_PC ); //and prepare the next.
		m_timingICache->run(this); //tmp

		//update the tab of instructions.
		const unsigned int instIndex = m_instInPipe_pipelineExample & 0x7; //range 0 -> 7.
		m_instructionsInPipeline_pipelineExample[instIndex]->release();
		m_instructionsInPipeline_pipelineExample[instIndex] = m_nextInstruction_pipelineExample;
		m_instInPipe_pipelineExample++;
	}

	#ifdef GADL_WITH_PIPELINE_TRACE
	if(m_pipelineTrace)
		m_pipelineTrace->pipelineTrace(notification, getNBCycles(), m_instructionsInPipeline_pipelineExample, m_instInPipe_pipelineExample);
	#endif
	DDCManagement(notification);
	if(notification & EXITS_REGISTER_MASK) //nbInst
	{
		m_nbInst++;
		instExecuted = true;
	}
	m_nbCycles++;
	return instExecuted;
}

//TODO: handles only 1 pipeline!!

void arch::DDCManagement(const unsigned int notification)
{
	//DDC related code.
	if(notification & ENTER_EXECUTE_MASK) //instruction enters in stage after the READ -> lock
	{
		//lock phase.

		const unsigned int indexDDCLock = m_DDCInstLockStage & 0x7;
		e200z4_instruction *DDCLockInst = m_instructionsInPipeline_pipelineExample[indexDDCLock];
		//lock registers
		u64 lock = 0;
		DDCLockInst->lockDDCWriteRegs(lock);
		m_fifoDDC->write(lock);
		//if(m_DDCregsInUse & lock) cout << "*** WAW detected!!! Not taken into account." << endl;
		m_DDCregsInUse |= lock;
		//RAZ condition.
		m_DDCCurrentReadRegs = 0;
		m_DDCInstLockStage++;
	}
	if(notification & ENTER_DECODE_EA_MASK) //instruction enters in stage where is done the READ -> request
	{
		const unsigned int indexDDCReq = m_DDCInstRequireStage & 0x7;
		e200z4_instruction *DDCReqInst = m_instructionsInPipeline_pipelineExample[indexDDCReq];
		//on fait le DDC sur toutes les instructions.
		//sinon, il faut une autre notification pour savoir si le DDC s'applique.
		DDCReqInst->getDDCReadRegs(m_DDCCurrentReadRegs);
		m_DDCInstRequireStage ++;
	}
	if(notification & ENTER_REGISTER_MASK) //instruction enters in stage where is done the WRITE -> unlock
	{
		//unlock registers
		u64 unlock;
		m_fifoDDC->read(unlock);
		m_DDCregsInUse = m_DDCregsInUse & ~unlock; //no WAW taken into account.
	}
}

void arch::debugDDCRegField()
{
	cout << "registers in use (lock): " << debug64(m_DDCregsInUse) << endl;
	cout << "registers required:      " << debug64(m_DDCCurrentReadRegs) << endl;
}



u32 arch::linkerAddressTranslation(u32 addr)
{
	return addr;
}

void arch::printRegs()
{

	//register L1CSR0
	cout << "L1CSR0 = " << hex << setw(8) << setfill('0') << (u64)L1CSR0()
	     << " - " << dec << (u64)L1CSR0() << endl;
	//register L1CSR0.wid
	cout << "L1CSR0.wid = " << hex << setw(1) << setfill('0') << (u64)L1CSR0_wid()
	     << " - " << dec << (u64)L1CSR0_wid() << endl;
	//register L1CSR1
	cout << "L1CSR1 = " << hex << setw(8) << setfill('0') << (u64)L1CSR1()
	     << " - " << dec << (u64)L1CSR1() << endl;
	//register L1CSR1.ICINV
	cout << "L1CSR1.ICINV = " << hex << setw(1) << setfill('0') << (u64)L1CSR1_ICINV()
	     << " - " << dec << (u64)L1CSR1_ICINV() << endl;
	//register L1CSR1.ICE
	cout << "L1CSR1.ICE = " << hex << setw(1) << setfill('0') << (u64)L1CSR1_ICE()
	     << " - " << dec << (u64)L1CSR1_ICE() << endl;
	//register L1FINV1
	cout << "L1FINV1 = " << hex << setw(8) << setfill('0') << (u64)L1FINV1()
	     << " - " << dec << (u64)L1FINV1() << endl;
	//register L1FINV1.CWAY
	cout << "L1FINV1.CWAY = " << hex << setw(1) << setfill('0') << (u64)L1FINV1_CWAY()
	     << " - " << dec << (u64)L1FINV1_CWAY() << endl;
	//register L1FINV1.CSET
	cout << "L1FINV1.CSET = " << hex << setw(2) << setfill('0') << (u64)L1FINV1_CSET()
	     << " - " << dec << (u64)L1FINV1_CSET() << endl;
	//register L1FINV1.CCMD
	cout << "L1FINV1.CCMD = " << hex << setw(1) << setfill('0') << (u64)L1FINV1_CCMD()
	     << " - " << dec << (u64)L1FINV1_CCMD() << endl;
	//register hit
	cout << "hit = " << hex << setw(8) << setfill('0') << (u64)hit()
	     << " - " << dec << (u64)hit() << endl;
	//register miss
	cout << "miss = " << hex << setw(8) << setfill('0') << (u64)miss()
	     << " - " << dec << (u64)miss() << endl;
	//register CR
	cout << "CR = " << hex << setw(8) << setfill('0') << (u64)CR()
	     << " - " << dec << (u64)CR() << endl;
	//register CR.CR0
	cout << "CR.CR0 = " << hex << setw(1) << setfill('0') << (u64)CR_CR0()
	     << " - " << dec << (u64)CR_CR0() << endl;
	//register CR.CR1
	cout << "CR.CR1 = " << hex << setw(1) << setfill('0') << (u64)CR_CR1()
	     << " - " << dec << (u64)CR_CR1() << endl;
	//register CR.CR2
	cout << "CR.CR2 = " << hex << setw(1) << setfill('0') << (u64)CR_CR2()
	     << " - " << dec << (u64)CR_CR2() << endl;
	//register CR.CR3
	cout << "CR.CR3 = " << hex << setw(1) << setfill('0') << (u64)CR_CR3()
	     << " - " << dec << (u64)CR_CR3() << endl;
	//register CR.CR4
	cout << "CR.CR4 = " << hex << setw(1) << setfill('0') << (u64)CR_CR4()
	     << " - " << dec << (u64)CR_CR4() << endl;
	//register CR.CR5
	cout << "CR.CR5 = " << hex << setw(1) << setfill('0') << (u64)CR_CR5()
	     << " - " << dec << (u64)CR_CR5() << endl;
	//register CR.CR6
	cout << "CR.CR6 = " << hex << setw(1) << setfill('0') << (u64)CR_CR6()
	     << " - " << dec << (u64)CR_CR6() << endl;
	//register CR.CR7
	cout << "CR.CR7 = " << hex << setw(1) << setfill('0') << (u64)CR_CR7()
	     << " - " << dec << (u64)CR_CR7() << endl;
	//register CTR
	cout << "CTR = " << hex << setw(8) << setfill('0') << (u64)CTR()
	     << " - " << dec << (u64)CTR() << endl;
	//register LR
	cout << "LR = " << hex << setw(8) << setfill('0') << (u64)LR()
	     << " - " << dec << (u64)LR() << endl;
	//register MSR
	cout << "MSR = " << hex << setw(8) << setfill('0') << (u64)MSR()
	     << " - " << dec << (u64)MSR() << endl;
	//register MSR.POW
	cout << "MSR.POW = " << hex << setw(1) << setfill('0') << (u64)MSR_POW()
	     << " - " << dec << (u64)MSR_POW() << endl;
	//register MSR.ILE
	cout << "MSR.ILE = " << hex << setw(1) << setfill('0') << (u64)MSR_ILE()
	     << " - " << dec << (u64)MSR_ILE() << endl;
	//register MSR.EE
	cout << "MSR.EE = " << hex << setw(1) << setfill('0') << (u64)MSR_EE()
	     << " - " << dec << (u64)MSR_EE() << endl;
	//register MSR.PR
	cout << "MSR.PR = " << hex << setw(1) << setfill('0') << (u64)MSR_PR()
	     << " - " << dec << (u64)MSR_PR() << endl;
	//register MSR.FP
	cout << "MSR.FP = " << hex << setw(1) << setfill('0') << (u64)MSR_FP()
	     << " - " << dec << (u64)MSR_FP() << endl;
	//register MSR.ME
	cout << "MSR.ME = " << hex << setw(1) << setfill('0') << (u64)MSR_ME()
	     << " - " << dec << (u64)MSR_ME() << endl;
	//register MSR.FE0
	cout << "MSR.FE0 = " << hex << setw(1) << setfill('0') << (u64)MSR_FE0()
	     << " - " << dec << (u64)MSR_FE0() << endl;
	//register MSR.SE
	cout << "MSR.SE = " << hex << setw(1) << setfill('0') << (u64)MSR_SE()
	     << " - " << dec << (u64)MSR_SE() << endl;
	//register MSR.BE
	cout << "MSR.BE = " << hex << setw(1) << setfill('0') << (u64)MSR_BE()
	     << " - " << dec << (u64)MSR_BE() << endl;
	//register MSR.FE1
	cout << "MSR.FE1 = " << hex << setw(1) << setfill('0') << (u64)MSR_FE1()
	     << " - " << dec << (u64)MSR_FE1() << endl;
	//register MSR.IP
	cout << "MSR.IP = " << hex << setw(1) << setfill('0') << (u64)MSR_IP()
	     << " - " << dec << (u64)MSR_IP() << endl;
	//register MSR.IR
	cout << "MSR.IR = " << hex << setw(1) << setfill('0') << (u64)MSR_IR()
	     << " - " << dec << (u64)MSR_IR() << endl;
	//register MSR.DR
	cout << "MSR.DR = " << hex << setw(1) << setfill('0') << (u64)MSR_DR()
	     << " - " << dec << (u64)MSR_DR() << endl;
	//register MSR.RI
	cout << "MSR.RI = " << hex << setw(1) << setfill('0') << (u64)MSR_RI()
	     << " - " << dec << (u64)MSR_RI() << endl;
	//register MSR.LE
	cout << "MSR.LE = " << hex << setw(1) << setfill('0') << (u64)MSR_LE()
	     << " - " << dec << (u64)MSR_LE() << endl;
	//register SRR0
	cout << "SRR0 = " << hex << setw(8) << setfill('0') << (u64)SRR0()
	     << " - " << dec << (u64)SRR0() << endl;
	//register SRR1
	cout << "SRR1 = " << hex << setw(8) << setfill('0') << (u64)SRR1()
	     << " - " << dec << (u64)SRR1() << endl;
	//register XER
	cout << "XER = " << hex << setw(8) << setfill('0') << (u64)XER()
	     << " - " << dec << (u64)XER() << endl;
	//register XER.SO
	cout << "XER.SO = " << hex << setw(1) << setfill('0') << (u64)XER_SO()
	     << " - " << dec << (u64)XER_SO() << endl;
	//register XER.OV
	cout << "XER.OV = " << hex << setw(1) << setfill('0') << (u64)XER_OV()
	     << " - " << dec << (u64)XER_OV() << endl;
	//register XER.CA
	cout << "XER.CA = " << hex << setw(1) << setfill('0') << (u64)XER_CA()
	     << " - " << dec << (u64)XER_CA() << endl;
	//register XER.byte_count
	cout << "XER.byte_count = " << hex << setw(2) << setfill('0') << (u64)XER_byte_count()
	     << " - " << dec << (u64)XER_byte_count() << endl;
	//register SERIAL0
	cout << "SERIAL0 = " << hex << setw(2) << setfill('0') << (u64)SERIAL0()
	     << " - " << dec << (u64)SERIAL0() << endl;
}

int arch::emuInst(const unsigned int nb)
{
	m_stopSimu = 0;
	unsigned int i = 0;
	e200z4_instruction* currentInstruction = NULL; 
	
	#ifdef GADL_SP_CHECK_ALLOWED
	u32 pcOld=0;			// CALL detection (compare PC before and after inst. exec.)
	u32 spOld=0;			// Recquired to have right SP when SPProcess()
	#endif // #ifdef GADL_SP_CHECK_ALLOWED

	while(i < nb && !m_stopSimu)
	{
		#ifdef GADL_CYCLIC_ENABLE
		if(m_nextCyclicWakeUpDate <= m_nbCycles) manageCyclicPart();
		#endif

		currentInstruction = m_decoder->decode(this, m_PC );

		// CALL DETECTION : More generic way to detect call type inst.
		#ifdef GADL_SP_CHECK_ALLOWED
		pcOld=programCounter();
		spOld=SP();
		#endif // #ifdef GADL_SP_CHECK_ALLOWED
			
		currentInstruction->execute(this);

		// CALL DETECTION : New way of detecting CALL Inst
		#ifdef GADL_SP_CHECK_ALLOWED
		if (currentInstruction->hasID_SP_Check() && (pcOld!=programCounter())) {		// Call type instuction detected
			m_stackController->setPcOld(pcOld);			// Recquired in order to correctly place actions
			m_stackController->setSpOld(spOld);			// 
			m_stackController->processSP_CHECK();	// Processing
		}
		#endif // #ifdef GADL_SP_CHECK_ALLOWED
			
		currentInstruction->release();
		i++;
	}
	m_nbInst+=i;
	return m_stopSimu;
}

/*void arch::debug(const bool _enable)
{
	m_pipeline->debug(_enable);
}*/

void arch::stopSimu(int reason)
{
	if(reason)	m_stopSimu = reason;
	else m_stopSimu = 1; 
}

std::string arch::disassemble(const unsigned int pcStart, const int nbBytes, bool verbose)
{
	stringstream result;
	u32 tempPC = (u32)pcStart;
	const u32 pcEnd = tempPC + (u32)nbBytes;
	while(tempPC < pcEnd)
	{
		const u32 pcOld = tempPC;
		if(verbose) {
			result << std::hex << "0x" << tempPC << " :";
		}
		/* the decoder does not modify the processor state (default fetch)*/
		e200z4_instruction *inst = m_decoder->decode(this,tempPC);
		if(verbose) {
			const int max = inst->size() / 4;
			for(int i = 0; i < max; i++)
			{
				unsigned int realAddr = getFetchAddress(pcOld+i);
				storage *sto=getProgramChunk(realAddr);
				result << hex << setfill('0') << setw(4 << 1) 
                       << (int)(sto->get32AtAddr(realAddr)) << " : ";
			}
		}
		result << inst->mnemo();
		inst->release();
	}
	return result.str();
}

u32 arch::getPhysicalAddress(const u32 v_addr, bool &found)
{
	if(m_reader) return linkerAddressTranslation(m_reader->getPhysicalAddress(v_addr, found));
	else 
	{
		found = false;
		return v_addr;
	}
}

bool arch::getFunctionName(const char *symbolName, u32 &v_addr)
{
	if(m_reader) return m_reader->getFunctionName(symbolName, v_addr);
	else return false;
}

bool arch::getSymbolObjectAddress(const char *symbolName, u32 &v_addr, u32 &size)
{
	if(m_reader) return m_reader->getSymbolObjectAddress(symbolName, v_addr, size);
	else return false;
}

/** read an Intel .H86, a Freescale Srecord file or an elf file */
bool arch::readCodeFile(const char *filename, const bool verbose)
{	

	#ifdef USE_LIBELF
		if(!m_reader)
		{
			//Try an elf file format (only if LGPL'd libelf library is installed). 
			m_reader = new elfReader();
			bool ok = m_reader -> readFile(filename,this,verbose);
			if(ok) setProgramCounter(m_reader -> getProgramCounter());
			else {delete m_reader; m_reader = NULL;}
		}
	#endif
	if(!m_reader)
	{
		//try an Intel .H86 format
		m_reader = new iHexReader();
		bool ok = m_reader -> readFile(filename,this,verbose);
		if(!ok) {delete m_reader; m_reader = NULL;}
	}
	if(!m_reader)
	{
		//then try a Motorola SRecord format
		m_reader = new sRecordReader();
		bool ok = m_reader -> readFile(filename,this,verbose);
		if(!ok) {delete m_reader; m_reader = NULL;}
	}
	//nothing? -> can't read the file.
	if(!m_reader) {
		std::cerr << "ERROR: can't read program file. It should be an Intel format"
		          << "(.h86, .hex), a Motorola (.sr, .s19) format";
		#ifdef USE_LIBELF
			std::cerr << " or an elf file." << std::endl;
		#else
			std::cerr << ". You can add Elf support if you install the LibElf"
			          << " elf library, available at http://www.mr511.de/software/english.html" 
					  << " (free software, licence is LGPL). Then you have to recompile the "
					  << " generated simulator using : make LIBELF=1."  << std::endl;
		#endif
	}
	return (m_reader!=NULL);
}
#ifdef USE_IO_STUBS
	#include "ioStubs.h"
#endif
bool arch::addIOStub(executeAction *act, string funcName)
{
	bool result = false;
#ifdef USE_IO_STUBS
	u32 v_addr;
	if(getFunctionName(funcName.c_str(), v_addr))
	{
		bool found = false;
		u32 p_addr = getPhysicalAddress(v_addr, found);
		if(!found) 
		{
			cerr << "internal error: symbol " << funcName << " have a virtual address (0x" <<
			hex << v_addr << "), but no physical address.";
		} else {
			//ok, insert action.
			//cerr << "insert execute action for " << funcName << " at 0x" << hex << p_addr << endl;
			addExecuteActionAtAddress(p_addr, act);
			result = true;
		}
	} else {
		//cannot find symbol of funcName
	}
#endif
	return result;
}

bool arch::useIOStubs()
{
#ifdef USE_IO_STUBS 
	if(!m_reader)
	{
		cerr << "you should first load a file, before using io stubs." << endl;
		return false;
	 } else {
		//program loaded.
		//try with "open":
		ioStubOpen *iso = new ioStubOpen();
		bool openOk = addIOStub(iso, iso->functionName());
		//try with "read":
		ioStubRead *isr = new ioStubRead(iso);
		bool readOk = addIOStub(isr, isr->functionName());
		//try with "write"
		ioStubWrite *isw = new ioStubWrite(iso);
		bool writeOk = addIOStub(isw, isw->functionName());
		//try with "write on stdout"
		ioStubPrintStdout *isps = new ioStubPrintStdout();
		bool writeStdOk = addIOStub(isps, isps->functionName());
		if(!openOk && (readOk || writeOk)) 
			cerr << "I/O stub error: no 'open' function, but a 'read' or 'write' function!!" << endl; 
		return (readOk || readOk || writeOk || writeStdOk); //at least one stub OK.
		//if(!readOk) delete isr;
	 }
#else //USE_IO_STUBS
  cerr << "file I/O stubs not compiled in. Make sure that USE_IO_STUBS is set to 1"
       << " in Makefile and hand written stubs (ioStubs.cpp and ioStubs.h) are added"
	   << "to the project (in example/<arch>/ioStubs/simulatorSource." <<endl;
	return false; 
#endif
}

std::string arch::getInstructionStaticInfo(unsigned int &p_addr)
{
	if(m_decoder)
	{
		e200z4_instruction *inst = m_decoder->decode(this, p_addr);
		if(inst) return inst->getStaticInfo(this);
	}
	return string("error");
}

void arch::dumpObjects()
{
	if(m_reader) m_reader->dumpObjects();
}

void arch::dumpFunctions()
{
	if(m_reader) m_reader->dumpFunctions();
}

std::string arch::whichFunctionAtAddress(const u32 v_addr)
{
	if(m_reader) return m_reader->whichFunctionAtAddress(v_addr);
	else return string("");
}


void arch::doNotExececuteNextInstructions(const u32 val) {
	for(unsigned int i = 0; i < val;i++)
	{
		//decode the instruction, and update the PC.
		e200z4_instruction* next; 
		next= m_decoder->decode(this, m_PC);
		next->release();
	}
}


const __cyclicFunc_e200z4 arch::cyclicFuncFor[1] = { NULL };
const __cyclicNextFunc_e200z4 arch::cyclicNextDate[1] = { NULL };


void arch::manageCyclicPart()
{
	//this function is called when m_nextCyclicWakeUpDate <= m_nbCycles
	while(m_nextCyclicWakeUpDate <= m_nbCycles)
	{
		cyclicPartNode *currentNode = m_cyclicRootNode;
		if(currentNode)
		{
			//remove the node.
			m_cyclicRootNode = currentNode->next;
			const int id = currentNode->id;
			//run
			(this->*cyclicFuncFor[id])();
			//update date (for next time)
			const u64 nextWakeUpDate = m_nextCyclicWakeUpDate+(this->*cyclicNextDate[id])(); 
			currentNode->wakeUpDate = nextWakeUpDate;
			//re-insert the node.
			insertCyclicNode(currentNode);
			//re-init m_nextCyclicWakeUpDate
			m_nextCyclicWakeUpDate = m_cyclicRootNode->wakeUpDate;
		}
	}
}


void arch::insertCyclicNode(cyclicPartNode *node)
{
	const u64 wakeUpDate=node->wakeUpDate;
	cyclicPartNode *currentNode = m_cyclicRootNode;
	cyclicPartNode *previousNode = NULL;

	while(currentNode && (currentNode->wakeUpDate)<wakeUpDate) 
	{
		previousNode = currentNode;
		currentNode = currentNode->next;
	}
	node->next = currentNode; //may be NULL
	if(previousNode)
	{
		//not at the beginning
		previousNode->next = node; //linked list.
	} else {
		//at the beginning
		m_cyclicRootNode = node;
	}
}
void arch::usePipelineTrace()
{
	#ifdef GADL_WITH_PIPELINE_TRACE
		m_pipelineTrace = new pipelineTraceDebug(5);
	#else
		cerr << "The 'usePipelineTrace' method requires to compile the simulator with the flag "
		     << "GADL_WITH_PIPELINE_TRACE. See the Makefile." << endl;
	#endif

}

void arch::outputPipelineTrace(const std::string filename)
{
	#ifdef GADL_WITH_PIPELINE_TRACE
		if(m_pipelineTrace)
			m_pipelineTrace->outputPipelineTrace(filename, this);
		else
			cerr << "The 'outputPipelineTrace' method requires to call first the "
		         << "'usePipelineTrace' at the beginning of the simulation." << endl;
	#else
		cerr << "The 'outputPipelineTrace' method requires to compile the simulator with the flag "
		     << "GADL_WITH_PIPELINE_TRACE. See the Makefile." << endl;
	#endif
}

bool arch::timingSynchroEmit(timingBase *emitAutomata,unsigned int sigEmitId, const bool broadcast)
{
	const unsigned int sigWaitId = signalLinksTo[sigEmitId];
	#ifdef DEBUG_TIMING
		cout << "synchro emit " << emitAutomata->toString();
		if(broadcast) cout << " broadcast";
		cout << " (sig " << sigEmitId << " -> " << sigWaitId << ") :";
	#endif
	if(sigWaitId==0) // the '*' in the description => not connected
	{
		#ifdef DEBUG_TIMING
			cout << "(signal not connected)" << endl;
		#endif
		return true; //calling automata can resume
	} else {
		timingBase *waitingAutomata = m_pendingSignalWaitTab[sigWaitId];
		if(waitingAutomata) //an automata is waiting
		{
			#ifdef DEBUG_TIMING
				if(broadcast) cout << "broadcast received by ";
				else cout << "rendezvous with ";
				cout << waitingAutomata->toString() << endl;
			#endif
			m_pendingSignalWaitTab[sigWaitId] = NULL; //reset signal
			waitingAutomata->run(this);
			return true; //calling automata can resume
		} else { 
			if(broadcast) {
				//Broadcast received by nobody.
				#ifdef DEBUG_TIMING
					cout << "broadcast signal received by nobody" << endl;
				#endif
				return true; //can resume.
			} else {
				//no automata is waiting: no rendez-vous. Should wait.
				#ifdef DEBUG_TIMING
					cout << "have to wait" << endl;
				#endif
				m_pendingSignalEmitTab[sigEmitId] = emitAutomata;
				return false; //calling automata should stop
			}
		}
	}
};

bool arch::timingSynchroWait(timingBase *waitingAutomata,unsigned int sigWaitId)
{
	const unsigned int sigEmitId = signalLinksFrom[sigWaitId];
	#ifdef DEBUG_TIMING
		cout << "synchro wait " << waitingAutomata->toString();
		cout << " (sig " << sigEmitId << " -> " << sigWaitId << ") :";
	#endif
	timingBase *emittingAutomata = m_pendingSignalEmitTab[sigEmitId];
	if(emittingAutomata) //an automata is waiting
	{
		#ifdef DEBUG_TIMING
			cout << "rendezvous with " << waitingAutomata->toString() << endl;
		#endif
		m_pendingSignalEmitTab[sigEmitId] = NULL; //reset signal
		emittingAutomata->run(this);
		return true; //calling automata can resume
	} else { //no automata is waiting: no rendez-vous. Should wait.
		#ifdef DEBUG_TIMING
			cout << "have to wait" << endl;
		#endif
		m_pendingSignalWaitTab[sigWaitId] = waitingAutomata;
		return false; //calling automata should stop
	}
};

void arch::timingWaitForCycles(timingBase *automata,const u64 nbCycles)
{
	const u64 wakeUpDate = m_nbCycles + nbCycles;
	#ifdef DEBUG_TIMING
		cout << "automata " << automata->toString() << " will wake up at " << wakeUpDate << endl;
	#endif
	automata->setNextWakeUpDate(wakeUpDate);
	//insert in single linked list (and adjust m_timingNextWakeUp if required)
	timingBase *currentNode = m_timingListRoot;
	timingBase *previousNode = NULL;

	while(currentNode && (currentNode->nextWakeUpDate())<wakeUpDate)
	{
		previousNode = currentNode;
		currentNode = currentNode->next();
	}
	automata->setNext(currentNode); //may be NULL
	if(previousNode)
	{
		//not at the beginning
		previousNode->setNext(automata); //linked list.
	} else {
		//at the beginning
		m_timingListRoot = automata;
		m_timingNextWakeUp = wakeUpDate;
	}
}

void arch::manageTiming()
{
	//this function is called when m_timingNextWakeUp <= m_nbCycles
	while(m_timingNextWakeUp <= m_nbCycles)
	{
		timingBase *currentNode = m_timingListRoot;
		if(currentNode)
		{
			//remove the node.
			m_timingListRoot = currentNode->next();
			//run
			#ifdef DEBUG_TIMING
				cout << "wake up automata " << currentNode->toString() << " : " << m_nbCycles << endl;
			#endif
			currentNode->run(this);
			//re-init m_timingNextWakeUp
			if(m_timingListRoot)
				m_timingNextWakeUp = m_timingListRoot->nextWakeUpDate();
			else
				m_timingNextWakeUp = 0xFFFFFFFFFFFFFFFFULL; //max u64 value.
		}
	}
}
