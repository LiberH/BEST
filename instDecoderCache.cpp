/**
 * generated by HARMLESS : 'Hardware ARchitecture Modeling Language
 *                          for Embedded Software Simulation'
 * model : e200z4
 *
 */

#ifndef DO_NOT_USE_INTERNAL_INSTRUCTION_CACHE
#include <iostream>
#include "instDecoder.h"
#include "instDecoderCache.h"
#include "instructionBase.h" //for retain/release machanism.
#include "utils.h" //SEGFAULTIF
#include "arch.h"  //fetch function.

using namespace std;

e200z4_instDecoderCache::e200z4_instDecoderCache(const unsigned int indexLengthBits) :
m_indexLengthBits(indexLengthBits)
{
	const unsigned int max = 1 << m_indexLengthBits;
	m_buffer = new e200z4_instDecoderCacheEntry[max];

	VERBOSE("using decoder internal cache (direct) with " 
	        << dec << max << "elements.");

    //init buffer.
	for(unsigned int i = 0; i < max; i++)
	{
		m_buffer[i].control = 0;
		m_buffer[i].inst = NULL;
    }

	#ifdef INST_DECODER_CACHE_STATS
	    m_hitCount = 0;
		m_missCount = 0;
	#endif
}

void e200z4_instDecoderCache::printCacheStats()
{
	cout << dec <<"Internal decoder instruction cache Ratio" << endl;
	#ifdef INST_DECODER_CACHE_STATS
		const unsigned int nbAccesses = m_missCount + m_hitCount;
		cout << "	" << nbAccesses << " accesses." << endl;
		cout << "	Miss : " << m_missCount << endl;
		cout << "	Hit : " << m_hitCount << endl;
		cout << "	Hit Ratio : ";
		if(nbAccesses == 0) cout << "NaN" << endl;
		else cout << ((float)m_hitCount)/((float)nbAccesses) << endl;
	#else
		cout << "	to get hit/miss ratio, please recompile application with " << endl;
		cout << "	INST_DECODER_CACHE_STATS flag set." << endl;
	#endif
	int nbUse = 0;
	const unsigned int max = 1 << m_indexLengthBits;

	for(unsigned int i = 0; i < max; i++)
	{
		if((m_buffer[i].control >> IDC_VALID_OFFSET) & 0x1) nbUse++;
	}
	cout << "	cache contains : " << dec << nbUse << " instructions"<<endl;
	cout << "	(capacity is " << (max) << " instructions)" << endl;
	cout << "	cache use ratio : ";
	cout << (float)nbUse / (max) << endl;
}

e200z4_instruction *e200z4_instDecoderCache::getInstruction(arch *_arch, u32 &codeAddr, e200z4_instDecoder *decoder)
{
	const u32 addr = codeAddr >> 2;
	const int mask = (-1) << m_indexLengthBits;	
	SEGFAULTIF(32 > 32) //in this case, update mask type to 64 bits.
	const u32 index = addr & (~mask);
	const u32 tag = addr >> m_indexLengthBits;

	/* SEGFAULTIF(tag > (1<<IDC_TAG_SIZE)) // in that case, use a bigger cache. */
	
	e200z4_instruction *inst = isInBuffer(index, tag, codeAddr);
    if(inst) {
		#ifdef INST_DECODER_CACHE_STATS
			m_hitCount++;
		#endif
		inst->retain();
	}
	else {
        inst = storeInBuffer(_arch, codeAddr, decoder, index, tag);
		#ifdef INST_DECODER_CACHE_STATS
			m_missCount++;
		#endif
    }
    return inst;
}

e200z4_instruction *e200z4_instDecoderCache::isInBuffer(const u32 index, const u32 tag, u32 &codeAddr)
{
	e200z4_instruction *result = NULL;
	e200z4_instDecoderCacheEntry *entry = &(m_buffer[index]);
	const u32 entryCon=entry->control;
	if((entryCon >> IDC_VALID_OFFSET) & 0x1) //valid
    {
        if(tag == (entryCon >> IDC_TAG_OFFSET))
        {
			result = entry->inst;
			const u8 chunks = (entryCon >> IDC_CHUNKS_OFFSET) & IDC_CHUNKS_MASK;
			codeAddr += chunks<<2;
        }
    }
    return result;
}

e200z4_instruction *e200z4_instDecoderCache::storeInBuffer(arch *_arch,
									u32 &codeAddr,
									e200z4_instDecoder *decoder,	
									const u32 index, 
									const u32 tag)
{
	//cerr <<"store instruction @"<<hex <<codeAddr<<endl;
	//fetch function called in the decodeDirect function.
    e200z4_instruction *inst = decoder->decodeWithExecActionCache(_arch, codeAddr);
	const u8 chunks = inst->chunks();
	SEGFAULTIF(chunks >= IDC_CHUNKS_MAX);
	if(inst!= NULL)
	{
		inst -> retain();	//instruction can't be deleted as it is cached.
			
		e200z4_instDecoderCacheEntry *entry = &(m_buffer[index]);
	    if((entry->control >> IDC_VALID_OFFSET) & 0x1)
	    {
			//remove previous instruction
			e200z4_instruction *instToRemove = entry->inst;
			decoder->cacheRemoveInstruction(instToRemove);
			instToRemove->release();
			instToRemove = NULL;
	    } 
		//create the new entry: control : valid and tag
		u32 control = 1 << IDC_VALID_OFFSET;
		control |= chunks << IDC_CHUNKS_OFFSET; /* value < IDC_CHUNKS_MAX checked. */
		control |= tag << IDC_TAG_OFFSET;
		entry->control = control;
		entry->inst = inst;
	}
	return inst;
}

e200z4_instDecoderCache::~e200z4_instDecoderCache()
{
	//empty the instruction cache by deleting each instruction.
	const unsigned int max = 1 << m_indexLengthBits;
	for(unsigned int i = 0; i < max; i++)
	{
		e200z4_instDecoderCacheEntry *entry =  &(m_buffer[i]);
		e200z4_instruction * inst = entry->inst;
		//remove instruction
		inst->release();
    }
	delete [] m_buffer;
}

e200z4_instruction *e200z4_instDecoderCache::isInCache(const u32 codeAddr)
{
	u32 addr = codeAddr >> 2;
	const int mask = (-1) << m_indexLengthBits;	
	SEGFAULTIF(32 > 32) //in this case, update mask type to 64 bits.
	const u32 index = addr & (~mask);
	const u32 tag = addr >> m_indexLengthBits;

	/* SEGFAULTIF(tag > (1<<IDC_TAG_SIZE)) // in that case, use a bigger cache. */
	
	u32 tmp = codeAddr; //will be updated.. but not used after
	return isInBuffer(index, tag, tmp);
}

void e200z4_instDecoderCache::replaceInCache(const u32 codeAddr, e200z4_instruction *prevInst,executeInstAction *eia)
{
	u32 addr = codeAddr >> 2;
	const int mask = (-1) << m_indexLengthBits;	
	SEGFAULTIF(32 > 32) //in this case, update mask type to 64 bits.
	const u32 index = addr & (~mask);
	const u32 tag = addr >> m_indexLengthBits;

	e200z4_instDecoderCacheEntry *entry = &(m_buffer[index]);
	const u32 entryCon=entry->control;
	bool ok = false;
	if((entryCon >> IDC_VALID_OFFSET) & 0x1) //valid
    {
        if(tag == (entryCon >> IDC_TAG_OFFSET))
        {
			if((entry->inst) == prevInst)
			{
				entry->inst = eia;
				eia-> retain(); //instruction is now in cache.
				ok = true;
			}
        } 
    }
	if(!ok) {
		cerr << "internal error: replace an instruction not present in cache" << endl;
	}
}

#endif //DO_NOT_USE_INTERNAL_INSTRUCTION_CACHE
